<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dfm_tools.ttide.t_predic API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.ttide.t_predic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division
import numpy as np
from dfm_tools.ttide.t_getconsts import t_getconsts
from dfm_tools.ttide.t_vuf import t_vuf
from dfm_tools.ttide import time as tm


def t_predic(t_time, names, freq, tidecon,
             lat=None, ltype=&#39;nodal&#39;, synth=0):
    &#34;&#34;&#34;T_PREDIC Tidal prediction from tidal consituents.

    Parameters
    ----------
    time : array_like (N)
        The array of times at which to make predictions.
    names : array_like (M)
        The constituent name strings (e.g. [&#39;M2&#39;, &#39;S2&#39;, ...])
    freq : array_like (M)
        The frequencies, in cph.
    tidecon : array_like (M, P)
        The tidal constituent amplitudes, phases, and orientations. P
        is either 4 (for real output), or 8 (for complex output).
    lat : flaot
        decimal degrees (+north) (default: None)
        In the simplest case, the tidal analysis was done without nodal
        corrections, and thus neither will the prediction. If nodal
        corrections were used in the analysis, then it is likely we will
        want to use them in the prediction too and these are computed
        using the latitude, if given.
    ltype : {&#39;nodal&#39;, &#39;full&#39;}
        If the original analysis was &gt;18.6 years satellites are not
        included and we force that here. Use, &#39;full&#39; if the
        consituents were computed from data longer that &gt;18.6
        years. &#39;nodal&#39; (default) is if the analysis was &lt;18.6 years.
    synth : float
        The tidal prediction may be restricted to only some of the
        available constituents:
            0 - use all selected constituents (default)
           &gt;0 - use only those constituents with a SNR greater than
                that given (1 or 2 are good choices).

    Returns
    -------
    yout : array (N,)
        The predicted time series (real/scaler for P = 4,
        complex/vector for P = 8).

    &#34;&#34;&#34;

    longseries = 0  # Currently only timeseries &lt;18.6 years are supported.
    if t_time.dtype.name.startswith(&#39;datetime64&#39;) or t_time.dtype is np.dtype(&#34;O&#34;):
        t_time = tm.date2num(t_time)

    t_time = t_time.reshape(-1, 1)

    # Do the synthesis.
    snr = (tidecon[:, 0] / tidecon[:, 1]) ** 2
    # signal to noise ratio
    if synth &gt; 0:
        I = snr &gt; synth
        if not any(I):
            print(&#39;No predictions with this SNR&#39;)
            yout = np.nan + np.zeros(shape=(t_time.shape, t_time.shape),
                                     dtype=&#39;float64&#39;)
            return yout
        tidecon = tidecon[I, :]
        names = names[I]
        freq = freq[I]
    if tidecon.shape[1] == 4:
        # Real time series
        ap = np.multiply(tidecon[:, 0] / 2.0,
                         np.exp(-1j * tidecon[:, 2] * np.pi / 180))
        am = np.conj(ap)
    else:
        ap = np.multiply((tidecon[:, 0] + tidecon[:, 2]) / 2.0,
                         np.exp(1j * np.pi / 180 * (tidecon[:, 4] - tidecon[:, 6])))

        am = np.multiply((tidecon[:, 0] - tidecon[:, 2]) / 2.0,
                         np.exp(1j * np.pi / 180 * (tidecon[:, 4] + tidecon[:, 6])))

    # Mean at central point (get rid of one point at end to
    # take mean of odd number of points if necessary).
    jdmid = np.mean(t_time[0:((2 * int((max(t_time.shape) - 1) / 2)) + 1)])
    if longseries:
        const = t_get18consts
        ju = np.zeros(shape=(freq.shape, freq.shape), dtype=&#39;float64&#39;)
        for k in range(1, (names.shape[0] + 1)):
            inam = strmatch(names[(k - 1), :], const.name)
            if max(inam.shape) == 1:
                ju[(k - 1)] = inam
            else:
                if max(inam.shape) &gt; 1:
                    minf, iminf = np.min(abs(freq[(k - 1)] - const.freq(inam)))
                    ju[(k - 1)] = inam[(iminf - 1)]
    else:
        const, sat, cshallow = t_getconsts(np.array([]))
        ju = np.zeros((len(freq),), dtype=&#39;int32&#39;)
        # Check to make sure names and frequencies match expected values.
        for k in range(0, (names.shape[0])):
            ju[k] = np.argwhere(const[&#39;name&#39;] == names[(k)])
        # if any(freq~=const.freq(ju)),
        # error(&#39;Frequencies do not match names in input&#39;);
        # end;
    # Get the astronical argument with or without nodal corrections.
    if lat is not None and np.absolute(jdmid) &gt; 1:
        v, u, f = t_vuf(ltype, jdmid, ju, lat)
    else:
        if np.fabs(jdmid) &gt; 1:
            # a real date
            v, u, f = t_vuf(ltype, jdmid, ju)
        else:
            v = np.zeros((len(ju),), dtype=&#39;float64&#39;)
            u = v
            f = np.ones((len(ju),), dtype=&#39;float64&#39;)

    ap = ap * f * np.exp(+1j * 2 * np.pi * (u + v))
    am = am * f * np.exp(-1j * 2 * np.pi * (u + v))
    t_time = t_time - jdmid

    n, m = t_time.shape
    ntime = max(t_time.shape)
    nsub = 10000
    yout = np.zeros([n * m, ], dtype=&#39;complex128&#39;)

    # longer than one year hourly.
    for j1 in np.arange(0, ntime, nsub):
        j1 = j1.astype(int)
        j2 = np.min([j1 + nsub, ntime]).astype(int)
        tap = np.repeat(ap, j2 - j1).reshape(len(ap), j2 - j1)
        tam = np.repeat(am, j2 - j1).reshape(len(am), j2 - j1)

        touter = np.outer(24 * 1j * 2 * np.pi * freq, t_time[j1:j2])
        yout[j1:j2] = np.sum(np.multiply(np.exp(touter), tap), axis=0) +\
            np.sum(np.multiply(np.exp(-touter), tam), axis=0)

    if (tidecon.shape[1] == 4):
        return np.real(yout)
    else:
        return yout</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.ttide.t_predic.t_predic"><code class="name flex">
<span>def <span class="ident">t_predic</span></span>(<span>t_time, names, freq, tidecon, lat=None, ltype='nodal', synth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>T_PREDIC Tidal prediction from tidal consituents.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>array_like (N)</code></dt>
<dd>The array of times at which to make predictions.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>array_like (M)</code></dt>
<dd>The constituent name strings (e.g. ['M2', 'S2', &hellip;])</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>array_like (M)</code></dt>
<dd>The frequencies, in cph.</dd>
<dt><strong><code>tidecon</code></strong> :&ensp;<code>array_like (M, P)</code></dt>
<dd>The tidal constituent amplitudes, phases, and orientations. P
is either 4 (for real output), or 8 (for complex output).</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>flaot</code></dt>
<dd>decimal degrees (+north) (default: None)
In the simplest case, the tidal analysis was done without nodal
corrections, and thus neither will the prediction. If nodal
corrections were used in the analysis, then it is likely we will
want to use them in the prediction too and these are computed
using the latitude, if given.</dd>
<dt><strong><code>ltype</code></strong> :&ensp;<code>{'nodal', 'full'}</code></dt>
<dd>If the original analysis was &gt;18.6 years satellites are not
included and we force that here. Use, 'full' if the
consituents were computed from data longer that &gt;18.6
years. 'nodal' (default) is if the analysis was &lt;18.6 years.</dd>
<dt><strong><code>synth</code></strong> :&ensp;<code>float</code></dt>
<dd>The tidal prediction may be restricted to only some of the
available constituents:
0 - use all selected constituents (default)<blockquote>
<p>0 - use only those constituents with a SNR greater than
that given (1 or 2 are good choices).</p>
</blockquote>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>yout</code></strong> :&ensp;<code>array (N,)</code></dt>
<dd>The predicted time series (real/scaler for P = 4,
complex/vector for P = 8).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t_predic(t_time, names, freq, tidecon,
             lat=None, ltype=&#39;nodal&#39;, synth=0):
    &#34;&#34;&#34;T_PREDIC Tidal prediction from tidal consituents.

    Parameters
    ----------
    time : array_like (N)
        The array of times at which to make predictions.
    names : array_like (M)
        The constituent name strings (e.g. [&#39;M2&#39;, &#39;S2&#39;, ...])
    freq : array_like (M)
        The frequencies, in cph.
    tidecon : array_like (M, P)
        The tidal constituent amplitudes, phases, and orientations. P
        is either 4 (for real output), or 8 (for complex output).
    lat : flaot
        decimal degrees (+north) (default: None)
        In the simplest case, the tidal analysis was done without nodal
        corrections, and thus neither will the prediction. If nodal
        corrections were used in the analysis, then it is likely we will
        want to use them in the prediction too and these are computed
        using the latitude, if given.
    ltype : {&#39;nodal&#39;, &#39;full&#39;}
        If the original analysis was &gt;18.6 years satellites are not
        included and we force that here. Use, &#39;full&#39; if the
        consituents were computed from data longer that &gt;18.6
        years. &#39;nodal&#39; (default) is if the analysis was &lt;18.6 years.
    synth : float
        The tidal prediction may be restricted to only some of the
        available constituents:
            0 - use all selected constituents (default)
           &gt;0 - use only those constituents with a SNR greater than
                that given (1 or 2 are good choices).

    Returns
    -------
    yout : array (N,)
        The predicted time series (real/scaler for P = 4,
        complex/vector for P = 8).

    &#34;&#34;&#34;

    longseries = 0  # Currently only timeseries &lt;18.6 years are supported.
    if t_time.dtype.name.startswith(&#39;datetime64&#39;) or t_time.dtype is np.dtype(&#34;O&#34;):
        t_time = tm.date2num(t_time)

    t_time = t_time.reshape(-1, 1)

    # Do the synthesis.
    snr = (tidecon[:, 0] / tidecon[:, 1]) ** 2
    # signal to noise ratio
    if synth &gt; 0:
        I = snr &gt; synth
        if not any(I):
            print(&#39;No predictions with this SNR&#39;)
            yout = np.nan + np.zeros(shape=(t_time.shape, t_time.shape),
                                     dtype=&#39;float64&#39;)
            return yout
        tidecon = tidecon[I, :]
        names = names[I]
        freq = freq[I]
    if tidecon.shape[1] == 4:
        # Real time series
        ap = np.multiply(tidecon[:, 0] / 2.0,
                         np.exp(-1j * tidecon[:, 2] * np.pi / 180))
        am = np.conj(ap)
    else:
        ap = np.multiply((tidecon[:, 0] + tidecon[:, 2]) / 2.0,
                         np.exp(1j * np.pi / 180 * (tidecon[:, 4] - tidecon[:, 6])))

        am = np.multiply((tidecon[:, 0] - tidecon[:, 2]) / 2.0,
                         np.exp(1j * np.pi / 180 * (tidecon[:, 4] + tidecon[:, 6])))

    # Mean at central point (get rid of one point at end to
    # take mean of odd number of points if necessary).
    jdmid = np.mean(t_time[0:((2 * int((max(t_time.shape) - 1) / 2)) + 1)])
    if longseries:
        const = t_get18consts
        ju = np.zeros(shape=(freq.shape, freq.shape), dtype=&#39;float64&#39;)
        for k in range(1, (names.shape[0] + 1)):
            inam = strmatch(names[(k - 1), :], const.name)
            if max(inam.shape) == 1:
                ju[(k - 1)] = inam
            else:
                if max(inam.shape) &gt; 1:
                    minf, iminf = np.min(abs(freq[(k - 1)] - const.freq(inam)))
                    ju[(k - 1)] = inam[(iminf - 1)]
    else:
        const, sat, cshallow = t_getconsts(np.array([]))
        ju = np.zeros((len(freq),), dtype=&#39;int32&#39;)
        # Check to make sure names and frequencies match expected values.
        for k in range(0, (names.shape[0])):
            ju[k] = np.argwhere(const[&#39;name&#39;] == names[(k)])
        # if any(freq~=const.freq(ju)),
        # error(&#39;Frequencies do not match names in input&#39;);
        # end;
    # Get the astronical argument with or without nodal corrections.
    if lat is not None and np.absolute(jdmid) &gt; 1:
        v, u, f = t_vuf(ltype, jdmid, ju, lat)
    else:
        if np.fabs(jdmid) &gt; 1:
            # a real date
            v, u, f = t_vuf(ltype, jdmid, ju)
        else:
            v = np.zeros((len(ju),), dtype=&#39;float64&#39;)
            u = v
            f = np.ones((len(ju),), dtype=&#39;float64&#39;)

    ap = ap * f * np.exp(+1j * 2 * np.pi * (u + v))
    am = am * f * np.exp(-1j * 2 * np.pi * (u + v))
    t_time = t_time - jdmid

    n, m = t_time.shape
    ntime = max(t_time.shape)
    nsub = 10000
    yout = np.zeros([n * m, ], dtype=&#39;complex128&#39;)

    # longer than one year hourly.
    for j1 in np.arange(0, ntime, nsub):
        j1 = j1.astype(int)
        j2 = np.min([j1 + nsub, ntime]).astype(int)
        tap = np.repeat(ap, j2 - j1).reshape(len(ap), j2 - j1)
        tam = np.repeat(am, j2 - j1).reshape(len(am), j2 - j1)

        touter = np.outer(24 * 1j * 2 * np.pi * freq, t_time[j1:j2])
        yout[j1:j2] = np.sum(np.multiply(np.exp(touter), tap), axis=0) +\
            np.sum(np.multiply(np.exp(-touter), tam), axis=0)

    if (tidecon.shape[1] == 4):
        return np.real(yout)
    else:
        return yout</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools.ttide" href="index.html">dfm_tools.ttide</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfm_tools.ttide.t_predic.t_predic" href="#dfm_tools.ttide.t_predic.t_predic">t_predic</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>