<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dfm_tools.ttide.t_vuf API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.ttide.t_vuf</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division
import numpy as np
import scipy as sp
from dfm_tools.ttide.t_astron import t_astron
from dfm_tools.ttide.t_getconsts import t_getconsts


def t_vuf(ltype, ctime, ju, lat=None):
    &#34;&#34;&#34;T_VUF Computes nodal modulation corrections.
     [V,U,F]=T_VUF(TYPE,DATE,JU,LAT) returns the astronomical phase V, the
     nodal phase modulation U, and the nodal amplitude correction F at
     a decimal date DATE for the components specified by index JU
     at a latitude LAT.

     TYPE is either &#39;full&#39; for the 18.6 year set of constitunets, or &#39;nodal&#39;
     for the 1-year set with satellite modulations.

     If LAT is not specified, then the Greenwich phase V is computed with
     U=0 and F=1.

     Note that V and U are in &#39;cycles&#39;, not degrees or radians (i.e.,
     multiply by 360 to get degrees).

     If LAT is set to NaN, then the nodal corrections are computed for all
     satellites that do *not* have a &#34;latitude-dependent&#34; correction
     factor. This is for compatibility with the ways things are done in
     the xtide package. (The latitude-dependent corrections were zeroed
     out there partly because it was convenient, but this was rationalized
     by saying that since the forcing of tides can occur at latitudes
     other than where they are observed, the idea that observations have
     the equilibrium latitude-dependence is possibly bogus anyway).
     Get all the info about constituents.
     Calculate astronomical arguments at mid-point of data time series.
    &#34;&#34;&#34;

    astro, ader = t_astron(ctime)

    if 0:#ltype == &#39;full&#39;: #changed to if 0 to discable, this is not used in matlab
        const = t_get18consts(ctime)
        # Phase relative to Greenwich (in units of cycles).
        v = rem(np.dot(const.doodson, astro) + const.semi, 1)
        v = v[(ju - 1)]
        u = np.zeros(shape=(v.shape, v.shape), dtype=&#39;float64&#39;)
        f = np.ones(shape=(v.shape, v.shape), dtype=&#39;float64&#39;)
    else:
        const, sat, shallow = t_getconsts(ctime)
        # Phase relative to Greenwich (in units of cycles).
        # (This only returns values when we have doodson#s,
        # i.e., not for the shallow water components,
        # but these will be computed later.)
        v = np.fmod(np.dot(const[&#39;doodson&#39;], astro) + const[&#39;semi&#39;], 1)

        if lat is not None:
            # If we have a latitude, get nodal corrections.
            # Apparently the second-order terms in the tidal potential
            # go to zero at the equator, but the third-order terms
            # do not. Hence when trying to infer the third-order terms
            # from the second-order terms, the nodal correction factors
            # blow up. In order to prevent this, it is assumed that the
            # equatorial forcing is due to second-order forcing OFF the
            # equator, from about the 5 degree location. Latitudes are
            # hence (somewhat arbitrarily) forced to be no closer than
            # 5 deg to the equator, as per note in Foreman.
            if abs(lat) &lt; 5:
                lat = np.sign(lat) * 5
            slat = np.sin(np.pi * lat / 180)
            # Satellite amplitude ratio adjustment for latitude.
            rr = sat[&#39;amprat&#39;]
            # no amplitude correction
            if np.isfinite(lat):
                j = np.flatnonzero(sat[&#39;ilatfac&#39;] == 1)
                # latitude correction for diurnal constituents
                rr[j] = rr[j] * 0.36309 * (1.0 - 5.0 * slat * slat) / slat
                j = np.flatnonzero(sat[&#39;ilatfac&#39;] == 2)
                # latitude correction for semi-diurnal constituents
                rr[j] = rr[j] * 2.59808 * slat
            else:
                rr[sat[&#39;ilatfac&#39;] &gt; 0] = 0
            # Calculate nodal amplitude and phase corrections.
            uu = np.fmod(np.dot(sat[&#39;deldood&#39;], astro.T[
                         3:6]) + sat[&#39;phcorr&#39;], 1)
            # uu=uudbl-round(uudbl);  &lt;_ I think this was wrong.
            # The original
            #                         FORTRAN code is:  IUU=UUDBL
            #                                           UU=UUDBL-IUU
            #                         which is truncation.
            # Sum up all of the satellite factors for all satellites.
            nsat = np.max(sat[&#39;iconst&#39;].shape)
            nfreq = np.max(const[&#39;isat&#39;].shape)

            fsum = np.array(1 + sp.sparse.csr_matrix(
                (np.squeeze(rr * np.exp(1j * 2 * np.pi * uu)),
                 (np.arange(0, nsat), np.squeeze(sat[&#39;iconst&#39;] - 1))),
                shape=(nsat, nfreq)).sum(axis=0)).flatten()

            f = np.absolute(fsum)
            u = np.angle(fsum) / (2 * np.pi)

            # Compute amplitude and phase corrections
            # for shallow water constituents.
            for k in np.flatnonzero(np.isfinite(const[&#39;ishallow&#39;])):
                ik = ((const[&#39;ishallow&#39;][k] - 1 +
                       np.array(range(0, const[&#39;nshallow&#39;][k]))).astype(int))
                iname = shallow[&#39;iname&#39;][ik] - 1
                coef = shallow[&#39;coef&#39;][ik]
                f[k] = np.prod(np.power(f[iname], coef))
                u[k] = np.dot(u[iname], coef)
                v[k] = np.dot(v[iname], coef)

            f = f[ju]
            u = u[ju]
            v = v[ju]

        else:
            # Astronomical arguments only, no nodal corrections.
            # Compute phases for shallow water constituents.
            for k in np.flatnonzero(np.isfinite(const[&#39;ishallow&#39;])):
                ik = ((const[&#39;ishallow&#39;][k] - 1 +
                       np.array(range(0, const[&#39;nshallow&#39;][k]))).astype(int))
                v[k] = np.dot(v[shallow[&#39;iname&#39;][ik] - 1], shallow[&#39;coef&#39;][ik])

            v = v[ju]
            f = np.ones(len(v))
            u = np.zeros(len(v))

    return v, u, f</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.ttide.t_vuf.t_vuf"><code class="name flex">
<span>def <span class="ident">t_vuf</span></span>(<span>ltype, ctime, ju, lat=None)</span>
</code></dt>
<dd>
<div class="desc"><p>T_VUF Computes nodal modulation corrections.
[V,U,F]=T_VUF(TYPE,DATE,JU,LAT) returns the astronomical phase V, the
nodal phase modulation U, and the nodal amplitude correction F at
a decimal date DATE for the components specified by index JU
at a latitude LAT.</p>
<p>TYPE is either 'full' for the 18.6 year set of constitunets, or 'nodal'
for the 1-year set with satellite modulations.</p>
<p>If LAT is not specified, then the Greenwich phase V is computed with
U=0 and F=1.</p>
<p>Note that V and U are in 'cycles', not degrees or radians (i.e.,
multiply by 360 to get degrees).</p>
<p>If LAT is set to NaN, then the nodal corrections are computed for all
satellites that do <em>not</em> have a "latitude-dependent" correction
factor. This is for compatibility with the ways things are done in
the xtide package. (The latitude-dependent corrections were zeroed
out there partly because it was convenient, but this was rationalized
by saying that since the forcing of tides can occur at latitudes
other than where they are observed, the idea that observations have
the equilibrium latitude-dependence is possibly bogus anyway).
Get all the info about constituents.
Calculate astronomical arguments at mid-point of data time series.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t_vuf(ltype, ctime, ju, lat=None):
    &#34;&#34;&#34;T_VUF Computes nodal modulation corrections.
     [V,U,F]=T_VUF(TYPE,DATE,JU,LAT) returns the astronomical phase V, the
     nodal phase modulation U, and the nodal amplitude correction F at
     a decimal date DATE for the components specified by index JU
     at a latitude LAT.

     TYPE is either &#39;full&#39; for the 18.6 year set of constitunets, or &#39;nodal&#39;
     for the 1-year set with satellite modulations.

     If LAT is not specified, then the Greenwich phase V is computed with
     U=0 and F=1.

     Note that V and U are in &#39;cycles&#39;, not degrees or radians (i.e.,
     multiply by 360 to get degrees).

     If LAT is set to NaN, then the nodal corrections are computed for all
     satellites that do *not* have a &#34;latitude-dependent&#34; correction
     factor. This is for compatibility with the ways things are done in
     the xtide package. (The latitude-dependent corrections were zeroed
     out there partly because it was convenient, but this was rationalized
     by saying that since the forcing of tides can occur at latitudes
     other than where they are observed, the idea that observations have
     the equilibrium latitude-dependence is possibly bogus anyway).
     Get all the info about constituents.
     Calculate astronomical arguments at mid-point of data time series.
    &#34;&#34;&#34;

    astro, ader = t_astron(ctime)

    if 0:#ltype == &#39;full&#39;: #changed to if 0 to discable, this is not used in matlab
        const = t_get18consts(ctime)
        # Phase relative to Greenwich (in units of cycles).
        v = rem(np.dot(const.doodson, astro) + const.semi, 1)
        v = v[(ju - 1)]
        u = np.zeros(shape=(v.shape, v.shape), dtype=&#39;float64&#39;)
        f = np.ones(shape=(v.shape, v.shape), dtype=&#39;float64&#39;)
    else:
        const, sat, shallow = t_getconsts(ctime)
        # Phase relative to Greenwich (in units of cycles).
        # (This only returns values when we have doodson#s,
        # i.e., not for the shallow water components,
        # but these will be computed later.)
        v = np.fmod(np.dot(const[&#39;doodson&#39;], astro) + const[&#39;semi&#39;], 1)

        if lat is not None:
            # If we have a latitude, get nodal corrections.
            # Apparently the second-order terms in the tidal potential
            # go to zero at the equator, but the third-order terms
            # do not. Hence when trying to infer the third-order terms
            # from the second-order terms, the nodal correction factors
            # blow up. In order to prevent this, it is assumed that the
            # equatorial forcing is due to second-order forcing OFF the
            # equator, from about the 5 degree location. Latitudes are
            # hence (somewhat arbitrarily) forced to be no closer than
            # 5 deg to the equator, as per note in Foreman.
            if abs(lat) &lt; 5:
                lat = np.sign(lat) * 5
            slat = np.sin(np.pi * lat / 180)
            # Satellite amplitude ratio adjustment for latitude.
            rr = sat[&#39;amprat&#39;]
            # no amplitude correction
            if np.isfinite(lat):
                j = np.flatnonzero(sat[&#39;ilatfac&#39;] == 1)
                # latitude correction for diurnal constituents
                rr[j] = rr[j] * 0.36309 * (1.0 - 5.0 * slat * slat) / slat
                j = np.flatnonzero(sat[&#39;ilatfac&#39;] == 2)
                # latitude correction for semi-diurnal constituents
                rr[j] = rr[j] * 2.59808 * slat
            else:
                rr[sat[&#39;ilatfac&#39;] &gt; 0] = 0
            # Calculate nodal amplitude and phase corrections.
            uu = np.fmod(np.dot(sat[&#39;deldood&#39;], astro.T[
                         3:6]) + sat[&#39;phcorr&#39;], 1)
            # uu=uudbl-round(uudbl);  &lt;_ I think this was wrong.
            # The original
            #                         FORTRAN code is:  IUU=UUDBL
            #                                           UU=UUDBL-IUU
            #                         which is truncation.
            # Sum up all of the satellite factors for all satellites.
            nsat = np.max(sat[&#39;iconst&#39;].shape)
            nfreq = np.max(const[&#39;isat&#39;].shape)

            fsum = np.array(1 + sp.sparse.csr_matrix(
                (np.squeeze(rr * np.exp(1j * 2 * np.pi * uu)),
                 (np.arange(0, nsat), np.squeeze(sat[&#39;iconst&#39;] - 1))),
                shape=(nsat, nfreq)).sum(axis=0)).flatten()

            f = np.absolute(fsum)
            u = np.angle(fsum) / (2 * np.pi)

            # Compute amplitude and phase corrections
            # for shallow water constituents.
            for k in np.flatnonzero(np.isfinite(const[&#39;ishallow&#39;])):
                ik = ((const[&#39;ishallow&#39;][k] - 1 +
                       np.array(range(0, const[&#39;nshallow&#39;][k]))).astype(int))
                iname = shallow[&#39;iname&#39;][ik] - 1
                coef = shallow[&#39;coef&#39;][ik]
                f[k] = np.prod(np.power(f[iname], coef))
                u[k] = np.dot(u[iname], coef)
                v[k] = np.dot(v[iname], coef)

            f = f[ju]
            u = u[ju]
            v = v[ju]

        else:
            # Astronomical arguments only, no nodal corrections.
            # Compute phases for shallow water constituents.
            for k in np.flatnonzero(np.isfinite(const[&#39;ishallow&#39;])):
                ik = ((const[&#39;ishallow&#39;][k] - 1 +
                       np.array(range(0, const[&#39;nshallow&#39;][k]))).astype(int))
                v[k] = np.dot(v[shallow[&#39;iname&#39;][ik] - 1], shallow[&#39;coef&#39;][ik])

            v = v[ju]
            f = np.ones(len(v))
            u = np.zeros(len(v))

    return v, u, f</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools.ttide" href="index.html">dfm_tools.ttide</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfm_tools.ttide.t_vuf.t_vuf" href="#dfm_tools.ttide.t_vuf.t_vuf">t_vuf</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>