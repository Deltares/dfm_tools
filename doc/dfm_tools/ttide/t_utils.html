<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dfm_tools.ttide.t_utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.ttide.t_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division, print_function
import numpy as np
import scipy.signal as sps
import sys
from dfm_tools.ttide.t_getconsts import t_getconsts
from dfm_tools.ttide import time

try:
    import pandas as pd
except ImportError:
    pd = None


np.set_printoptions(precision=8, suppress=True)

try:
    enc = sys.stdout.encoding
except AttributeError:
    enc = &#39;UTF-8&#39;

if enc is None:
    # This is for piping/writing stdout to file, e.g. using &#39;&gt;&#39;
    enc = &#39;UTF-8&#39;


def fourpad(conin):
    conin = np.array(conin, dtype=&#39;|S4&#39;)
    for i, con in enumerate(conin):
        conin[i] = con.ljust(4)

    return conin


def constituents(minres, constit, shallow, infname, infref, centraltime):
    &#34;&#34;&#34;[name,freq,kmpr]=constituents(minres,infname) loads tidal constituent
     table (containing 146 constituents), then picks out only the &#39;
     resolvable&#39; frequencies (i.e. those that are MINRES apart), base on
     the comparisons in the third column of constituents.dat. Only
     frequencies in the &#39;standard&#39; set of 69 frequencies are actually used.
     Also return the indices of constituents to be inferred.
     If we have the mat-file, read it in, otherwise create it and read
     it in!
     R Pawlowicz 9/1/01
     Version 1.0

        19/1/02 - typo fixed (thanks to  Zhigang Xu)
     Compute frequencies from astronomical considerations.
    &#34;&#34;&#34;
    if 1:#minres &gt; 1 / (18.6 * 365.25 * 24): #changed to 1 since second loop is not in matlab anymore
        # Choose only resolveable pairs for short
        const, sat, cshallow = t_getconsts(centraltime)
        # Time series
        ju = np.flatnonzero(const[&#39;df&#39;] &gt;= minres)
    else:
        # Choose them all if &gt; 18.6 years.
        const, sat, cshallow = t_get18consts(centraltime)
        
        ju = np.array([range(2,
                             (max(const[&#39;freq&#39;].shape)+1))]).reshape(1, -1).T
        # Skip Z0
        for ff in range(1, 3):
            # loop twice to make sure of neightbouring pairs
            jck = np.flatnonzero(np.diff(const[&#39;freq&#39;][ju]) &lt; minres)
            if (max(jck.shape) &gt; 0):
                jrm = jck
                jrm = jrm + (abs(const[&#39;doodsonamp&#39;][ju[(jck + 1 - 1)]]) &lt;
                             abs(const[&#39;doodsonamp&#39;][ju[(jck - 1)]]))
# disp(&#39;  Warning! Following constituent pairs violate Rayleigh criterion&#39;)
#               for ick in range(1, (max(jck.shape) +1)):
#                    disp(&#39;     &#39; + const.name(ju[(jck[(ick -1)] -1)], :)
# + &#39; vs &#39; + const.name(ju[(jck[(ick -1)] + 1 -1)], :) + &#39; - not using &#39; +
# const.name(ju[(jrm[(ick -1)] -1)], :))
                ju[(jrm - 1)] = np.array([])

    if constit.size:
        # Selected if constituents are specified in input.
        ju = np.array([], dtype=int)
        for k in range(0, (constit.shape[0])):
            j1 = np.where(const[&#39;name&#39;] == constit[k])[0]
            if (j1.size == 0):
                print(&#34;Can&#39;t recognize name &#34; +
                      constit[k].decode(enc) +
                      &#39; for forced search&#39;)
            else:
                ju = np.append(ju, j1)

        # sort in ascending order of frequency.
        II = np.argsort(const[&#39;freq&#39;][ju])
        ju = ju[II]

    # cout
    # disp([&#39;   number of standard constituents used: &#39;,int2str(length(ju))])
    if shallow.size != 0:
        # Add explictly selected shallow water constituents.
        for k in range(0, (shallow.shape[0])):
            j1 = np.where(const[&#39;name&#39;] == shallow[k])[0]
            if (j1.size == 0):
                print(&#34;Can&#39;t recognize name &#34; +
                      shallow[k].decode(enc) +
                      &#39; for forced search&#39;)
            else:
                ju = np.append(ju, j1)

    nameu = const[&#39;name&#39;][ju]
    fu = const[&#39;freq&#39;][ju]

    # Check if neighboring chosen constituents violate Rayleigh criteria.
    jck = np.flatnonzero(np.diff(fu) &lt; minres)
    # cout
    # if (length(jck)&gt;0)
    # disp([&#39;  Warning! Following constituent
    # pairs violate Rayleigh criterion&#39;]);
    # for ick=1:length(jck);
    # disp([&#39;     &#39;,nameu(jck(ick),:),&#39;  &#39;,nameu(jck(ick)+1,:)]);
    # end;
    # end
    # For inference, add in list of components to be inferred.
    fi = np.array([])
    namei = np.array([])
    jinf = np.array([])
    jref = np.array([])
    if infname.size != 0:
        fi = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;)
        namei = np.zeros(shape=(infname.shape[0], 4), dtype=&#39;float64&#39;)
        jinf = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;) + np.NaN
        jref = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;) + np.NaN
        for k in range(1, (infname.shape[0] + 1)):
            j1 = strmatch(infname[(k - 1), :], const.name)
            if (0 in j1.shape):
                print(&#34;Can&#39;t recognize name&#34; +
                      infname[(k - 1), :] + &#39; for inference&#39;)
            else:
                jinf[(k - 1)] = j1
                fi[(k - 1)] = const[&#39;freq&#39;][j1]
                namei[(k - 1), :] = const[&#39;name&#39;][j1, :]
                j1 = strmatch(infref[(k - 1), :], nameu)
                if (0 in j1.shape):
                    print(&#34;Can&#39;t recognize name &#34; + infref[(k - 1), :] +
                          &#39; for as a reference for inference&#39;)
                else:
                    jref[(k - 1)] = j1
                    print(&#39;   Inference of &#39; + namei[(k - 1), :] +
                          &#39; using &#39; + nameu[(j1 - 1), :] + &#39;\\n&#39;)
        jinf[(np.isnan(jref) - 1)] = np.NaN
    return nameu, fu, ju, namei, fi, jinf, jref


def fixgaps(x):
    &#34;&#34;&#34;FIXGAPS: Linearly interpolates gaps in a time series
     YOUT=FIXGAPS(YIN) linearly interpolates over NaN in the input time
     series (may be complex), but ignores trailing and leading NaNs.
     R. Pawlowicz 11/6/99
     Version 1.0
    &#34;&#34;&#34;
    

    #find nans
    bd = np.isnan(x)

    #early exit if there are no nans  
    if not bd.any():
        return x
    
    #find nonnans index numbers
    gd = np.flatnonzero(~bd)
    
    if len(gd) == 0:
        raise Exception(&#39;ERROR: array with only nans provided, cannot continue&#39;)
    #ignore leading and trailing nans
    bd[:gd.min()]=False
    bd[(gd.max()+1):]=False
    
    #interpolate nans
    x[bd] = np.interp(np.flatnonzero(bd),gd,x[gd])

    return x

def cluster(ain, clusang):
    &#34;&#34;&#34;CLUSTER: Clusters angles in rows around the angles in the first
     column. CLUSANG is the allowable ambiguity (usually 360 degrees but
     sometimes 180).
    &#34;&#34;&#34;

    makearray = (ain - np.repeat(ain[:, 0],
                                 ain.shape[1]).reshape(ain.shape[0], ain.shape[1]))
    ii = makearray &gt; clusang / 2
    ain[(ii)] = ain[(ii)] - clusang
    ii = (ain - np.repeat(ain[:, 0],
                          ain.shape[1]).reshape(ain.shape[0], ain.shape[1])) &lt; - clusang / 2
    ain[(ii)] = ain[(ii)] + clusang
    return ain


def noise_realizations(xres, fu, dt, nreal, errcalc):
    &#34;&#34;&#34;NOISE_REALIZATIONS: Generates matrices of noise (with correct
     cross-correlation structure) for bootstrap analysis.

     R. Pawlowicz 11/10/00
     Version 1.0
    &#34;&#34;&#34;
    if errcalc == &#39;cboot&#39;:
        fband, Pxrave, Pxiave, Pxcave = residual_spectrum(xres, fu, dt)
        aaa, bbb = Pxcave.shape
        Pxcave = np.zeros((aaa, bbb), dtype=&#39;float64&#39;)
        # For comparison with other technique!
        # print(&#39;**** Assuming no covariance between u and v errors!******\n&#39;);
    else:
        if errcalc == &#39;wboot&#39;:
            fband = np.array([0, 0.5]).reshape(1, -1)
            nx = max(xres.shape)
            A = np.cov(np.real(xres), np.imag(xres)) / nx
            Pxrave = np.array([A[0, 0]])
            Pxiave = np.array([A[1, 1]])
            Pxcave = np.array([A[0, 1]])
        else:
            sys.exit(&#34;Unrecognized type of bootstap analysis specified: &#39;&#34; +
                     errcalc + &#34;&#39;&#34;)

    nfband = fband.shape[0]
    Mat = np.zeros(shape=(4, 4, nfband), dtype=&#39;float64&#39;)
    for k in range(1, (nfband + 1)):
        # The B matrix represents the covariance matrix for the vector
        # [Re{ap} Im{ap} Re{am} Im{am}]&#39; where Re{} and Im{} are real and
        # imaginary parts, and ap/m represent the complex constituent
        # amplitudes for positive and negative frequencies when the input
        # is bivariate white noise. For a flat residual spectrum this works
        # fine.
        # This is adapted here for &#34;locally white&#34; conditions, but I&#39;m still
        # not sure how to handle a complex sxy, so this is set to zero
        # right now.
        p = (Pxrave[(k - 1)] + Pxiave[(k - 1)]) / 2
        d = (Pxrave[(k - 1)] - Pxiave[(k - 1)]) / 2
        sxy = Pxcave[(k - 1)]
        B = np.hstack([p, 0, d, sxy,
                       0, p, sxy, -d,
                       d, sxy, p, 0,
                       sxy, -d, 0, p]).reshape(4, 4)
        # Compute the transformation matrix that takes uncorrelated white
        # noise and makes noise with the same statistical structure as the
        # Fourier transformed noise.

        D, V = np.linalg.eigh(B)

        # next five lines are horrible coding/math someone should check it over
        # swap so the vectors match matlab, should check if this always holds
        V[[1, 0], [1, 3]] = V[[0, 1], [3, 1]]
        V[[3, 2], [1, 3]] = V[[2, 3], [3, 1]]
        # total cludge to deal with bad zeroing in eigh
        D[((D &lt; 0) &amp; (D &gt; -0.00000000001))] = 0

        Mat[:, :, (k - 1)] = np.dot(V, np.diag(np.sqrt(D)))
        # print Mat
    # Generate realizations for the different analyzed constituents.
    N = np.zeros(shape=(4, nreal), dtype=&#39;float64&#39;)
    NM = np.zeros(shape=(max(fu.shape), nreal), dtype=&#39;complex128&#39;)
    NP = np.zeros(shape=(max(fu.shape), nreal), dtype=&#39;complex128&#39;)

    for k in range(0, fu.shape[0]):
        l = np.squeeze(np.flatnonzero(np.all([fu[k] &gt; fband[:, 0],
                                              fu[k] &lt; fband[:, 1]], axis=0)))
        N = np.hstack([np.zeros(4,).reshape(-1, 1),
                       np.dot(np.squeeze(Mat[:, :, l]),
                              np.random.randn(4, nreal - 1))])
        NP[(k), :] = (N[0, :] + 1j * N[1, :])
        NM[(k), :] = (N[2, :] + 1j * N[3, :])

    return NP, NM


def residual_spectrum(xres, fu, dt):
    &#34;&#34;&#34;RESIDUAL_SPECTRUM: Computes statistics from an input spectrum over
     a number of bands, returning the band limits and the estimates for
     power spectra for real and imaginary parts and the cross-spectrum.

     Mean values of the noise spectrum are computed for the following
     8 frequency bands defined by their center frequency and band width:
     M0 +.1 cpd; M1 +-.2 cpd; M2 +-.2 cpd; M3 +-.2 cpd; M4 +-.2 cpd;
     M5 +-.2 cpd; M6 +-.21 cpd; M7 (.26-.29 cpd); and M8 (.30-.50 cpd).
     S. Lentz  10/28/99
     R. Pawlowicz 11/1/00
     Version 1.0
     Define frequency bands for spectral averaging.
    &#34;&#34;&#34;
    fband = np.array([[0.0001, 0.00417],
                      [0.03192, 0.04859],
                      [0.07218, 0.08884],
                      [0.11243, 0.1291],
                      [0.15269, 0.16936],
                      [0.19295, 0.20961],
                      [0.2332, 0.251],
                      [0.26, 0.29],
                      [0.3, 0.5]])

    # If we have a sampling interval&gt; 1 hour, we might have to get
    # rid of some bins.
    # fband(fband(:,1)&gt;1/(2*dt),:)=[];
    nfband = fband.shape[0]
    nx = max(xres.shape)

    # Spectral estimate (takes real time series only).
    fx, Pxr = sps.welch(np.real(xres), window=np.hanning(nx),
                        noverlap=np.ceil(nx / 2), nfft=nx, fs=1 / dt, nperseg=nx)
    Pxr = Pxr / 2 / dt
    fx, Pxi = sps.welch(np.imag(xres), window=np.hanning(nx),
                        noverlap=np.ceil(nx / 2), nfft=nx, fs=1 / dt, nperseg=nx)
    Pxi = Pxi / 2 / dt
    #Pxc, fx = mplm.csd(np.real(xres), np.imag(xres), nx, 1 / dt)
    fx, Pxc = sps.csd(np.real(xres), np.imag(xres), fs=1 / dt, nperseg=nx, nfft=nx, )

    # matlab cpsd returns only reals when given a real xres have to
    # test for complex and maybe change to ifstatement
    Pxc = np.real(Pxc)
    Pxc = Pxc / 2 / dt
    df = fx[2] - fx[1]

    # Sets Px=NaN in bins close to analyzed frequencies
    # to prevent leakage problems?).
    Pxr[np.around(fu / df).astype(int)] = np.nan
    Pxi[np.around(fu / df).astype(int)] = np.nan
    Pxc[np.around(fu / df).astype(int)] = np.nan

    Pxrave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)
    Pxiave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)
    Pxcave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)

    # Loop downwards in frequency through bands (cures short time series
    # problem with no data in lowest band).
    # Divide by nx to get power per frequency bin, and multiply by 2
    # to account for positive and negative frequencies.
    for k in range(nfband - 1, -1, - 1):
        jband = np.flatnonzero(np.all(np.vstack([fx &gt;= fband[(k), 0],
                                                 fx &lt;= fband[(k), 1],
                                                 np.isfinite(Pxr)]).T, axis=1))
        if any(jband):
            Pxrave[k] = 2 * np.mean(Pxr[(jband)]) / nx
            Pxiave[k] = 2 * np.mean(Pxi[(jband)]) / nx
            Pxcave[k] = 2 * np.mean(Pxc[(jband)]) / nx
        else:
            if k &lt; nfband:
                Pxrave[k] = Pxrave[(k + 1)]
                # Low frequency bin might not have any points...
                Pxiave[k] = Pxiave[(k + 1)]
                Pxcave[k] = Pxcave[(k + 1)]

    return fband, Pxrave, Pxiave, Pxcave


def noise_stats(xres, fu, dt):
    &#34;&#34;&#34;NOISE_STATS: Computes statistics of residual energy for all
     constituents (ignoring any cross-correlations between real and
     imaginary parts).
     S. Lentz  10/28/99
     R. Pawlowicz 11/1/00
     Version 1.0
    &#34;&#34;&#34;
    fband, Pxrave, Pxiave, Pxcave = residual_spectrum(xres, fu, dt)
    nfband = fband.shape[0]
    mu = max(fu.shape)
    # Get the statistics for each component.
    ercx = np.zeros(shape=(mu, 1), dtype=&#39;float64&#39;)
    eicx = np.zeros(shape=(mu, 1), dtype=&#39;float64&#39;)
    for k1 in range(0, nfband):
        k = np.flatnonzero(np.all([fu &gt;= fband[k1, 0],
                                   fu &lt;= fband[k1, 1]], axis=0))
        ercx[(k)] = np.sqrt(Pxrave[(k1)])
        eicx[(k)] = np.sqrt(Pxiave[(k1)])
    return ercx, eicx


def errell(cxi, sxi, ercx, ersx, ercy, ersy):
    &#34;&#34;&#34;[emaj,emin,einc,epha]=errell(cx,sx,cy,sy,ercx,ersx,ercy,ersy) computes
     the uncertainities in the ellipse parameters based on the
     uncertainities in the least square fit cos,sin coefficients.

      INPUT:  cx,sx=cos,sin coefficients for x
              cy,sy=cos,sin coefficients for y
              ercx,ersx=errors in x cos,sin coefficients
              ercy,ersy=errors in y cos,sin coefficients

      OUTPUT: emaj=major axis error
              emin=minor axis error
              einc=inclination error (deg)
              epha=pha error (deg)
     based on linear error propagation, with errors in the coefficients
     cx,sx,cy,sy uncorrelated.
     B. Beardsley  1/15/99; 1/20/99
     Version 1.0
    &#34;&#34;&#34;
    r2d = 180.0 / np.pi
    cx = np.real(cxi[:])
    sx = np.real(sxi[:])
    cy = np.imag(cxi[:])
    sy = np.imag(sxi[:])
    ercx = ercx[:]
    ersx = ersx[:]
    ercy = ercy[:]
    ersy = ersy[:]
    rp = 0.5 * np.sqrt((cx + sy) ** 2 + (cy - sx) ** 2)
    rm = 0.5 * np.sqrt((cx - sy) ** 2 + (cy + sx) ** 2)
    ercx2 = ercx ** 2
    ersx2 = ersx ** 2
    ercy2 = ercy ** 2
    ersy2 = ersy ** 2
    # major axis error
    ex = (cx + sy) / rp
    fx = (cx - sy) / rm
    gx = (sx - cy) / rp
    hx = (sx + cy) / rm
    dcx2 = (0.25 * (ex + fx)) ** 2
    dsx2 = (0.25 * (gx + hx)) ** 2
    dcy2 = (0.25 * (hx - gx)) ** 2
    dsy2 = (0.25 * (ex - fx)) ** 2
    emaj = np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                   dcy2 * ercy2 + dsy2 * ersy2)
    # minor axis error
    dcx2 = (0.25 * (ex - fx)) ** 2
    dsx2 = (0.25 * (gx - hx)) ** 2
    dcy2 = (0.25 * (hx + gx)) ** 2
    dsy2 = (0.25 * (ex + fx)) ** 2
    emin = np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                   dcy2 * ercy2 + dsy2 * ersy2)
    # inclination error
    rn = 2.0 * (cx * cy + sx * sy)
    rd = cx ** 2 + sx ** 2 - (cy ** 2 + sy ** 2)
    den = rn ** 2 + rd ** 2
    dcx2 = ((rd * cy - rn * cx) / den) ** 2
    dsx2 = ((rd * sy - rn * sx) / den) ** 2
    dcy2 = ((rd * cx + rn * cy) / den) ** 2
    dsy2 = ((rd * sx + rn * sy) / den) ** 2
    einc = r2d * np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                         dcy2 * ercy2 + dsy2 * ersy2)
    # phase error
    rn = 2.0 * (cx * sx + cy * sy)
    rd = cx ** 2 - sx ** 2 + cy ** 2 - sy ** 2
    den = rn ** 2 + rd ** 2
    dcx2 = ((rd * sx - rn * cx) / den) ** 2
    dsx2 = ((rd * cx + rn * sx) / den) ** 2
    dcy2 = ((rd * sy - rn * cy) / den) ** 2
    dsy2 = ((rd * cy + rn * sy) / den) ** 2
    epha = r2d * np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                         dcy2 * ercy2 + dsy2 * ersy2)

    return emaj, emin, einc, epha


def variance_str(out):
    &#39;&#39;&#39;Takes the out dictionary and prints the variance text&#39;&#39;&#39;

    x = np.var(out[&#39;xingd&#39;].real, ddof=1)
    xp = np.var(out[&#39;xoutgd&#39;].real, ddof=1)
    xr = np.var(out[&#39;xresgd&#39;].real, ddof=1)
    z0r = out[&#39;z0&#39;].real
    dz0r = out[&#39;dz0&#39;].real

    outstr = &#39;x0= {:.3g}  xtrend= {:.3g}\n&#39;.format(z0r, dz0r)
    outstr += (&#39;var(data)= {:.2f}&#39; + &#39; &#39; * 4 +
               &#39;var(prediction)= {:.2f}&#39; + &#39; &#39; * 4 +
               &#39;var(residual)= {:.2f}\n&#39;).format(x, xp, xr)
    outstr += &#39;var(prediction)/var(data) (%%) = %.1f\n\n&#39; % (100 * xp / x)

    if np.iscomplexobj(out[&#39;xin&#39;]):
        y = np.var(out[&#39;xingd&#39;].imag, ddof=1)
        yp = np.var(out[&#39;xoutgd&#39;].imag, ddof=1)
        yr = np.var(out[&#39;xresgd&#39;].imag, ddof=1)
        z0r = out[&#39;z0&#39;].imag
        dz0r = out[&#39;dz0&#39;].imag

        outstr += &#39;y0= {:.3g}  ytrend= {:.3g}\n&#39;.format(z0r, dz0r)
        outstr += (&#39;var(data)= {:.2f}&#39; + &#39; &#39; * 4 +
                   &#39;var(prediction)= {:.2f}&#39; + &#39; &#39; * 4 +
                   &#39;var(residual)= {:.2f}\n&#39;).format(y, yp, yr)
        outstr += &#39;var(prediction)/var(data) (%) = {:.1f}\n\n&#39;.format(
            100 * yp / y)

        outstr += &#39;total_var= {:f} pred_var=  {:f}\n&#39;.format(
            (x + y), (xp + yp))
        outstr += &#39;total_var/pred_var (%) =  {:.1f}  \n&#39;.format(
            100 * (xp + yp) / (x + y))
    return outstr


def classic_style(out):
    outstr = &#39;-&#39; * 35 + &#39;\n&#39;
    outstr += (&#39;nobs = %d \nngood = %d \nrecord length (days) = %.2f&#39; %
               (out[&#39;nobs&#39;], out[&#39;ngood&#39;],
                np.dot(max(out[&#39;xin&#39;].shape), out[&#39;dt&#39;]) / 24)) + &#39;\n&#39;
    if (&#39;stime&#39; in out):
        outstr += &#39;start time: {}\n&#39;.format(
            time.num2date(out[&#39;stime&#39;]).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))
    outstr += (&#39;rayleigh criterion = %.1f\n\n&#39; % out[&#39;ray&#39;])
    outstr += (&#39;%s\n&#39; % out[&#39;nodcor&#39;])
    outstr += variance_str(out)

    if out[&#39;isComplex&#39;]:
        outstr += (&#39; &#39; * 32 + &#39;ellipse parameters with 95 % CI estimates\n&#39;)
        outstr += (&#39; tide     freq        major      emaj&#39; +
                   &#39;      minor      emin     inc      einc&#39; +
                   &#39;      pha       epha      snr\n&#39;)
        fmt = (&#39;{star} {name}  {fuk:9.7f}  &#39;
               &#39;{c[0]:9.4f}  {c[1]:8.3f} {c[2]:9.4f}  {c[3]:8.3f} &#39;
               &#39;{c[4]:8.2f}  {c[5]:8.2f}  {c[6]:8.2f}  {c[7]:8.2f} &#39;
               &#39;{snr:8.2g}\n&#39;)
        for k, fuk in enumerate(out[&#39;fu&#39;]):
            if out[&#39;snr&#39;][k] &gt; out[&#39;synth&#39;]:
                star = &#39;*&#39;
            else:
                star = &#39; &#39;
            outstr += fmt.format(star=star,
                                 name=out[&#39;nameu&#39;][k].decode(enc),
                                 fuk=fuk,
                                 c=out[&#39;tidecon&#39;][k],
                                 snr=out[&#39;snr&#39;][k])
    else:
        outstr += &#39;        tidal amplitude and phase with 95 % CI estimates\n&#39;
        outstr += (&#39; tide      freq        amp      amp_err&#39; +
                   &#39;   pha      pha_err    snr\n&#39;)
        fmt = (&#39;{star} {name}  {fuk:9.7f}  &#39;+
               &#39;{c[0]:9.4f}  {c[1]:8.3f}  {c[2]:8.2f}  {c[3]:8.2f}  &#39;+ #EDIT: replaced comma by +
               &#39;{snr:8.2g}\n&#39;)                                         #EDIT: replaced comma by +
        for k, fuk in enumerate(out[&#39;fu&#39;]):
            if out[&#39;snr&#39;][k] &gt; out[&#39;synth&#39;]:
                star = &#39;*&#39;
            else:
                star = &#39; &#39;
            outstr += fmt.format(star=star,
                                 name=out[&#39;nameu&#39;][k].decode(enc),  
                                 fuk=fuk,                           
                                 c=out[&#39;tidecon&#39;][k],    
                                 snr=out[&#39;snr&#39;][k])
    return outstr


def pandas_style(out, dfTF=False):
    if pd is None:
        # Unable to import pandas.
        print(&#34;pandas is not available, falling back to out_style=&#39;classic&#39;.&#34;)
        return classic_style(out)
    spacer = 70
    if out[&#39;isComplex&#39;]:
        spacer = 116
    outstr = &#39;=&#39; * spacer + &#39;\n&#39;

    outstr += (&#39;Number of observations = %d&#39; % out[&#39;nobs&#39;]) + &#39;\n&#39;
    outstr += (&#39;Number of observations used = %d&#39; % out[&#39;ngood&#39;]) + &#39;\n&#39;
    outstr += (&#39;Record length (days) = %.2f&#39; % (out[&#39;nobs&#39;] * out[&#39;dt&#39;] / 24.0)) + &#39;\n&#39;

    if (&#39;stime&#39; in out):
        outstr += (&#39;Start time: %s\n&#39; %
                   time.num2date(out[&#39;stime&#39;]).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)) + &#39;\n&#39;
    outstr += (&#39;%s\n&#39; % out[&#39;nodcor&#39;]) + &#39;\n&#39;
    outstr += variance_str(out)

    names = np.array([name.decode(enc) for name in out[&#39;nameu&#39;]])
    fmt = {&#39;Freq&#39;: &#39;{:,.6f}&#39;.format, &#39;Major&#39;: &#39;{:,.2f}&#39;.format,
           &#39;Major Err&#39;: &#39;{:,.2f}&#39;.format, &#39;Minor&#39;: &#39;{:,.2f}&#39;.format,
           &#39;Minor Err&#39;: &#39;{:,.2f}&#39;.format, &#39;Inc&#39;: &#39;{:,.1f}&#39;.format,
           &#39;Inc Err&#39;: &#39;{:,.1f}&#39;.format, &#39;Phase&#39;: &#39;{:,.1f}&#39;.format,
           &#39;Phase Err&#39;: &#39;{:,.1f}&#39;.format, &#39;SNR&#39;: &#39;{:,.1g}&#39;.format,
           &#39;Amp&#39;: &#39;{:,.2f}&#39;.format, &#39;Amp Err&#39;: &#39;{:,.2f}&#39;.format}

    if out[&#39;isComplex&#39;]:
        colnames = [&#39;Freq&#39;, &#39;Major&#39;, &#39;Major Err&#39;, &#39;Minor&#39;, &#39;Minor Err&#39;,
                    &#39;Inc&#39;, &#39;Inc Err&#39;, &#39;Phase&#39;, &#39;Phase Err&#39;, &#39;SNR&#39;]
        outstr += (&#39; &#39; * 35 + &#39;Ellipse parameters with 95 % CI estimates&#39;) + &#39;\n&#39;
    else:
        colnames = [&#39;Freq&#39;, &#39;Amp&#39;, &#39;Amp Err&#39;, &#39;Phase&#39;, &#39;Phase Err&#39;, &#39;SNR&#39;]
        outstr += (&#39; &#39; * 12 + &#39;Tidal amplitude and phase with 95 % CI estimates&#39;) + &#39;\n&#39;

    dfdata = np.vstack([out[&#39;fu&#39;], out[&#39;tidecon&#39;].T, out[&#39;snr&#39;]]).T
    df = pd.DataFrame(dfdata, names, colnames)
    df.index.name = &#39;Tide&#39;
    outstr += (df.to_string(col_space=10, formatters=fmt)) + &#39;\n&#39;

    outstr += (&#39;=&#39; * spacer) + &#39;\n&#39;
    if dfTF:
        return outstr, df
    else:
        return outstr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.ttide.t_utils.classic_style"><code class="name flex">
<span>def <span class="ident">classic_style</span></span>(<span>out)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classic_style(out):
    outstr = &#39;-&#39; * 35 + &#39;\n&#39;
    outstr += (&#39;nobs = %d \nngood = %d \nrecord length (days) = %.2f&#39; %
               (out[&#39;nobs&#39;], out[&#39;ngood&#39;],
                np.dot(max(out[&#39;xin&#39;].shape), out[&#39;dt&#39;]) / 24)) + &#39;\n&#39;
    if (&#39;stime&#39; in out):
        outstr += &#39;start time: {}\n&#39;.format(
            time.num2date(out[&#39;stime&#39;]).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))
    outstr += (&#39;rayleigh criterion = %.1f\n\n&#39; % out[&#39;ray&#39;])
    outstr += (&#39;%s\n&#39; % out[&#39;nodcor&#39;])
    outstr += variance_str(out)

    if out[&#39;isComplex&#39;]:
        outstr += (&#39; &#39; * 32 + &#39;ellipse parameters with 95 % CI estimates\n&#39;)
        outstr += (&#39; tide     freq        major      emaj&#39; +
                   &#39;      minor      emin     inc      einc&#39; +
                   &#39;      pha       epha      snr\n&#39;)
        fmt = (&#39;{star} {name}  {fuk:9.7f}  &#39;
               &#39;{c[0]:9.4f}  {c[1]:8.3f} {c[2]:9.4f}  {c[3]:8.3f} &#39;
               &#39;{c[4]:8.2f}  {c[5]:8.2f}  {c[6]:8.2f}  {c[7]:8.2f} &#39;
               &#39;{snr:8.2g}\n&#39;)
        for k, fuk in enumerate(out[&#39;fu&#39;]):
            if out[&#39;snr&#39;][k] &gt; out[&#39;synth&#39;]:
                star = &#39;*&#39;
            else:
                star = &#39; &#39;
            outstr += fmt.format(star=star,
                                 name=out[&#39;nameu&#39;][k].decode(enc),
                                 fuk=fuk,
                                 c=out[&#39;tidecon&#39;][k],
                                 snr=out[&#39;snr&#39;][k])
    else:
        outstr += &#39;        tidal amplitude and phase with 95 % CI estimates\n&#39;
        outstr += (&#39; tide      freq        amp      amp_err&#39; +
                   &#39;   pha      pha_err    snr\n&#39;)
        fmt = (&#39;{star} {name}  {fuk:9.7f}  &#39;+
               &#39;{c[0]:9.4f}  {c[1]:8.3f}  {c[2]:8.2f}  {c[3]:8.2f}  &#39;+ #EDIT: replaced comma by +
               &#39;{snr:8.2g}\n&#39;)                                         #EDIT: replaced comma by +
        for k, fuk in enumerate(out[&#39;fu&#39;]):
            if out[&#39;snr&#39;][k] &gt; out[&#39;synth&#39;]:
                star = &#39;*&#39;
            else:
                star = &#39; &#39;
            outstr += fmt.format(star=star,
                                 name=out[&#39;nameu&#39;][k].decode(enc),  
                                 fuk=fuk,                           
                                 c=out[&#39;tidecon&#39;][k],    
                                 snr=out[&#39;snr&#39;][k])
    return outstr</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.cluster"><code class="name flex">
<span>def <span class="ident">cluster</span></span>(<span>ain, clusang)</span>
</code></dt>
<dd>
<div class="desc"><p>CLUSTER: Clusters angles in rows around the angles in the first
column. CLUSANG is the allowable ambiguity (usually 360 degrees but
sometimes 180).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster(ain, clusang):
    &#34;&#34;&#34;CLUSTER: Clusters angles in rows around the angles in the first
     column. CLUSANG is the allowable ambiguity (usually 360 degrees but
     sometimes 180).
    &#34;&#34;&#34;

    makearray = (ain - np.repeat(ain[:, 0],
                                 ain.shape[1]).reshape(ain.shape[0], ain.shape[1]))
    ii = makearray &gt; clusang / 2
    ain[(ii)] = ain[(ii)] - clusang
    ii = (ain - np.repeat(ain[:, 0],
                          ain.shape[1]).reshape(ain.shape[0], ain.shape[1])) &lt; - clusang / 2
    ain[(ii)] = ain[(ii)] + clusang
    return ain</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.constituents"><code class="name flex">
<span>def <span class="ident">constituents</span></span>(<span>minres, constit, shallow, infname, infref, centraltime)</span>
</code></dt>
<dd>
<div class="desc"><p>[name,freq,kmpr]=constituents(minres,infname) loads tidal constituent
table (containing 146 constituents), then picks out only the '
resolvable' frequencies (i.e. those that are MINRES apart), base on
the comparisons in the third column of constituents.dat. Only
frequencies in the 'standard' set of 69 frequencies are actually used.
Also return the indices of constituents to be inferred.
If we have the mat-file, read it in, otherwise create it and read
it in!
R Pawlowicz 9/1/01
Version 1.0</p>
<p>19/1/02 - typo fixed (thanks to
Zhigang Xu)
Compute frequencies from astronomical considerations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constituents(minres, constit, shallow, infname, infref, centraltime):
    &#34;&#34;&#34;[name,freq,kmpr]=constituents(minres,infname) loads tidal constituent
     table (containing 146 constituents), then picks out only the &#39;
     resolvable&#39; frequencies (i.e. those that are MINRES apart), base on
     the comparisons in the third column of constituents.dat. Only
     frequencies in the &#39;standard&#39; set of 69 frequencies are actually used.
     Also return the indices of constituents to be inferred.
     If we have the mat-file, read it in, otherwise create it and read
     it in!
     R Pawlowicz 9/1/01
     Version 1.0

        19/1/02 - typo fixed (thanks to  Zhigang Xu)
     Compute frequencies from astronomical considerations.
    &#34;&#34;&#34;
    if 1:#minres &gt; 1 / (18.6 * 365.25 * 24): #changed to 1 since second loop is not in matlab anymore
        # Choose only resolveable pairs for short
        const, sat, cshallow = t_getconsts(centraltime)
        # Time series
        ju = np.flatnonzero(const[&#39;df&#39;] &gt;= minres)
    else:
        # Choose them all if &gt; 18.6 years.
        const, sat, cshallow = t_get18consts(centraltime)
        
        ju = np.array([range(2,
                             (max(const[&#39;freq&#39;].shape)+1))]).reshape(1, -1).T
        # Skip Z0
        for ff in range(1, 3):
            # loop twice to make sure of neightbouring pairs
            jck = np.flatnonzero(np.diff(const[&#39;freq&#39;][ju]) &lt; minres)
            if (max(jck.shape) &gt; 0):
                jrm = jck
                jrm = jrm + (abs(const[&#39;doodsonamp&#39;][ju[(jck + 1 - 1)]]) &lt;
                             abs(const[&#39;doodsonamp&#39;][ju[(jck - 1)]]))
# disp(&#39;  Warning! Following constituent pairs violate Rayleigh criterion&#39;)
#               for ick in range(1, (max(jck.shape) +1)):
#                    disp(&#39;     &#39; + const.name(ju[(jck[(ick -1)] -1)], :)
# + &#39; vs &#39; + const.name(ju[(jck[(ick -1)] + 1 -1)], :) + &#39; - not using &#39; +
# const.name(ju[(jrm[(ick -1)] -1)], :))
                ju[(jrm - 1)] = np.array([])

    if constit.size:
        # Selected if constituents are specified in input.
        ju = np.array([], dtype=int)
        for k in range(0, (constit.shape[0])):
            j1 = np.where(const[&#39;name&#39;] == constit[k])[0]
            if (j1.size == 0):
                print(&#34;Can&#39;t recognize name &#34; +
                      constit[k].decode(enc) +
                      &#39; for forced search&#39;)
            else:
                ju = np.append(ju, j1)

        # sort in ascending order of frequency.
        II = np.argsort(const[&#39;freq&#39;][ju])
        ju = ju[II]

    # cout
    # disp([&#39;   number of standard constituents used: &#39;,int2str(length(ju))])
    if shallow.size != 0:
        # Add explictly selected shallow water constituents.
        for k in range(0, (shallow.shape[0])):
            j1 = np.where(const[&#39;name&#39;] == shallow[k])[0]
            if (j1.size == 0):
                print(&#34;Can&#39;t recognize name &#34; +
                      shallow[k].decode(enc) +
                      &#39; for forced search&#39;)
            else:
                ju = np.append(ju, j1)

    nameu = const[&#39;name&#39;][ju]
    fu = const[&#39;freq&#39;][ju]

    # Check if neighboring chosen constituents violate Rayleigh criteria.
    jck = np.flatnonzero(np.diff(fu) &lt; minres)
    # cout
    # if (length(jck)&gt;0)
    # disp([&#39;  Warning! Following constituent
    # pairs violate Rayleigh criterion&#39;]);
    # for ick=1:length(jck);
    # disp([&#39;     &#39;,nameu(jck(ick),:),&#39;  &#39;,nameu(jck(ick)+1,:)]);
    # end;
    # end
    # For inference, add in list of components to be inferred.
    fi = np.array([])
    namei = np.array([])
    jinf = np.array([])
    jref = np.array([])
    if infname.size != 0:
        fi = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;)
        namei = np.zeros(shape=(infname.shape[0], 4), dtype=&#39;float64&#39;)
        jinf = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;) + np.NaN
        jref = np.zeros(shape=(infname.shape[0], 1), dtype=&#39;float64&#39;) + np.NaN
        for k in range(1, (infname.shape[0] + 1)):
            j1 = strmatch(infname[(k - 1), :], const.name)
            if (0 in j1.shape):
                print(&#34;Can&#39;t recognize name&#34; +
                      infname[(k - 1), :] + &#39; for inference&#39;)
            else:
                jinf[(k - 1)] = j1
                fi[(k - 1)] = const[&#39;freq&#39;][j1]
                namei[(k - 1), :] = const[&#39;name&#39;][j1, :]
                j1 = strmatch(infref[(k - 1), :], nameu)
                if (0 in j1.shape):
                    print(&#34;Can&#39;t recognize name &#34; + infref[(k - 1), :] +
                          &#39; for as a reference for inference&#39;)
                else:
                    jref[(k - 1)] = j1
                    print(&#39;   Inference of &#39; + namei[(k - 1), :] +
                          &#39; using &#39; + nameu[(j1 - 1), :] + &#39;\\n&#39;)
        jinf[(np.isnan(jref) - 1)] = np.NaN
    return nameu, fu, ju, namei, fi, jinf, jref</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.errell"><code class="name flex">
<span>def <span class="ident">errell</span></span>(<span>cxi, sxi, ercx, ersx, ercy, ersy)</span>
</code></dt>
<dd>
<div class="desc"><p>[emaj,emin,einc,epha]=errell(cx,sx,cy,sy,ercx,ersx,ercy,ersy) computes
the uncertainities in the ellipse parameters based on the
uncertainities in the least square fit cos,sin coefficients.</p>
<p>INPUT:
cx,sx=cos,sin coefficients for x
cy,sy=cos,sin coefficients for y
ercx,ersx=errors in x cos,sin coefficients
ercy,ersy=errors in y cos,sin coefficients</p>
<p>OUTPUT: emaj=major axis error
emin=minor axis error
einc=inclination error (deg)
epha=pha error (deg)
based on linear error propagation, with errors in the coefficients
cx,sx,cy,sy uncorrelated.
B. Beardsley
1/15/99; 1/20/99
Version 1.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errell(cxi, sxi, ercx, ersx, ercy, ersy):
    &#34;&#34;&#34;[emaj,emin,einc,epha]=errell(cx,sx,cy,sy,ercx,ersx,ercy,ersy) computes
     the uncertainities in the ellipse parameters based on the
     uncertainities in the least square fit cos,sin coefficients.

      INPUT:  cx,sx=cos,sin coefficients for x
              cy,sy=cos,sin coefficients for y
              ercx,ersx=errors in x cos,sin coefficients
              ercy,ersy=errors in y cos,sin coefficients

      OUTPUT: emaj=major axis error
              emin=minor axis error
              einc=inclination error (deg)
              epha=pha error (deg)
     based on linear error propagation, with errors in the coefficients
     cx,sx,cy,sy uncorrelated.
     B. Beardsley  1/15/99; 1/20/99
     Version 1.0
    &#34;&#34;&#34;
    r2d = 180.0 / np.pi
    cx = np.real(cxi[:])
    sx = np.real(sxi[:])
    cy = np.imag(cxi[:])
    sy = np.imag(sxi[:])
    ercx = ercx[:]
    ersx = ersx[:]
    ercy = ercy[:]
    ersy = ersy[:]
    rp = 0.5 * np.sqrt((cx + sy) ** 2 + (cy - sx) ** 2)
    rm = 0.5 * np.sqrt((cx - sy) ** 2 + (cy + sx) ** 2)
    ercx2 = ercx ** 2
    ersx2 = ersx ** 2
    ercy2 = ercy ** 2
    ersy2 = ersy ** 2
    # major axis error
    ex = (cx + sy) / rp
    fx = (cx - sy) / rm
    gx = (sx - cy) / rp
    hx = (sx + cy) / rm
    dcx2 = (0.25 * (ex + fx)) ** 2
    dsx2 = (0.25 * (gx + hx)) ** 2
    dcy2 = (0.25 * (hx - gx)) ** 2
    dsy2 = (0.25 * (ex - fx)) ** 2
    emaj = np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                   dcy2 * ercy2 + dsy2 * ersy2)
    # minor axis error
    dcx2 = (0.25 * (ex - fx)) ** 2
    dsx2 = (0.25 * (gx - hx)) ** 2
    dcy2 = (0.25 * (hx + gx)) ** 2
    dsy2 = (0.25 * (ex + fx)) ** 2
    emin = np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                   dcy2 * ercy2 + dsy2 * ersy2)
    # inclination error
    rn = 2.0 * (cx * cy + sx * sy)
    rd = cx ** 2 + sx ** 2 - (cy ** 2 + sy ** 2)
    den = rn ** 2 + rd ** 2
    dcx2 = ((rd * cy - rn * cx) / den) ** 2
    dsx2 = ((rd * sy - rn * sx) / den) ** 2
    dcy2 = ((rd * cx + rn * cy) / den) ** 2
    dsy2 = ((rd * sx + rn * sy) / den) ** 2
    einc = r2d * np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                         dcy2 * ercy2 + dsy2 * ersy2)
    # phase error
    rn = 2.0 * (cx * sx + cy * sy)
    rd = cx ** 2 - sx ** 2 + cy ** 2 - sy ** 2
    den = rn ** 2 + rd ** 2
    dcx2 = ((rd * sx - rn * cx) / den) ** 2
    dsx2 = ((rd * cx + rn * sx) / den) ** 2
    dcy2 = ((rd * sy - rn * cy) / den) ** 2
    dsy2 = ((rd * cy + rn * sy) / den) ** 2
    epha = r2d * np.sqrt(dcx2 * ercx2 + dsx2 * ersx2 +
                         dcy2 * ercy2 + dsy2 * ersy2)

    return emaj, emin, einc, epha</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.fixgaps"><code class="name flex">
<span>def <span class="ident">fixgaps</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>FIXGAPS: Linearly interpolates gaps in a time series
YOUT=FIXGAPS(YIN) linearly interpolates over NaN in the input time
series (may be complex), but ignores trailing and leading NaNs.
R. Pawlowicz 11/6/99
Version 1.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixgaps(x):
    &#34;&#34;&#34;FIXGAPS: Linearly interpolates gaps in a time series
     YOUT=FIXGAPS(YIN) linearly interpolates over NaN in the input time
     series (may be complex), but ignores trailing and leading NaNs.
     R. Pawlowicz 11/6/99
     Version 1.0
    &#34;&#34;&#34;
    

    #find nans
    bd = np.isnan(x)

    #early exit if there are no nans  
    if not bd.any():
        return x
    
    #find nonnans index numbers
    gd = np.flatnonzero(~bd)
    
    if len(gd) == 0:
        raise Exception(&#39;ERROR: array with only nans provided, cannot continue&#39;)
    #ignore leading and trailing nans
    bd[:gd.min()]=False
    bd[(gd.max()+1):]=False
    
    #interpolate nans
    x[bd] = np.interp(np.flatnonzero(bd),gd,x[gd])

    return x</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.fourpad"><code class="name flex">
<span>def <span class="ident">fourpad</span></span>(<span>conin)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourpad(conin):
    conin = np.array(conin, dtype=&#39;|S4&#39;)
    for i, con in enumerate(conin):
        conin[i] = con.ljust(4)

    return conin</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.noise_realizations"><code class="name flex">
<span>def <span class="ident">noise_realizations</span></span>(<span>xres, fu, dt, nreal, errcalc)</span>
</code></dt>
<dd>
<div class="desc"><p>NOISE_REALIZATIONS: Generates matrices of noise (with correct
cross-correlation structure) for bootstrap analysis.</p>
<p>R. Pawlowicz 11/10/00
Version 1.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noise_realizations(xres, fu, dt, nreal, errcalc):
    &#34;&#34;&#34;NOISE_REALIZATIONS: Generates matrices of noise (with correct
     cross-correlation structure) for bootstrap analysis.

     R. Pawlowicz 11/10/00
     Version 1.0
    &#34;&#34;&#34;
    if errcalc == &#39;cboot&#39;:
        fband, Pxrave, Pxiave, Pxcave = residual_spectrum(xres, fu, dt)
        aaa, bbb = Pxcave.shape
        Pxcave = np.zeros((aaa, bbb), dtype=&#39;float64&#39;)
        # For comparison with other technique!
        # print(&#39;**** Assuming no covariance between u and v errors!******\n&#39;);
    else:
        if errcalc == &#39;wboot&#39;:
            fband = np.array([0, 0.5]).reshape(1, -1)
            nx = max(xres.shape)
            A = np.cov(np.real(xres), np.imag(xres)) / nx
            Pxrave = np.array([A[0, 0]])
            Pxiave = np.array([A[1, 1]])
            Pxcave = np.array([A[0, 1]])
        else:
            sys.exit(&#34;Unrecognized type of bootstap analysis specified: &#39;&#34; +
                     errcalc + &#34;&#39;&#34;)

    nfband = fband.shape[0]
    Mat = np.zeros(shape=(4, 4, nfband), dtype=&#39;float64&#39;)
    for k in range(1, (nfband + 1)):
        # The B matrix represents the covariance matrix for the vector
        # [Re{ap} Im{ap} Re{am} Im{am}]&#39; where Re{} and Im{} are real and
        # imaginary parts, and ap/m represent the complex constituent
        # amplitudes for positive and negative frequencies when the input
        # is bivariate white noise. For a flat residual spectrum this works
        # fine.
        # This is adapted here for &#34;locally white&#34; conditions, but I&#39;m still
        # not sure how to handle a complex sxy, so this is set to zero
        # right now.
        p = (Pxrave[(k - 1)] + Pxiave[(k - 1)]) / 2
        d = (Pxrave[(k - 1)] - Pxiave[(k - 1)]) / 2
        sxy = Pxcave[(k - 1)]
        B = np.hstack([p, 0, d, sxy,
                       0, p, sxy, -d,
                       d, sxy, p, 0,
                       sxy, -d, 0, p]).reshape(4, 4)
        # Compute the transformation matrix that takes uncorrelated white
        # noise and makes noise with the same statistical structure as the
        # Fourier transformed noise.

        D, V = np.linalg.eigh(B)

        # next five lines are horrible coding/math someone should check it over
        # swap so the vectors match matlab, should check if this always holds
        V[[1, 0], [1, 3]] = V[[0, 1], [3, 1]]
        V[[3, 2], [1, 3]] = V[[2, 3], [3, 1]]
        # total cludge to deal with bad zeroing in eigh
        D[((D &lt; 0) &amp; (D &gt; -0.00000000001))] = 0

        Mat[:, :, (k - 1)] = np.dot(V, np.diag(np.sqrt(D)))
        # print Mat
    # Generate realizations for the different analyzed constituents.
    N = np.zeros(shape=(4, nreal), dtype=&#39;float64&#39;)
    NM = np.zeros(shape=(max(fu.shape), nreal), dtype=&#39;complex128&#39;)
    NP = np.zeros(shape=(max(fu.shape), nreal), dtype=&#39;complex128&#39;)

    for k in range(0, fu.shape[0]):
        l = np.squeeze(np.flatnonzero(np.all([fu[k] &gt; fband[:, 0],
                                              fu[k] &lt; fband[:, 1]], axis=0)))
        N = np.hstack([np.zeros(4,).reshape(-1, 1),
                       np.dot(np.squeeze(Mat[:, :, l]),
                              np.random.randn(4, nreal - 1))])
        NP[(k), :] = (N[0, :] + 1j * N[1, :])
        NM[(k), :] = (N[2, :] + 1j * N[3, :])

    return NP, NM</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.noise_stats"><code class="name flex">
<span>def <span class="ident">noise_stats</span></span>(<span>xres, fu, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>NOISE_STATS: Computes statistics of residual energy for all
constituents (ignoring any cross-correlations between real and
imaginary parts).
S. Lentz
10/28/99
R. Pawlowicz 11/1/00
Version 1.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noise_stats(xres, fu, dt):
    &#34;&#34;&#34;NOISE_STATS: Computes statistics of residual energy for all
     constituents (ignoring any cross-correlations between real and
     imaginary parts).
     S. Lentz  10/28/99
     R. Pawlowicz 11/1/00
     Version 1.0
    &#34;&#34;&#34;
    fband, Pxrave, Pxiave, Pxcave = residual_spectrum(xres, fu, dt)
    nfband = fband.shape[0]
    mu = max(fu.shape)
    # Get the statistics for each component.
    ercx = np.zeros(shape=(mu, 1), dtype=&#39;float64&#39;)
    eicx = np.zeros(shape=(mu, 1), dtype=&#39;float64&#39;)
    for k1 in range(0, nfband):
        k = np.flatnonzero(np.all([fu &gt;= fband[k1, 0],
                                   fu &lt;= fband[k1, 1]], axis=0))
        ercx[(k)] = np.sqrt(Pxrave[(k1)])
        eicx[(k)] = np.sqrt(Pxiave[(k1)])
    return ercx, eicx</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.pandas_style"><code class="name flex">
<span>def <span class="ident">pandas_style</span></span>(<span>out, dfTF=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pandas_style(out, dfTF=False):
    if pd is None:
        # Unable to import pandas.
        print(&#34;pandas is not available, falling back to out_style=&#39;classic&#39;.&#34;)
        return classic_style(out)
    spacer = 70
    if out[&#39;isComplex&#39;]:
        spacer = 116
    outstr = &#39;=&#39; * spacer + &#39;\n&#39;

    outstr += (&#39;Number of observations = %d&#39; % out[&#39;nobs&#39;]) + &#39;\n&#39;
    outstr += (&#39;Number of observations used = %d&#39; % out[&#39;ngood&#39;]) + &#39;\n&#39;
    outstr += (&#39;Record length (days) = %.2f&#39; % (out[&#39;nobs&#39;] * out[&#39;dt&#39;] / 24.0)) + &#39;\n&#39;

    if (&#39;stime&#39; in out):
        outstr += (&#39;Start time: %s\n&#39; %
                   time.num2date(out[&#39;stime&#39;]).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)) + &#39;\n&#39;
    outstr += (&#39;%s\n&#39; % out[&#39;nodcor&#39;]) + &#39;\n&#39;
    outstr += variance_str(out)

    names = np.array([name.decode(enc) for name in out[&#39;nameu&#39;]])
    fmt = {&#39;Freq&#39;: &#39;{:,.6f}&#39;.format, &#39;Major&#39;: &#39;{:,.2f}&#39;.format,
           &#39;Major Err&#39;: &#39;{:,.2f}&#39;.format, &#39;Minor&#39;: &#39;{:,.2f}&#39;.format,
           &#39;Minor Err&#39;: &#39;{:,.2f}&#39;.format, &#39;Inc&#39;: &#39;{:,.1f}&#39;.format,
           &#39;Inc Err&#39;: &#39;{:,.1f}&#39;.format, &#39;Phase&#39;: &#39;{:,.1f}&#39;.format,
           &#39;Phase Err&#39;: &#39;{:,.1f}&#39;.format, &#39;SNR&#39;: &#39;{:,.1g}&#39;.format,
           &#39;Amp&#39;: &#39;{:,.2f}&#39;.format, &#39;Amp Err&#39;: &#39;{:,.2f}&#39;.format}

    if out[&#39;isComplex&#39;]:
        colnames = [&#39;Freq&#39;, &#39;Major&#39;, &#39;Major Err&#39;, &#39;Minor&#39;, &#39;Minor Err&#39;,
                    &#39;Inc&#39;, &#39;Inc Err&#39;, &#39;Phase&#39;, &#39;Phase Err&#39;, &#39;SNR&#39;]
        outstr += (&#39; &#39; * 35 + &#39;Ellipse parameters with 95 % CI estimates&#39;) + &#39;\n&#39;
    else:
        colnames = [&#39;Freq&#39;, &#39;Amp&#39;, &#39;Amp Err&#39;, &#39;Phase&#39;, &#39;Phase Err&#39;, &#39;SNR&#39;]
        outstr += (&#39; &#39; * 12 + &#39;Tidal amplitude and phase with 95 % CI estimates&#39;) + &#39;\n&#39;

    dfdata = np.vstack([out[&#39;fu&#39;], out[&#39;tidecon&#39;].T, out[&#39;snr&#39;]]).T
    df = pd.DataFrame(dfdata, names, colnames)
    df.index.name = &#39;Tide&#39;
    outstr += (df.to_string(col_space=10, formatters=fmt)) + &#39;\n&#39;

    outstr += (&#39;=&#39; * spacer) + &#39;\n&#39;
    if dfTF:
        return outstr, df
    else:
        return outstr</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.residual_spectrum"><code class="name flex">
<span>def <span class="ident">residual_spectrum</span></span>(<span>xres, fu, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>RESIDUAL_SPECTRUM: Computes statistics from an input spectrum over
a number of bands, returning the band limits and the estimates for
power spectra for real and imaginary parts and the cross-spectrum.</p>
<p>Mean values of the noise spectrum are computed for the following
8 frequency bands defined by their center frequency and band width:
M0 +.1 cpd; M1 +-.2 cpd; M2 +-.2 cpd; M3 +-.2 cpd; M4 +-.2 cpd;
M5 +-.2 cpd; M6 +-.21 cpd; M7 (.26-.29 cpd); and M8 (.30-.50 cpd).
S. Lentz
10/28/99
R. Pawlowicz 11/1/00
Version 1.0
Define frequency bands for spectral averaging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residual_spectrum(xres, fu, dt):
    &#34;&#34;&#34;RESIDUAL_SPECTRUM: Computes statistics from an input spectrum over
     a number of bands, returning the band limits and the estimates for
     power spectra for real and imaginary parts and the cross-spectrum.

     Mean values of the noise spectrum are computed for the following
     8 frequency bands defined by their center frequency and band width:
     M0 +.1 cpd; M1 +-.2 cpd; M2 +-.2 cpd; M3 +-.2 cpd; M4 +-.2 cpd;
     M5 +-.2 cpd; M6 +-.21 cpd; M7 (.26-.29 cpd); and M8 (.30-.50 cpd).
     S. Lentz  10/28/99
     R. Pawlowicz 11/1/00
     Version 1.0
     Define frequency bands for spectral averaging.
    &#34;&#34;&#34;
    fband = np.array([[0.0001, 0.00417],
                      [0.03192, 0.04859],
                      [0.07218, 0.08884],
                      [0.11243, 0.1291],
                      [0.15269, 0.16936],
                      [0.19295, 0.20961],
                      [0.2332, 0.251],
                      [0.26, 0.29],
                      [0.3, 0.5]])

    # If we have a sampling interval&gt; 1 hour, we might have to get
    # rid of some bins.
    # fband(fband(:,1)&gt;1/(2*dt),:)=[];
    nfband = fband.shape[0]
    nx = max(xres.shape)

    # Spectral estimate (takes real time series only).
    fx, Pxr = sps.welch(np.real(xres), window=np.hanning(nx),
                        noverlap=np.ceil(nx / 2), nfft=nx, fs=1 / dt, nperseg=nx)
    Pxr = Pxr / 2 / dt
    fx, Pxi = sps.welch(np.imag(xres), window=np.hanning(nx),
                        noverlap=np.ceil(nx / 2), nfft=nx, fs=1 / dt, nperseg=nx)
    Pxi = Pxi / 2 / dt
    #Pxc, fx = mplm.csd(np.real(xres), np.imag(xres), nx, 1 / dt)
    fx, Pxc = sps.csd(np.real(xres), np.imag(xres), fs=1 / dt, nperseg=nx, nfft=nx, )

    # matlab cpsd returns only reals when given a real xres have to
    # test for complex and maybe change to ifstatement
    Pxc = np.real(Pxc)
    Pxc = Pxc / 2 / dt
    df = fx[2] - fx[1]

    # Sets Px=NaN in bins close to analyzed frequencies
    # to prevent leakage problems?).
    Pxr[np.around(fu / df).astype(int)] = np.nan
    Pxi[np.around(fu / df).astype(int)] = np.nan
    Pxc[np.around(fu / df).astype(int)] = np.nan

    Pxrave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)
    Pxiave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)
    Pxcave = np.zeros(shape=(nfband, 1), dtype=&#39;float64&#39;)

    # Loop downwards in frequency through bands (cures short time series
    # problem with no data in lowest band).
    # Divide by nx to get power per frequency bin, and multiply by 2
    # to account for positive and negative frequencies.
    for k in range(nfband - 1, -1, - 1):
        jband = np.flatnonzero(np.all(np.vstack([fx &gt;= fband[(k), 0],
                                                 fx &lt;= fband[(k), 1],
                                                 np.isfinite(Pxr)]).T, axis=1))
        if any(jband):
            Pxrave[k] = 2 * np.mean(Pxr[(jband)]) / nx
            Pxiave[k] = 2 * np.mean(Pxi[(jband)]) / nx
            Pxcave[k] = 2 * np.mean(Pxc[(jband)]) / nx
        else:
            if k &lt; nfband:
                Pxrave[k] = Pxrave[(k + 1)]
                # Low frequency bin might not have any points...
                Pxiave[k] = Pxiave[(k + 1)]
                Pxcave[k] = Pxcave[(k + 1)]

    return fband, Pxrave, Pxiave, Pxcave</code></pre>
</details>
</dd>
<dt id="dfm_tools.ttide.t_utils.variance_str"><code class="name flex">
<span>def <span class="ident">variance_str</span></span>(<span>out)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the out dictionary and prints the variance text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance_str(out):
    &#39;&#39;&#39;Takes the out dictionary and prints the variance text&#39;&#39;&#39;

    x = np.var(out[&#39;xingd&#39;].real, ddof=1)
    xp = np.var(out[&#39;xoutgd&#39;].real, ddof=1)
    xr = np.var(out[&#39;xresgd&#39;].real, ddof=1)
    z0r = out[&#39;z0&#39;].real
    dz0r = out[&#39;dz0&#39;].real

    outstr = &#39;x0= {:.3g}  xtrend= {:.3g}\n&#39;.format(z0r, dz0r)
    outstr += (&#39;var(data)= {:.2f}&#39; + &#39; &#39; * 4 +
               &#39;var(prediction)= {:.2f}&#39; + &#39; &#39; * 4 +
               &#39;var(residual)= {:.2f}\n&#39;).format(x, xp, xr)
    outstr += &#39;var(prediction)/var(data) (%%) = %.1f\n\n&#39; % (100 * xp / x)

    if np.iscomplexobj(out[&#39;xin&#39;]):
        y = np.var(out[&#39;xingd&#39;].imag, ddof=1)
        yp = np.var(out[&#39;xoutgd&#39;].imag, ddof=1)
        yr = np.var(out[&#39;xresgd&#39;].imag, ddof=1)
        z0r = out[&#39;z0&#39;].imag
        dz0r = out[&#39;dz0&#39;].imag

        outstr += &#39;y0= {:.3g}  ytrend= {:.3g}\n&#39;.format(z0r, dz0r)
        outstr += (&#39;var(data)= {:.2f}&#39; + &#39; &#39; * 4 +
                   &#39;var(prediction)= {:.2f}&#39; + &#39; &#39; * 4 +
                   &#39;var(residual)= {:.2f}\n&#39;).format(y, yp, yr)
        outstr += &#39;var(prediction)/var(data) (%) = {:.1f}\n\n&#39;.format(
            100 * yp / y)

        outstr += &#39;total_var= {:f} pred_var=  {:f}\n&#39;.format(
            (x + y), (xp + yp))
        outstr += &#39;total_var/pred_var (%) =  {:.1f}  \n&#39;.format(
            100 * (xp + yp) / (x + y))
    return outstr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools.ttide" href="index.html">dfm_tools.ttide</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dfm_tools.ttide.t_utils.classic_style" href="#dfm_tools.ttide.t_utils.classic_style">classic_style</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.cluster" href="#dfm_tools.ttide.t_utils.cluster">cluster</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.constituents" href="#dfm_tools.ttide.t_utils.constituents">constituents</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.errell" href="#dfm_tools.ttide.t_utils.errell">errell</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.fixgaps" href="#dfm_tools.ttide.t_utils.fixgaps">fixgaps</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.fourpad" href="#dfm_tools.ttide.t_utils.fourpad">fourpad</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.noise_realizations" href="#dfm_tools.ttide.t_utils.noise_realizations">noise_realizations</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.noise_stats" href="#dfm_tools.ttide.t_utils.noise_stats">noise_stats</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.pandas_style" href="#dfm_tools.ttide.t_utils.pandas_style">pandas_style</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.residual_spectrum" href="#dfm_tools.ttide.t_utils.residual_spectrum">residual_spectrum</a></code></li>
<li><code><a title="dfm_tools.ttide.t_utils.variance_str" href="#dfm_tools.ttide.t_utils.variance_str">variance_str</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>