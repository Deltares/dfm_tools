<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dfm_tools.ugrid API documentation</title>
<meta name="description" content="dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.ugrid</code></h1>
</header>
<section id="section-intro">
<p>dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.
if not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<p>All names, logos, and references to "Deltares" are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.</p>
<p>INFORMATION
This script is part of dfm_tools: <a href="https://github.com/openearth/dfm_tools">https://github.com/openearth/dfm_tools</a>
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools</p>
<p>Created on Fri Feb 14 11:23:12 2020</p>
<p>@author: veenstra</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  if not, see &lt;http://www.gnu.org/licenses/&gt;.

All names, logos, and references to &#34;Deltares&#34; are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.


INFORMATION
This script is part of dfm_tools: https://github.com/openearth/dfm_tools
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools

Created on Fri Feb 14 11:23:12 2020

@author: veenstra
&#34;&#34;&#34;

class UGrid:
    &#34;&#34;&#34;Unstructured grid&#34;&#34;&#34;
    def __init__(self, mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=None, edge_verts=None):
        self.mesh2d_node_x = mesh2d_node_x
        self.mesh2d_node_y = mesh2d_node_y
        self.mesh2d_face_nodes = mesh2d_face_nodes
        self.verts = verts
        self.mesh2d_node_z = mesh2d_node_z
        #if mesh2d_node_z is not None:
        #    self.mesh2d_node_z = mesh2d_node_z
        #else:
        #    self.mesh2d_node_z = np.zeros(self.mesh2d_node_x.shape)
        self.edge_verts=edge_verts #can be none?
    @staticmethod
    def fromfile(file_nc):
        import numpy as np
        from netCDF4 import Dataset
        from dfm_tools.get_nc_helpers import get_varname_fromnc, ghostcell_filter
        
        def nodexyfaces2verts(node_x,node_y, faces):
            quatrangles = faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            quatrangles_filled = quatrangles.filled(int(-999)) #necessary since fill value was changed from -999 to -2147483647 and this cannot be handled for some reason
            #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
            #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
            yz = np.c_[node_x,node_y]
            verts= yz[quatrangles_filled]
            verts[quatrangles.mask==True,:] = np.nan #remove all masked values by making them nan
            return verts
        
        def nodexyfaces2edgeverts(node_x,node_y,edge_nodes, face_x,face_y,edge_faces):
            quatranglese = edge_nodes-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            quatranglesf = edge_faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
            #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
            yze = np.c_[node_x,node_y]
            yzf = np.c_[face_x,face_y]
            yzf = np.concatenate([yzf,[[np.nan,np.nan]]]) #add dummy row to index -1, since edge_faces has one 0-value when it is a model border edge. This gets turned into -1 towards quatranglesf (last index), which must be nan eventually
            vertse= yze[quatranglese]
            vertsf= yzf[quatranglesf]
            vertse[quatranglese.mask==True,:] = np.nan #remove all masked values by making them nan
            vertsf[quatranglesf.mask==True,:] = np.nan #remove all masked values by making them nan
            verts_raw = np.concatenate([vertse,vertsf],axis=1)
            edge_verts = verts_raw[:,[0,2,1,3],:] #set ordering in (counter)clockwise direction instead of updown-leftright. second column will sometimes contain nans, then the face is not plotted.
            return edge_verts
        
        data_nc = Dataset(file_nc)
        
        varn_mesh2d_node_x = get_varname_fromnc(data_nc,&#39;mesh2d_node_x&#39;,vardim=&#39;var&#39;)
        varn_mesh2d_node_y = get_varname_fromnc(data_nc,&#39;mesh2d_node_y&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_node_x is None or varn_mesh2d_node_y is None:
            raise Exception(&#39;file does not contain variables &#34;mesh2d_node_x&#34; and &#34;mesh2d_node_y&#34; or similar, are you sure this is an unstructured grid?&#39;)
        mesh2d_node_x = data_nc.variables[varn_mesh2d_node_x][:]
        mesh2d_node_y = data_nc.variables[varn_mesh2d_node_y][:]
        
        varn_mesh2d_node_z = get_varname_fromnc(data_nc,&#39;mesh2d_node_z&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_node_z is not None: # node_z variable is present
            mesh2d_node_z = data_nc.variables[varn_mesh2d_node_z][:]
        else:
            mesh2d_node_z = None

        varn_mesh2d_face_nodes = get_varname_fromnc(data_nc,&#39;mesh2d_face_nodes&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_face_nodes is not None: # node_z variable is present
            mesh2d_face_nodes = data_nc.variables[varn_mesh2d_face_nodes][:, :]
        else:
            raise Exception(&#39;ERROR: provided file does not contain a variable mesh2d_face_nodes or similar:\n%s\nPlease do one of the following:\n- plot grid from *_map.nc file\n- import and export the grid with RGFGRID\n- import and save the gridd &#34;with cellfinfo&#34; from interacter&#39;%(file_nc))
        verts = nodexyfaces2verts(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes) #xy coordinates of face nodes
        
        #varn_mesh2d_edge_x = get_varname_fromnc(data_nc,&#39;mesh2d_edge_x&#39;,vardim=&#39;var&#39;)
        varn_mesh2d_edge_faces = get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_edge_faces is not None: # mesh2d_edge_x (and mesh2d_edge_y) variable is present
            #get coordinates and mapping of edge start/end node
            #mesh2d_edge_x = data_nc.variables[varn_mesh2d_edge_x][:]
            #mesh2d_edge_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_y&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_edge_nodes = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_nodes&#39;,vardim=&#39;var&#39;)][:]
            #get center coordinates and mapping of two bordering faces
            mesh2d_face_x = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_x&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_face_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_y&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_edge_faces = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)][:]
            #combine to edge_verts
            edge_verts = nodexyfaces2edgeverts(mesh2d_node_x, mesh2d_node_y, mesh2d_edge_nodes, mesh2d_face_x, mesh2d_face_y, mesh2d_edge_faces) #xy coordinates of face nodes
            
        else:
            edge_verts = None
            
        #remove ghost cells from faces and verts
        nonghost_bool = ghostcell_filter(file_nc)
        if nonghost_bool is not None:
            mesh2d_face_nodes = mesh2d_face_nodes[nonghost_bool]
            verts = verts[nonghost_bool]
            if 0: # remove edges from partition boundaries if there are partitions
                part_edges_removebool = (mesh2d_edge_faces==0).any(axis=1) # Array is 1 based indexed, 0 means missing # &amp; (np.in1d(mesh2d_edge_faces[:,0],ghost_removeids-1) | np.in1d(mesh2d_edge_faces[:,1],ghost_removeids-1))
                edge_verts = edge_verts[~part_edges_removebool]

        data_nc.close()
        ugrid = UGrid(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=mesh2d_node_z, edge_verts=edge_verts)
        return ugrid


    def polygon_intersect(self, line_array, optimize_dist=False, calcdist_fromlatlon=False):
        import numpy as np
        from matplotlib.path import Path
        
        from dfm_tools.testutils import try_importmodule
        try_importmodule(modulename=&#39;shapely&#39;)
        import shapely
        from shapely.geometry import LineString, Polygon, MultiLineString, Point
        from dfm_tools.get_nc import calc_dist_pythagoras, calc_dist_haversine

        print(&#39;defining celinlinebox&#39;)
        
        line_section = LineString(line_array)
        
        verts_xmax = np.nanmax(self.verts[:,:,0].data,axis=1)
        verts_xmin = np.nanmin(self.verts[:,:,0].data,axis=1)
        verts_ymax = np.nanmax(self.verts[:,:,1].data,axis=1)
        verts_ymin = np.nanmin(self.verts[:,:,1].data,axis=1)
        
        if not optimize_dist:
            cellinlinebox_all_bool = (((np.min(line_array[:,0]) &lt;= verts_xmax) &amp;
                                       (np.max(line_array[:,0]) &gt;= verts_xmin)) &amp;
                                      ((np.min(line_array[:,1]) &lt;= verts_ymax) &amp; 
                                       (np.max(line_array[:,1]) &gt;= verts_ymin))
                                      )
        elif type(optimize_dist) in [int,float]: #not properly tested and documented
            #calculate angles wrt x axis
            angles_wrtx = []
            nlinecoords = line_array.shape[0]
            for iL in range(nlinecoords-1):
                dx = line_array[iL+1,0] - line_array[iL,0]
                dy = line_array[iL+1,1] - line_array[iL,1]
                angles_wrtx.append(np.rad2deg(np.arctan2(dy,dx)))
            angles_toprev = np.concatenate([[90],np.diff(angles_wrtx),[90]])
            angles_wrtx_ext = np.concatenate([[angles_wrtx[0]-90],np.array(angles_wrtx),[angles_wrtx[-1]+90]])
            angtot_wrtx = angles_wrtx_ext[:-1] + 0.5*(180+angles_toprev)
            #distance over xy-axis from original points
            dxynewpoints = optimize_dist * np.array([np.cos(np.deg2rad(angtot_wrtx)),np.sin(np.deg2rad(angtot_wrtx))]).T
            newpoints1 = line_array+dxynewpoints
            newpoints2 = line_array-dxynewpoints
            pol_inpol = np.concatenate([newpoints1, np.flip(newpoints2,axis=0)])
            pol_inpol_path = Path(pol_inpol)
            bool_all = []
            for iC in range(self.verts.shape[1]):
                test = pol_inpol_path.contains_points(self.verts[:,iC,:])
                bool_all.append(test)
            test_all = np.array(bool_all)
            cellinlinebox_all_bool = (test_all==True).any(axis=0)
        else:
            raise Exception(&#39;ERROR: invalid type for optimize_dist argument&#39;)
        
        #intersect_coords = np.empty((0,2,2))
        intersect_coords = np.empty((0,4))
        intersect_gridnos = np.empty((0),dtype=int) #has to be numbers, since a boolean is differently ordered
        verts_inlinebox = self.verts[cellinlinebox_all_bool,:,:]
        verts_inlinebox_nos = np.where(cellinlinebox_all_bool)[0]
        print(&#39;finding crossing flow links (can take a while if linebox over xy covers a lot of cells, %i of %i cells are being processed)&#39;%(cellinlinebox_all_bool.sum(),len(cellinlinebox_all_bool)))
        
        for iP, pol_data in enumerate(verts_inlinebox):
            pol_shp = Polygon(pol_data[~np.isnan(pol_data).all(axis=1)])
            intersect_result = pol_shp.intersection(line_section)
            if isinstance(intersect_result,shapely.geometry.multilinestring.MultiLineString): #in the rare case that a cell (pol_shp) is crossed by multiple parts of the line
                intersect_result_multi = intersect_result
            elif isinstance(intersect_result,shapely.geometry.linestring.LineString): #if one linepart trough cell (ex/including node), make multilinestring anyway
                if intersect_result.coords == []: #when the line does not cross this cell, intersect_results.coords is an empty linestring and this cell can be skipped (continue makes forloop continue with next in line without finishing the rest of the steps for this instance)
                    continue
                elif len(intersect_result.coords.xy[0]) == 0: #for newer cartopy versions, when line does not cross this cell, intersect_result.coords.xy is (array(&#39;d&#39;), array(&#39;d&#39;)), and both arrays in tuple have len 0.
                    continue
                intersect_result_multi = MultiLineString([intersect_result])
                
            for iLL, intesect_result_one in enumerate(intersect_result_multi.geoms): #loop over multilinestrings, will mostly only contain one linestring. Will be two if the line crosses a cell more than once.
                intersection_line = intesect_result_one.coords
                intline_xyshape = np.array(intersection_line.xy).shape
                #print(&#39;len(intersection_line.xy): %s&#39;%([intline_xyshape]))
                for numlinepart_incell in range(1,intline_xyshape[1]): #is mostly 1, but more if there is a linebreakpoint in this cell (then there are two or more lineparts)
                    intersect_gridnos = np.append(intersect_gridnos,verts_inlinebox_nos[iP])
                    #intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy)[np.newaxis,:,numlinepart_incell-1:numlinepart_incell+1]],axis=0)
                    intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy).T[numlinepart_incell-1:numlinepart_incell+1].flatten()[np.newaxis]])
        
        if intersect_coords.shape[0] != len(intersect_gridnos):
            raise Exception(&#39;something went wrong, intersect_coords.shape[0] and len(intersect_gridnos) are not equal&#39;)
        
        import pandas as pd
        intersect_pd = pd.DataFrame(intersect_coords,index=intersect_gridnos,columns=[&#39;x1&#39;,&#39;y1&#39;,&#39;x2&#39;,&#39;y2&#39;])
        intersect_pd.index.name = &#39;gridnumber&#39;
        
        #TODO up to here could come from meshkernelpy
        
        print(&#39;calculating distance for all crossed cells, from first point of line (should not take long, but if it does, optimisation is needed)&#39;)
        nlinecoords = line_array.shape[0]
        nlinedims = len(line_array.shape)
        ncrosscellparts = len(intersect_pd)
        if nlinecoords&lt;2 or nlinedims != 2:
            raise Exception(&#39;ERROR: line_array should at least contain two xy points [[x,y],[x,y]]&#39;)
        
        #calculate distance between celledge-linepart crossing (is zero when line iL crosses cell)
        distperline_tostart = np.zeros((ncrosscellparts,nlinecoords-1))
        distperline_tostop = np.zeros((ncrosscellparts,nlinecoords-1))
        linepart_length = np.zeros((nlinecoords))
        for iL in range(nlinecoords-1):
            #calculate length of lineparts
            line_section_part = LineString(line_array[iL:iL+2,:])
            if calcdist_fromlatlon:
                linepart_length[iL+1] = calc_dist_haversine(line_array[iL,0],line_array[iL+1,0],line_array[iL,1],line_array[iL+1,1])
            else:
                linepart_length[iL+1] = line_section_part.length
        
            #get distance between all lineparts and point (later used to calculate distance from beginpoint of closest linepart)
            for iP in range(ncrosscellparts):
                distperline_tostart[iP,iL] = line_section_part.distance(Point(intersect_coords[:,0][iP],intersect_coords[:,1][iP]))
                distperline_tostop[iP,iL] = line_section_part.distance(Point(intersect_coords[:,2][iP],intersect_coords[:,3][iP]))
        linepart_lengthcum = np.cumsum(linepart_length)
        cross_points_closestlineid = np.argmin(np.maximum(distperline_tostart,distperline_tostop),axis=1)
        intersect_pd[&#39;closestlineid&#39;] = cross_points_closestlineid
        print(&#39;finished calculating distance for all crossed cells, from first point of line&#39;)
        
        if not calcdist_fromlatlon:
            crs_dist_starts = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
            crs_dist_stops = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
        else:
            crs_dist_starts = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
            crs_dist_stops = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
        intersect_pd[&#39;crs_dist_starts&#39;] = crs_dist_starts
        intersect_pd[&#39;crs_dist_stops&#39;] = crs_dist_stops
        intersect_pd[&#39;linepartlen&#39;] = crs_dist_stops-crs_dist_starts
        intersect_pd = intersect_pd.sort_values(&#39;crs_dist_starts&#39;)
        
        #dimensions (gridnos, xy, firstsecond)
        print(&#39;done finding crossing flow links: %i of %i&#39;%(len(intersect_gridnos),len(cellinlinebox_all_bool)))
        return intersect_pd
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dfm_tools.ugrid.UGrid"><code class="flex name class">
<span>class <span class="ident">UGrid</span></span>
<span>(</span><span>mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=None, edge_verts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unstructured grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UGrid:
    &#34;&#34;&#34;Unstructured grid&#34;&#34;&#34;
    def __init__(self, mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=None, edge_verts=None):
        self.mesh2d_node_x = mesh2d_node_x
        self.mesh2d_node_y = mesh2d_node_y
        self.mesh2d_face_nodes = mesh2d_face_nodes
        self.verts = verts
        self.mesh2d_node_z = mesh2d_node_z
        #if mesh2d_node_z is not None:
        #    self.mesh2d_node_z = mesh2d_node_z
        #else:
        #    self.mesh2d_node_z = np.zeros(self.mesh2d_node_x.shape)
        self.edge_verts=edge_verts #can be none?
    @staticmethod
    def fromfile(file_nc):
        import numpy as np
        from netCDF4 import Dataset
        from dfm_tools.get_nc_helpers import get_varname_fromnc, ghostcell_filter
        
        def nodexyfaces2verts(node_x,node_y, faces):
            quatrangles = faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            quatrangles_filled = quatrangles.filled(int(-999)) #necessary since fill value was changed from -999 to -2147483647 and this cannot be handled for some reason
            #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
            #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
            yz = np.c_[node_x,node_y]
            verts= yz[quatrangles_filled]
            verts[quatrangles.mask==True,:] = np.nan #remove all masked values by making them nan
            return verts
        
        def nodexyfaces2edgeverts(node_x,node_y,edge_nodes, face_x,face_y,edge_faces):
            quatranglese = edge_nodes-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            quatranglesf = edge_faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
            #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
            #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
            yze = np.c_[node_x,node_y]
            yzf = np.c_[face_x,face_y]
            yzf = np.concatenate([yzf,[[np.nan,np.nan]]]) #add dummy row to index -1, since edge_faces has one 0-value when it is a model border edge. This gets turned into -1 towards quatranglesf (last index), which must be nan eventually
            vertse= yze[quatranglese]
            vertsf= yzf[quatranglesf]
            vertse[quatranglese.mask==True,:] = np.nan #remove all masked values by making them nan
            vertsf[quatranglesf.mask==True,:] = np.nan #remove all masked values by making them nan
            verts_raw = np.concatenate([vertse,vertsf],axis=1)
            edge_verts = verts_raw[:,[0,2,1,3],:] #set ordering in (counter)clockwise direction instead of updown-leftright. second column will sometimes contain nans, then the face is not plotted.
            return edge_verts
        
        data_nc = Dataset(file_nc)
        
        varn_mesh2d_node_x = get_varname_fromnc(data_nc,&#39;mesh2d_node_x&#39;,vardim=&#39;var&#39;)
        varn_mesh2d_node_y = get_varname_fromnc(data_nc,&#39;mesh2d_node_y&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_node_x is None or varn_mesh2d_node_y is None:
            raise Exception(&#39;file does not contain variables &#34;mesh2d_node_x&#34; and &#34;mesh2d_node_y&#34; or similar, are you sure this is an unstructured grid?&#39;)
        mesh2d_node_x = data_nc.variables[varn_mesh2d_node_x][:]
        mesh2d_node_y = data_nc.variables[varn_mesh2d_node_y][:]
        
        varn_mesh2d_node_z = get_varname_fromnc(data_nc,&#39;mesh2d_node_z&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_node_z is not None: # node_z variable is present
            mesh2d_node_z = data_nc.variables[varn_mesh2d_node_z][:]
        else:
            mesh2d_node_z = None

        varn_mesh2d_face_nodes = get_varname_fromnc(data_nc,&#39;mesh2d_face_nodes&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_face_nodes is not None: # node_z variable is present
            mesh2d_face_nodes = data_nc.variables[varn_mesh2d_face_nodes][:, :]
        else:
            raise Exception(&#39;ERROR: provided file does not contain a variable mesh2d_face_nodes or similar:\n%s\nPlease do one of the following:\n- plot grid from *_map.nc file\n- import and export the grid with RGFGRID\n- import and save the gridd &#34;with cellfinfo&#34; from interacter&#39;%(file_nc))
        verts = nodexyfaces2verts(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes) #xy coordinates of face nodes
        
        #varn_mesh2d_edge_x = get_varname_fromnc(data_nc,&#39;mesh2d_edge_x&#39;,vardim=&#39;var&#39;)
        varn_mesh2d_edge_faces = get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)
        if varn_mesh2d_edge_faces is not None: # mesh2d_edge_x (and mesh2d_edge_y) variable is present
            #get coordinates and mapping of edge start/end node
            #mesh2d_edge_x = data_nc.variables[varn_mesh2d_edge_x][:]
            #mesh2d_edge_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_y&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_edge_nodes = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_nodes&#39;,vardim=&#39;var&#39;)][:]
            #get center coordinates and mapping of two bordering faces
            mesh2d_face_x = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_x&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_face_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_y&#39;,vardim=&#39;var&#39;)][:]
            mesh2d_edge_faces = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)][:]
            #combine to edge_verts
            edge_verts = nodexyfaces2edgeverts(mesh2d_node_x, mesh2d_node_y, mesh2d_edge_nodes, mesh2d_face_x, mesh2d_face_y, mesh2d_edge_faces) #xy coordinates of face nodes
            
        else:
            edge_verts = None
            
        #remove ghost cells from faces and verts
        nonghost_bool = ghostcell_filter(file_nc)
        if nonghost_bool is not None:
            mesh2d_face_nodes = mesh2d_face_nodes[nonghost_bool]
            verts = verts[nonghost_bool]
            if 0: # remove edges from partition boundaries if there are partitions
                part_edges_removebool = (mesh2d_edge_faces==0).any(axis=1) # Array is 1 based indexed, 0 means missing # &amp; (np.in1d(mesh2d_edge_faces[:,0],ghost_removeids-1) | np.in1d(mesh2d_edge_faces[:,1],ghost_removeids-1))
                edge_verts = edge_verts[~part_edges_removebool]

        data_nc.close()
        ugrid = UGrid(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=mesh2d_node_z, edge_verts=edge_verts)
        return ugrid


    def polygon_intersect(self, line_array, optimize_dist=False, calcdist_fromlatlon=False):
        import numpy as np
        from matplotlib.path import Path
        
        from dfm_tools.testutils import try_importmodule
        try_importmodule(modulename=&#39;shapely&#39;)
        import shapely
        from shapely.geometry import LineString, Polygon, MultiLineString, Point
        from dfm_tools.get_nc import calc_dist_pythagoras, calc_dist_haversine

        print(&#39;defining celinlinebox&#39;)
        
        line_section = LineString(line_array)
        
        verts_xmax = np.nanmax(self.verts[:,:,0].data,axis=1)
        verts_xmin = np.nanmin(self.verts[:,:,0].data,axis=1)
        verts_ymax = np.nanmax(self.verts[:,:,1].data,axis=1)
        verts_ymin = np.nanmin(self.verts[:,:,1].data,axis=1)
        
        if not optimize_dist:
            cellinlinebox_all_bool = (((np.min(line_array[:,0]) &lt;= verts_xmax) &amp;
                                       (np.max(line_array[:,0]) &gt;= verts_xmin)) &amp;
                                      ((np.min(line_array[:,1]) &lt;= verts_ymax) &amp; 
                                       (np.max(line_array[:,1]) &gt;= verts_ymin))
                                      )
        elif type(optimize_dist) in [int,float]: #not properly tested and documented
            #calculate angles wrt x axis
            angles_wrtx = []
            nlinecoords = line_array.shape[0]
            for iL in range(nlinecoords-1):
                dx = line_array[iL+1,0] - line_array[iL,0]
                dy = line_array[iL+1,1] - line_array[iL,1]
                angles_wrtx.append(np.rad2deg(np.arctan2(dy,dx)))
            angles_toprev = np.concatenate([[90],np.diff(angles_wrtx),[90]])
            angles_wrtx_ext = np.concatenate([[angles_wrtx[0]-90],np.array(angles_wrtx),[angles_wrtx[-1]+90]])
            angtot_wrtx = angles_wrtx_ext[:-1] + 0.5*(180+angles_toprev)
            #distance over xy-axis from original points
            dxynewpoints = optimize_dist * np.array([np.cos(np.deg2rad(angtot_wrtx)),np.sin(np.deg2rad(angtot_wrtx))]).T
            newpoints1 = line_array+dxynewpoints
            newpoints2 = line_array-dxynewpoints
            pol_inpol = np.concatenate([newpoints1, np.flip(newpoints2,axis=0)])
            pol_inpol_path = Path(pol_inpol)
            bool_all = []
            for iC in range(self.verts.shape[1]):
                test = pol_inpol_path.contains_points(self.verts[:,iC,:])
                bool_all.append(test)
            test_all = np.array(bool_all)
            cellinlinebox_all_bool = (test_all==True).any(axis=0)
        else:
            raise Exception(&#39;ERROR: invalid type for optimize_dist argument&#39;)
        
        #intersect_coords = np.empty((0,2,2))
        intersect_coords = np.empty((0,4))
        intersect_gridnos = np.empty((0),dtype=int) #has to be numbers, since a boolean is differently ordered
        verts_inlinebox = self.verts[cellinlinebox_all_bool,:,:]
        verts_inlinebox_nos = np.where(cellinlinebox_all_bool)[0]
        print(&#39;finding crossing flow links (can take a while if linebox over xy covers a lot of cells, %i of %i cells are being processed)&#39;%(cellinlinebox_all_bool.sum(),len(cellinlinebox_all_bool)))
        
        for iP, pol_data in enumerate(verts_inlinebox):
            pol_shp = Polygon(pol_data[~np.isnan(pol_data).all(axis=1)])
            intersect_result = pol_shp.intersection(line_section)
            if isinstance(intersect_result,shapely.geometry.multilinestring.MultiLineString): #in the rare case that a cell (pol_shp) is crossed by multiple parts of the line
                intersect_result_multi = intersect_result
            elif isinstance(intersect_result,shapely.geometry.linestring.LineString): #if one linepart trough cell (ex/including node), make multilinestring anyway
                if intersect_result.coords == []: #when the line does not cross this cell, intersect_results.coords is an empty linestring and this cell can be skipped (continue makes forloop continue with next in line without finishing the rest of the steps for this instance)
                    continue
                elif len(intersect_result.coords.xy[0]) == 0: #for newer cartopy versions, when line does not cross this cell, intersect_result.coords.xy is (array(&#39;d&#39;), array(&#39;d&#39;)), and both arrays in tuple have len 0.
                    continue
                intersect_result_multi = MultiLineString([intersect_result])
                
            for iLL, intesect_result_one in enumerate(intersect_result_multi.geoms): #loop over multilinestrings, will mostly only contain one linestring. Will be two if the line crosses a cell more than once.
                intersection_line = intesect_result_one.coords
                intline_xyshape = np.array(intersection_line.xy).shape
                #print(&#39;len(intersection_line.xy): %s&#39;%([intline_xyshape]))
                for numlinepart_incell in range(1,intline_xyshape[1]): #is mostly 1, but more if there is a linebreakpoint in this cell (then there are two or more lineparts)
                    intersect_gridnos = np.append(intersect_gridnos,verts_inlinebox_nos[iP])
                    #intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy)[np.newaxis,:,numlinepart_incell-1:numlinepart_incell+1]],axis=0)
                    intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy).T[numlinepart_incell-1:numlinepart_incell+1].flatten()[np.newaxis]])
        
        if intersect_coords.shape[0] != len(intersect_gridnos):
            raise Exception(&#39;something went wrong, intersect_coords.shape[0] and len(intersect_gridnos) are not equal&#39;)
        
        import pandas as pd
        intersect_pd = pd.DataFrame(intersect_coords,index=intersect_gridnos,columns=[&#39;x1&#39;,&#39;y1&#39;,&#39;x2&#39;,&#39;y2&#39;])
        intersect_pd.index.name = &#39;gridnumber&#39;
        
        #TODO up to here could come from meshkernelpy
        
        print(&#39;calculating distance for all crossed cells, from first point of line (should not take long, but if it does, optimisation is needed)&#39;)
        nlinecoords = line_array.shape[0]
        nlinedims = len(line_array.shape)
        ncrosscellparts = len(intersect_pd)
        if nlinecoords&lt;2 or nlinedims != 2:
            raise Exception(&#39;ERROR: line_array should at least contain two xy points [[x,y],[x,y]]&#39;)
        
        #calculate distance between celledge-linepart crossing (is zero when line iL crosses cell)
        distperline_tostart = np.zeros((ncrosscellparts,nlinecoords-1))
        distperline_tostop = np.zeros((ncrosscellparts,nlinecoords-1))
        linepart_length = np.zeros((nlinecoords))
        for iL in range(nlinecoords-1):
            #calculate length of lineparts
            line_section_part = LineString(line_array[iL:iL+2,:])
            if calcdist_fromlatlon:
                linepart_length[iL+1] = calc_dist_haversine(line_array[iL,0],line_array[iL+1,0],line_array[iL,1],line_array[iL+1,1])
            else:
                linepart_length[iL+1] = line_section_part.length
        
            #get distance between all lineparts and point (later used to calculate distance from beginpoint of closest linepart)
            for iP in range(ncrosscellparts):
                distperline_tostart[iP,iL] = line_section_part.distance(Point(intersect_coords[:,0][iP],intersect_coords[:,1][iP]))
                distperline_tostop[iP,iL] = line_section_part.distance(Point(intersect_coords[:,2][iP],intersect_coords[:,3][iP]))
        linepart_lengthcum = np.cumsum(linepart_length)
        cross_points_closestlineid = np.argmin(np.maximum(distperline_tostart,distperline_tostop),axis=1)
        intersect_pd[&#39;closestlineid&#39;] = cross_points_closestlineid
        print(&#39;finished calculating distance for all crossed cells, from first point of line&#39;)
        
        if not calcdist_fromlatlon:
            crs_dist_starts = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
            crs_dist_stops = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
        else:
            crs_dist_starts = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
            crs_dist_stops = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
        intersect_pd[&#39;crs_dist_starts&#39;] = crs_dist_starts
        intersect_pd[&#39;crs_dist_stops&#39;] = crs_dist_stops
        intersect_pd[&#39;linepartlen&#39;] = crs_dist_stops-crs_dist_starts
        intersect_pd = intersect_pd.sort_values(&#39;crs_dist_starts&#39;)
        
        #dimensions (gridnos, xy, firstsecond)
        print(&#39;done finding crossing flow links: %i of %i&#39;%(len(intersect_gridnos),len(cellinlinebox_all_bool)))
        return intersect_pd</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dfm_tools.ugrid.UGrid.fromfile"><code class="name flex">
<span>def <span class="ident">fromfile</span></span>(<span>file_nc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromfile(file_nc):
    import numpy as np
    from netCDF4 import Dataset
    from dfm_tools.get_nc_helpers import get_varname_fromnc, ghostcell_filter
    
    def nodexyfaces2verts(node_x,node_y, faces):
        quatrangles = faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
        quatrangles_filled = quatrangles.filled(int(-999)) #necessary since fill value was changed from -999 to -2147483647 and this cannot be handled for some reason
        #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
        #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
        yz = np.c_[node_x,node_y]
        verts= yz[quatrangles_filled]
        verts[quatrangles.mask==True,:] = np.nan #remove all masked values by making them nan
        return verts
    
    def nodexyfaces2edgeverts(node_x,node_y,edge_nodes, face_x,face_y,edge_faces):
        quatranglese = edge_nodes-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
        quatranglesf = edge_faces-1 #convert 1-based indexing of cell numbering in ugrid to 0-based indexing
        #https://stackoverflow.com/questions/49640311/matplotlib-unstructered-quadrilaterals-instead-of-triangles
        #https://stackoverflow.com/questions/52202014/how-can-i-plot-2d-fem-results-using-matplotlib
        yze = np.c_[node_x,node_y]
        yzf = np.c_[face_x,face_y]
        yzf = np.concatenate([yzf,[[np.nan,np.nan]]]) #add dummy row to index -1, since edge_faces has one 0-value when it is a model border edge. This gets turned into -1 towards quatranglesf (last index), which must be nan eventually
        vertse= yze[quatranglese]
        vertsf= yzf[quatranglesf]
        vertse[quatranglese.mask==True,:] = np.nan #remove all masked values by making them nan
        vertsf[quatranglesf.mask==True,:] = np.nan #remove all masked values by making them nan
        verts_raw = np.concatenate([vertse,vertsf],axis=1)
        edge_verts = verts_raw[:,[0,2,1,3],:] #set ordering in (counter)clockwise direction instead of updown-leftright. second column will sometimes contain nans, then the face is not plotted.
        return edge_verts
    
    data_nc = Dataset(file_nc)
    
    varn_mesh2d_node_x = get_varname_fromnc(data_nc,&#39;mesh2d_node_x&#39;,vardim=&#39;var&#39;)
    varn_mesh2d_node_y = get_varname_fromnc(data_nc,&#39;mesh2d_node_y&#39;,vardim=&#39;var&#39;)
    if varn_mesh2d_node_x is None or varn_mesh2d_node_y is None:
        raise Exception(&#39;file does not contain variables &#34;mesh2d_node_x&#34; and &#34;mesh2d_node_y&#34; or similar, are you sure this is an unstructured grid?&#39;)
    mesh2d_node_x = data_nc.variables[varn_mesh2d_node_x][:]
    mesh2d_node_y = data_nc.variables[varn_mesh2d_node_y][:]
    
    varn_mesh2d_node_z = get_varname_fromnc(data_nc,&#39;mesh2d_node_z&#39;,vardim=&#39;var&#39;)
    if varn_mesh2d_node_z is not None: # node_z variable is present
        mesh2d_node_z = data_nc.variables[varn_mesh2d_node_z][:]
    else:
        mesh2d_node_z = None

    varn_mesh2d_face_nodes = get_varname_fromnc(data_nc,&#39;mesh2d_face_nodes&#39;,vardim=&#39;var&#39;)
    if varn_mesh2d_face_nodes is not None: # node_z variable is present
        mesh2d_face_nodes = data_nc.variables[varn_mesh2d_face_nodes][:, :]
    else:
        raise Exception(&#39;ERROR: provided file does not contain a variable mesh2d_face_nodes or similar:\n%s\nPlease do one of the following:\n- plot grid from *_map.nc file\n- import and export the grid with RGFGRID\n- import and save the gridd &#34;with cellfinfo&#34; from interacter&#39;%(file_nc))
    verts = nodexyfaces2verts(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes) #xy coordinates of face nodes
    
    #varn_mesh2d_edge_x = get_varname_fromnc(data_nc,&#39;mesh2d_edge_x&#39;,vardim=&#39;var&#39;)
    varn_mesh2d_edge_faces = get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)
    if varn_mesh2d_edge_faces is not None: # mesh2d_edge_x (and mesh2d_edge_y) variable is present
        #get coordinates and mapping of edge start/end node
        #mesh2d_edge_x = data_nc.variables[varn_mesh2d_edge_x][:]
        #mesh2d_edge_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_y&#39;,vardim=&#39;var&#39;)][:]
        mesh2d_edge_nodes = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_nodes&#39;,vardim=&#39;var&#39;)][:]
        #get center coordinates and mapping of two bordering faces
        mesh2d_face_x = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_x&#39;,vardim=&#39;var&#39;)][:]
        mesh2d_face_y = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_face_y&#39;,vardim=&#39;var&#39;)][:]
        mesh2d_edge_faces = data_nc.variables[get_varname_fromnc(data_nc,&#39;mesh2d_edge_faces&#39;,vardim=&#39;var&#39;)][:]
        #combine to edge_verts
        edge_verts = nodexyfaces2edgeverts(mesh2d_node_x, mesh2d_node_y, mesh2d_edge_nodes, mesh2d_face_x, mesh2d_face_y, mesh2d_edge_faces) #xy coordinates of face nodes
        
    else:
        edge_verts = None
        
    #remove ghost cells from faces and verts
    nonghost_bool = ghostcell_filter(file_nc)
    if nonghost_bool is not None:
        mesh2d_face_nodes = mesh2d_face_nodes[nonghost_bool]
        verts = verts[nonghost_bool]
        if 0: # remove edges from partition boundaries if there are partitions
            part_edges_removebool = (mesh2d_edge_faces==0).any(axis=1) # Array is 1 based indexed, 0 means missing # &amp; (np.in1d(mesh2d_edge_faces[:,0],ghost_removeids-1) | np.in1d(mesh2d_edge_faces[:,1],ghost_removeids-1))
            edge_verts = edge_verts[~part_edges_removebool]

    data_nc.close()
    ugrid = UGrid(mesh2d_node_x, mesh2d_node_y, mesh2d_face_nodes, verts, mesh2d_node_z=mesh2d_node_z, edge_verts=edge_verts)
    return ugrid</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dfm_tools.ugrid.UGrid.polygon_intersect"><code class="name flex">
<span>def <span class="ident">polygon_intersect</span></span>(<span>self, line_array, optimize_dist=False, calcdist_fromlatlon=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_intersect(self, line_array, optimize_dist=False, calcdist_fromlatlon=False):
    import numpy as np
    from matplotlib.path import Path
    
    from dfm_tools.testutils import try_importmodule
    try_importmodule(modulename=&#39;shapely&#39;)
    import shapely
    from shapely.geometry import LineString, Polygon, MultiLineString, Point
    from dfm_tools.get_nc import calc_dist_pythagoras, calc_dist_haversine

    print(&#39;defining celinlinebox&#39;)
    
    line_section = LineString(line_array)
    
    verts_xmax = np.nanmax(self.verts[:,:,0].data,axis=1)
    verts_xmin = np.nanmin(self.verts[:,:,0].data,axis=1)
    verts_ymax = np.nanmax(self.verts[:,:,1].data,axis=1)
    verts_ymin = np.nanmin(self.verts[:,:,1].data,axis=1)
    
    if not optimize_dist:
        cellinlinebox_all_bool = (((np.min(line_array[:,0]) &lt;= verts_xmax) &amp;
                                   (np.max(line_array[:,0]) &gt;= verts_xmin)) &amp;
                                  ((np.min(line_array[:,1]) &lt;= verts_ymax) &amp; 
                                   (np.max(line_array[:,1]) &gt;= verts_ymin))
                                  )
    elif type(optimize_dist) in [int,float]: #not properly tested and documented
        #calculate angles wrt x axis
        angles_wrtx = []
        nlinecoords = line_array.shape[0]
        for iL in range(nlinecoords-1):
            dx = line_array[iL+1,0] - line_array[iL,0]
            dy = line_array[iL+1,1] - line_array[iL,1]
            angles_wrtx.append(np.rad2deg(np.arctan2(dy,dx)))
        angles_toprev = np.concatenate([[90],np.diff(angles_wrtx),[90]])
        angles_wrtx_ext = np.concatenate([[angles_wrtx[0]-90],np.array(angles_wrtx),[angles_wrtx[-1]+90]])
        angtot_wrtx = angles_wrtx_ext[:-1] + 0.5*(180+angles_toprev)
        #distance over xy-axis from original points
        dxynewpoints = optimize_dist * np.array([np.cos(np.deg2rad(angtot_wrtx)),np.sin(np.deg2rad(angtot_wrtx))]).T
        newpoints1 = line_array+dxynewpoints
        newpoints2 = line_array-dxynewpoints
        pol_inpol = np.concatenate([newpoints1, np.flip(newpoints2,axis=0)])
        pol_inpol_path = Path(pol_inpol)
        bool_all = []
        for iC in range(self.verts.shape[1]):
            test = pol_inpol_path.contains_points(self.verts[:,iC,:])
            bool_all.append(test)
        test_all = np.array(bool_all)
        cellinlinebox_all_bool = (test_all==True).any(axis=0)
    else:
        raise Exception(&#39;ERROR: invalid type for optimize_dist argument&#39;)
    
    #intersect_coords = np.empty((0,2,2))
    intersect_coords = np.empty((0,4))
    intersect_gridnos = np.empty((0),dtype=int) #has to be numbers, since a boolean is differently ordered
    verts_inlinebox = self.verts[cellinlinebox_all_bool,:,:]
    verts_inlinebox_nos = np.where(cellinlinebox_all_bool)[0]
    print(&#39;finding crossing flow links (can take a while if linebox over xy covers a lot of cells, %i of %i cells are being processed)&#39;%(cellinlinebox_all_bool.sum(),len(cellinlinebox_all_bool)))
    
    for iP, pol_data in enumerate(verts_inlinebox):
        pol_shp = Polygon(pol_data[~np.isnan(pol_data).all(axis=1)])
        intersect_result = pol_shp.intersection(line_section)
        if isinstance(intersect_result,shapely.geometry.multilinestring.MultiLineString): #in the rare case that a cell (pol_shp) is crossed by multiple parts of the line
            intersect_result_multi = intersect_result
        elif isinstance(intersect_result,shapely.geometry.linestring.LineString): #if one linepart trough cell (ex/including node), make multilinestring anyway
            if intersect_result.coords == []: #when the line does not cross this cell, intersect_results.coords is an empty linestring and this cell can be skipped (continue makes forloop continue with next in line without finishing the rest of the steps for this instance)
                continue
            elif len(intersect_result.coords.xy[0]) == 0: #for newer cartopy versions, when line does not cross this cell, intersect_result.coords.xy is (array(&#39;d&#39;), array(&#39;d&#39;)), and both arrays in tuple have len 0.
                continue
            intersect_result_multi = MultiLineString([intersect_result])
            
        for iLL, intesect_result_one in enumerate(intersect_result_multi.geoms): #loop over multilinestrings, will mostly only contain one linestring. Will be two if the line crosses a cell more than once.
            intersection_line = intesect_result_one.coords
            intline_xyshape = np.array(intersection_line.xy).shape
            #print(&#39;len(intersection_line.xy): %s&#39;%([intline_xyshape]))
            for numlinepart_incell in range(1,intline_xyshape[1]): #is mostly 1, but more if there is a linebreakpoint in this cell (then there are two or more lineparts)
                intersect_gridnos = np.append(intersect_gridnos,verts_inlinebox_nos[iP])
                #intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy)[np.newaxis,:,numlinepart_incell-1:numlinepart_incell+1]],axis=0)
                intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy).T[numlinepart_incell-1:numlinepart_incell+1].flatten()[np.newaxis]])
    
    if intersect_coords.shape[0] != len(intersect_gridnos):
        raise Exception(&#39;something went wrong, intersect_coords.shape[0] and len(intersect_gridnos) are not equal&#39;)
    
    import pandas as pd
    intersect_pd = pd.DataFrame(intersect_coords,index=intersect_gridnos,columns=[&#39;x1&#39;,&#39;y1&#39;,&#39;x2&#39;,&#39;y2&#39;])
    intersect_pd.index.name = &#39;gridnumber&#39;
    
    #TODO up to here could come from meshkernelpy
    
    print(&#39;calculating distance for all crossed cells, from first point of line (should not take long, but if it does, optimisation is needed)&#39;)
    nlinecoords = line_array.shape[0]
    nlinedims = len(line_array.shape)
    ncrosscellparts = len(intersect_pd)
    if nlinecoords&lt;2 or nlinedims != 2:
        raise Exception(&#39;ERROR: line_array should at least contain two xy points [[x,y],[x,y]]&#39;)
    
    #calculate distance between celledge-linepart crossing (is zero when line iL crosses cell)
    distperline_tostart = np.zeros((ncrosscellparts,nlinecoords-1))
    distperline_tostop = np.zeros((ncrosscellparts,nlinecoords-1))
    linepart_length = np.zeros((nlinecoords))
    for iL in range(nlinecoords-1):
        #calculate length of lineparts
        line_section_part = LineString(line_array[iL:iL+2,:])
        if calcdist_fromlatlon:
            linepart_length[iL+1] = calc_dist_haversine(line_array[iL,0],line_array[iL+1,0],line_array[iL,1],line_array[iL+1,1])
        else:
            linepart_length[iL+1] = line_section_part.length
    
        #get distance between all lineparts and point (later used to calculate distance from beginpoint of closest linepart)
        for iP in range(ncrosscellparts):
            distperline_tostart[iP,iL] = line_section_part.distance(Point(intersect_coords[:,0][iP],intersect_coords[:,1][iP]))
            distperline_tostop[iP,iL] = line_section_part.distance(Point(intersect_coords[:,2][iP],intersect_coords[:,3][iP]))
    linepart_lengthcum = np.cumsum(linepart_length)
    cross_points_closestlineid = np.argmin(np.maximum(distperline_tostart,distperline_tostop),axis=1)
    intersect_pd[&#39;closestlineid&#39;] = cross_points_closestlineid
    print(&#39;finished calculating distance for all crossed cells, from first point of line&#39;)
    
    if not calcdist_fromlatlon:
        crs_dist_starts = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    else:
        crs_dist_starts = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    intersect_pd[&#39;crs_dist_starts&#39;] = crs_dist_starts
    intersect_pd[&#39;crs_dist_stops&#39;] = crs_dist_stops
    intersect_pd[&#39;linepartlen&#39;] = crs_dist_stops-crs_dist_starts
    intersect_pd = intersect_pd.sort_values(&#39;crs_dist_starts&#39;)
    
    #dimensions (gridnos, xy, firstsecond)
    print(&#39;done finding crossing flow links: %i of %i&#39;%(len(intersect_gridnos),len(cellinlinebox_all_bool)))
    return intersect_pd</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools" href="index.html">dfm_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dfm_tools.ugrid.UGrid" href="#dfm_tools.ugrid.UGrid">UGrid</a></code></h4>
<ul class="">
<li><code><a title="dfm_tools.ugrid.UGrid.fromfile" href="#dfm_tools.ugrid.UGrid.fromfile">fromfile</a></code></li>
<li><code><a title="dfm_tools.ugrid.UGrid.polygon_intersect" href="#dfm_tools.ugrid.UGrid.polygon_intersect">polygon_intersect</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>