<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dfm_tools.modplot API documentation</title>
<meta name="description" content="Created on Wed Mar 25 15:26:55 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.modplot</code></h1>
</header>
<section id="section-intro">
<p>Created on Wed Mar 25 15:26:55 2020</p>
<p>@author: Kieran Hunt
<a href="https://github.com/kieranmrhunt/curved-quivers/blob/master/modplot.py">https://github.com/kieranmrhunt/curved-quivers/blob/master/modplot.py</a>
<a href="https://stackoverflow.com/questions/51843313/flow-visualisation-in-python-using-curved-path-following-vectors">https://stackoverflow.com/questions/51843313/flow-visualisation-in-python-using-curved-path-following-vectors</a>
aligned with matplotlib.streamplot and improved by Jelmer Veenstra (30-03-2023), <a href="https://github.com/veenstrajelmer">https://github.com/veenstrajelmer</a>
matplotlib.streamplot available at <a href="https://raw.githubusercontent.com/matplotlib/matplotlib/main/lib/matplotlib/streamplot.py">https://raw.githubusercontent.com/matplotlib/matplotlib/main/lib/matplotlib/streamplot.py</a></p>
<p>Streamline plotting for 2D vector fields.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Wed Mar 25 15:26:55 2020

@author: Kieran Hunt
https://github.com/kieranmrhunt/curved-quivers/blob/master/modplot.py
https://stackoverflow.com/questions/51843313/flow-visualisation-in-python-using-curved-path-following-vectors
aligned with matplotlib.streamplot and improved by Jelmer Veenstra (30-03-2023), https://github.com/veenstrajelmer
matplotlib.streamplot available at https://raw.githubusercontent.com/matplotlib/matplotlib/main/lib/matplotlib/streamplot.py

Streamline plotting for 2D vector fields.

&#34;&#34;&#34;

import numpy as np

import matplotlib as mpl
from matplotlib import _api, cm, patches
import matplotlib.colors as mcolors
import matplotlib.collections as mcollections
import matplotlib.lines as mlines


__all__ = [&#39;velovect&#39;]


def velovect(axes, x, y, u, v, density=1, linewidth=None, color=None,
               cmap=None, norm=None, arrowsize=1, arrowstyle=&#39;-|&gt;&#39;,
               transform=None, zorder=None, start_points=None,
               integration_direction=&#39;both&#39;,
               grains=15,
               broken_streamlines=True):
    &#34;&#34;&#34;
    Draw streamlines of a vector flow.

    Parameters
    ----------
    x, y : 1D/2D arrays
        Evenly spaced strictly increasing arrays to make a grid.  If 2D, all
        rows of *x* must be equal and all columns of *y* must be equal; i.e.,
        they must be as if generated by ``np.meshgrid(x_1d, y_1d)``.
    u, v : 2D arrays
        *x* and *y*-velocities. The number of rows and columns must match
        the length of *y* and *x*, respectively.
    density : float or (float, float)
        Controls the closeness of streamlines. When ``density = 1``, the domain
        is divided into a 30x30 grid. *density* linearly scales this grid.
        Each cell in the grid can have, at most, one traversing streamline.
        For different densities in each direction, use a tuple
        (density_x, density_y).
    linewidth : float or 2D array
        The width of the streamlines. With a 2D array the line width can be
        varied across the grid. The array must have the same shape as *u*
        and *v*.
    color : color or 2D array
        The streamline color. If given an array, its values are converted to
        colors using *cmap* and *norm*.  The array must have the same shape
        as *u* and *v*.
    cmap, norm
        Data normalization and colormapping parameters for *color*; only used
        if *color* is an array of floats. See `~.Axes.imshow` for a detailed
        description.
    arrowsize : float
        Scaling factor for the arrow size.
    arrowstyle : str
        Arrow style specification.
        See `~matplotlib.patches.FancyArrowPatch`.
    minlength : float
        Minimum length of streamline in axes coordinates.
    start_points : (N, 2) array
        Coordinates of starting points for the streamlines in data coordinates
        (the same coordinates as the *x* and *y* arrays).
    zorder : float
        The zorder of the streamlines and arrows.
        Artists with lower zorder values are drawn first.
    maxlength : float
        Maximum length of streamline in axes coordinates.
    integration_direction : {&#39;forward&#39;, &#39;backward&#39;, &#39;both&#39;}, default: &#39;both&#39;
        Integrate the streamline in forward, backward or both directions.
    data : indexable object, optional
        DATA_PARAMETER_PLACEHOLDER
    broken_streamlines : boolean, default: True
        If False, forces streamlines to continue until they
        leave the plot domain.  If True, they may be terminated if they
        come too close to another streamline.

    Returns
    -------
    StreamplotSet
        Container object with attributes
 
        - ``lines``: `.LineCollection` of streamlines

        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`
          objects representing the arrows half-way along streamlines.

            This container will probably change in the future to allow changes
            to the colormap, alpha, etc. for both lines and arrows, but these
            changes should be backward compatible.
    &#34;&#34;&#34;
    grid = Grid(x, y)
    mask = StreamMask(10)
    dmap = DomainMap(grid, mask)

    if zorder is None:
        zorder = mlines.Line2D.zorder

    # default to data coordinates
    if transform is None:
        transform = axes.transData

    if color is None:
        color = axes._get_lines.get_next_color()

    if linewidth is None:
        linewidth = mpl.rcParams[&#39;lines.linewidth&#39;]

    line_kw = {}
    arrow_kw = dict(arrowstyle=arrowstyle, mutation_scale=10 * arrowsize)

    _api.check_in_list([&#39;both&#39;, &#39;forward&#39;, &#39;backward&#39;],
                       integration_direction=integration_direction)

    #if integration_direction == &#39;both&#39;: #done for magnitude
    #    maxlength /= 2.

    use_multicolor_lines = isinstance(color, np.ndarray)
    if use_multicolor_lines:
        if color.shape != grid.shape:
            raise ValueError(&#34;If &#39;color&#39; is given, it must match the shape of &#34;
                             &#34;the (x, y) grid&#34;)
        line_colors = [[]]  # Empty entry allows concatenation of zero arrays.
        color = np.ma.masked_invalid(color)
    else:
        line_kw[&#39;color&#39;] = color
        arrow_kw[&#39;color&#39;] = color

    if isinstance(linewidth, np.ndarray):
        if linewidth.shape != grid.shape:
            raise ValueError(&#34;If &#39;linewidth&#39; is given, it must match the &#34;
                             &#34;shape of the (x, y) grid&#34;)
        line_kw[&#39;linewidth&#39;] = []
    else:
        line_kw[&#39;linewidth&#39;] = linewidth
        arrow_kw[&#39;linewidth&#39;] = linewidth

    line_kw[&#39;zorder&#39;] = zorder
    arrow_kw[&#39;zorder&#39;] = zorder

    # Sanity checks.
    if u.shape != grid.shape or v.shape != grid.shape:
        raise ValueError(&#34;&#39;u&#39; and &#39;v&#39; must match the shape of the (x, y) grid&#34;)

    u = np.ma.masked_invalid(u)
    v = np.ma.masked_invalid(v)
    magnitude = np.sqrt(u**2 + v**2)
    magnitude/=np.max(magnitude)
    if integration_direction == &#39;both&#39;:
        magnitude /= 2.
        
    resolution = density/np.max(grains)
    integrate = _get_integrator(u, v, dmap, resolution, magnitude, integration_direction)

    trajectories = []    
   
    if start_points is None:
        start_points=_gen_starting_points(x,y,grains)
    
    sp2 = np.asanyarray(start_points, dtype=float).copy()

    # Check if start_points are outside the data boundaries
    for xs, ys in sp2:
        if not (grid.x_origin &lt;= xs &lt;= grid.x_origin + grid.width and
                grid.y_origin &lt;= ys &lt;= grid.y_origin + grid.height):
                raise ValueError(f&#34;Starting point ({xs}, {ys}) outside of &#34;
                                 &#34;data boundaries&#34;)

    # Convert start_points from data to array coords
    # Shift the seed points from the bottom left of the data so that
    # data2grid works properly.
    sp2[:, 0] -= grid.x_origin
    sp2[:, 1] -= grid.y_origin

    for xs, ys in sp2:
        xg, yg = dmap.data2grid(xs, ys)
        # Floating point issues can cause xg, yg to be slightly out of
        # bounds for xs, ys on the upper boundaries. Because we have
        # already checked that the starting points are within the original
        # grid, clip the xg, yg to the grid to work around this issue
        xg = np.clip(xg, 0, grid.nx - 1)
        yg = np.clip(yg, 0, grid.ny - 1)
        
        t = integrate(xg, yg, broken_streamlines)
        if t is not None:
            trajectories.append(t)

    if use_multicolor_lines:
        if norm is None:
            norm = mcolors.Normalize(color.min(), color.max())
        cmap = cm._ensure_cmap(cmap)

    streamlines = []
    arrows = []
    for t in trajectories:
        tgx, tgy = t.T
        # Rescale from grid-coordinates to data-coordinates.
        tx, ty = dmap.grid2data(tgx, tgy)
        tx += grid.x_origin
        ty += grid.y_origin

        # Create multiple tiny segments if varying width or color is given
        if isinstance(linewidth, np.ndarray) or use_multicolor_lines:
            points = np.transpose([tx, ty]).reshape(-1, 1, 2)
            streamlines.extend(np.hstack([points[:-1], points[1:]]))
        else:
            points = np.transpose([tx, ty])
            streamlines.append(points)

        # Add arrows halfway along each trajectory.
        s = np.cumsum(np.hypot(np.diff(tx), np.diff(ty)))
        n = np.searchsorted(s, s[-1])
        arrow_tail = (tx[n], ty[n])
        arrow_head = (np.mean(tx[n:n + 2]), np.mean(ty[n:n + 2]))

        if isinstance(linewidth, np.ndarray):
            line_widths = interpgrid(linewidth, tgx, tgy)[:-1]
            line_kw[&#39;linewidth&#39;].extend(line_widths)
            arrow_kw[&#39;linewidth&#39;] = line_widths[n]

        if use_multicolor_lines:
            color_values = interpgrid(color, tgx, tgy)[:-1]
            line_colors.append(color_values)
            arrow_kw[&#39;color&#39;] = cmap(norm(color_values[n]))

        p = patches.FancyArrowPatch(
            arrow_tail, arrow_head, transform=transform, **arrow_kw)
        arrows.append(p)
        
    lc = mcollections.LineCollection(
        streamlines, transform=transform, **line_kw)
    lc.sticky_edges.x[:] = [grid.x_origin, grid.x_origin + grid.width]
    lc.sticky_edges.y[:] = [grid.y_origin, grid.y_origin + grid.height]
    if use_multicolor_lines:
        lc.set_array(np.ma.hstack(line_colors))
        lc.set_cmap(cmap)
        lc.set_norm(norm)
    axes.add_collection(lc)

    ac = mcollections.PatchCollection(arrows)
    # Adding the collection itself is broken; see #2341.
    for p in arrows:
        axes.add_patch(p)

    axes.autoscale_view()
    stream_container = StreamplotSet(lc, ac)
    return stream_container

        
class StreamplotSet:

    def __init__(self, lines, arrows):
        self.lines = lines
        self.arrows = arrows


# Coordinate definitions
# ========================

class DomainMap:
    &#34;&#34;&#34;
    Map representing different coordinate systems.

    Coordinate definitions:

    * axes-coordinates goes from 0 to 1 in the domain.
    * data-coordinates are specified by the input x-y coordinates.
    * grid-coordinates goes from 0 to N and 0 to M for an N x M grid,
      where N and M match the shape of the input data.
    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask,
      where N and M are user-specified to control the density of streamlines.

    This class also has methods for adding trajectories to the StreamMask.
    Before adding a trajectory, run `start_trajectory` to keep track of regions
    crossed by a given trajectory. Later, if you decide the trajectory is bad
    (e.g., if the trajectory is very short) just call `undo_trajectory`.
    &#34;&#34;&#34;

    def __init__(self, grid, mask):
        self.grid = grid
        self.mask = mask
        # Constants for conversion between grid- and mask-coordinates
        self.x_grid2mask = (mask.nx - 1) / (grid.nx - 1)
        self.y_grid2mask = (mask.ny - 1) / (grid.ny - 1)

        self.x_mask2grid = 1. / self.x_grid2mask
        self.y_mask2grid = 1. / self.y_grid2mask

        self.x_data2grid = 1. / grid.dx
        self.y_data2grid = 1. / grid.dy

    def grid2mask(self, xi, yi):
        &#34;&#34;&#34;Return nearest space in mask-coords from given grid-coords.&#34;&#34;&#34;
        return round(xi * self.x_grid2mask), round(yi * self.y_grid2mask)

    def mask2grid(self, xm, ym):
        return xm * self.x_mask2grid, ym * self.y_mask2grid

    def data2grid(self, xd, yd):
        return xd * self.x_data2grid, yd * self.y_data2grid

    def grid2data(self, xg, yg):
        return xg / self.x_data2grid, yg / self.y_data2grid

    def start_trajectory(self, xg, yg, broken_streamlines=True):
        xm, ym = self.grid2mask(xg, yg)
        self.mask._start_trajectory(xm, ym, broken_streamlines)

    def reset_start_point(self, xg, yg):
        xm, ym = self.grid2mask(xg, yg)
        self.mask._current_xy = (xm, ym)

    def update_trajectory(self, xg, yg, broken_streamlines=True):
        if not self.grid.within_grid(xg, yg):
            raise InvalidIndexError
        xm, ym = self.grid2mask(xg, yg)
        self.mask._update_trajectory(xm, ym, broken_streamlines)

    def undo_trajectory(self):
        self.mask._undo_trajectory()


class Grid:
    &#34;&#34;&#34;Grid of data.&#34;&#34;&#34;
    def __init__(self, x, y):

        if np.ndim(x) == 1:
            pass
        elif np.ndim(x) == 2:
            x_row = x[0]
            if not np.allclose(x_row, x):
                raise ValueError(&#34;The rows of &#39;x&#39; must be equal&#34;)
            x = x_row
        else:
            raise ValueError(&#34;&#39;x&#39; can have at maximum 2 dimensions&#34;)

        if np.ndim(y) == 1:
            pass
        elif np.ndim(y) == 2:
            yt = np.transpose(y)  # Also works for nested lists.
            y_col = yt[0]
            if not np.allclose(y_col, yt):
                raise ValueError(&#34;The columns of &#39;y&#39; must be equal&#34;)
            y = y_col
        else:
            raise ValueError(&#34;&#39;y&#39; can have at maximum 2 dimensions&#34;)

        if not (np.diff(x) &gt; 0).all():
            raise ValueError(&#34;&#39;x&#39; must be strictly increasing&#34;)
        if not (np.diff(y) &gt; 0).all():
            raise ValueError(&#34;&#39;y&#39; must be strictly increasing&#34;)

        self.nx = len(x)
        self.ny = len(y)

        self.dx = x[1] - x[0]
        self.dy = y[1] - y[0]

        self.x_origin = x[0]
        self.y_origin = y[0]

        self.width = x[-1] - x[0]
        self.height = y[-1] - y[0]

        if not np.allclose(np.diff(x), self.width / (self.nx - 1)):
            raise ValueError(&#34;&#39;x&#39; values must be equally spaced&#34;)
        if not np.allclose(np.diff(y), self.height / (self.ny - 1)):
            raise ValueError(&#34;&#39;y&#39; values must be equally spaced&#34;)

    @property
    def shape(self):
        return self.ny, self.nx

    def within_grid(self, xi, yi):
        &#34;&#34;&#34;Return whether (*xi*, *yi*) is a valid index of the grid.&#34;&#34;&#34;
        # Note that xi/yi can be floats; so, for example, we can&#39;t simply check
        # `xi &lt; self.nx` since *xi* can be `self.nx - 1 &lt; xi &lt; self.nx`
        return 0 &lt;= xi &lt;= self.nx - 1 and 0 &lt;= yi &lt;= self.ny - 1


class StreamMask:
    &#34;&#34;&#34;
    Mask to keep track of discrete regions crossed by streamlines.

    The resolution of this grid determines the approximate spacing between
    trajectories. Streamlines are only allowed to pass through zeroed cells:
    When a streamline enters a cell, that cell is set to 1, and no new
    streamlines are allowed to enter.
    &#34;&#34;&#34;

    def __init__(self, density):
        try:
            self.nx, self.ny = (30 * np.broadcast_to(density, 2)).astype(int)
        except ValueError as err:
            raise ValueError(&#34;&#39;density&#39; must be a scalar or be of length &#34;
                             &#34;2&#34;) from err
        if self.nx &lt; 0 or self.ny &lt; 0:
            raise ValueError(&#34;&#39;density&#39; must be positive&#34;)
        self._mask = np.zeros((self.ny, self.nx))
        self.shape = self._mask.shape

        self._current_xy = None

    def __getitem__(self, args):
        return self._mask[args]

    def _start_trajectory(self, xm, ym, broken_streamlines=True):
        &#34;&#34;&#34;Start recording streamline trajectory&#34;&#34;&#34;
        self._traj = []
        self._update_trajectory(xm, ym, broken_streamlines)

    def _undo_trajectory(self):
        &#34;&#34;&#34;Remove current trajectory from mask&#34;&#34;&#34;
        for t in self._traj:
            self._mask[t] = 0

    def _update_trajectory(self, xm, ym, broken_streamlines=True):
        &#34;&#34;&#34;
        Update current trajectory position in mask.

        If the new position has already been filled, raise `InvalidIndexError`.
        &#34;&#34;&#34;
        if self._current_xy != (xm, ym):
            if self[ym, xm] == 0:
                self._traj.append((ym, xm))
                self._mask[ym, xm] = 1
                self._current_xy = (xm, ym)
            else:
                if broken_streamlines:
                    raise InvalidIndexError
                else:
                    pass


class InvalidIndexError(Exception):
    pass


class TerminateTrajectory(Exception):
    pass


# Integrator definitions
# =======================

def _get_integrator(u, v, dmap, resolution, magnitude, integration_direction):

    # rescale velocity onto grid-coordinates for integrations.
    u, v = dmap.data2grid(u, v)

    # speed (path length) will be in axes-coordinates
    u_ax = u / (dmap.grid.nx - 1)
    v_ax = v / (dmap.grid.ny - 1)
    speed = np.ma.sqrt(u_ax ** 2 + v_ax ** 2)

    def forward_time(xi, yi):
        if not dmap.grid.within_grid(xi, yi):
            raise OutOfBounds
        ds_dt = interpgrid(speed, xi, yi)
        if ds_dt == 0:
            raise TerminateTrajectory()
        dt_ds = 1. / ds_dt
        ui = interpgrid(u, xi, yi)
        vi = interpgrid(v, xi, yi)
        return ui * dt_ds, vi * dt_ds

    def backward_time(xi, yi):
        dxi, dyi = forward_time(xi, yi)
        return -dxi, -dyi

    def integrate(x0, y0, broken_streamlines=True):
        &#34;&#34;&#34;
        Return x, y grid-coordinates of trajectory based on starting point.

        Integrate both forward and backward in time from starting point in
        grid coordinates.

        Integration is terminated when a trajectory reaches a domain boundary
        or when it crosses into an already occupied cell in the StreamMask. The
        resulting trajectory is None if it is shorter than `minlength`.
        &#34;&#34;&#34;

        stotal, xy_traj = 0., []

        try:
            dmap.start_trajectory(x0, y0, broken_streamlines)
        except InvalidIndexError:
            return None
        if integration_direction in [&#39;both&#39;, &#39;backward&#39;]:
            s, xyt = _integrate_rk12(x0, y0, dmap, backward_time, resolution, magnitude,
                                     broken_streamlines)
            stotal += s
            xy_traj += xyt[::-1]

        if integration_direction in [&#39;both&#39;, &#39;forward&#39;]:
            dmap.reset_start_point(x0, y0)
            s, xyt = _integrate_rk12(x0, y0, dmap, forward_time, resolution, magnitude,
                                     broken_streamlines)
            stotal += s
            xy_traj += xyt[1:]

        if len(xy_traj) &gt; 1:
            return np.broadcast_arrays(xy_traj, np.empty((1, 2)))[0]
        else:  # reject short trajectories
            dmap.undo_trajectory()
            return None

    return integrate


class OutOfBounds(IndexError):
    pass


def _integrate_rk12(x0, y0, dmap, f, resolution, magnitude, broken_streamlines=True):
    &#34;&#34;&#34;
    2nd-order Runge-Kutta algorithm with adaptive step size.

    This method is also referred to as the improved Euler&#39;s method, or Heun&#39;s
    method. This method is favored over higher-order methods because:

    1. To get decent looking trajectories and to sample every mask cell
       on the trajectory we need a small timestep, so a lower order
       solver doesn&#39;t hurt us unless the data is *very* high resolution.
       In fact, for cases where the user inputs
       data smaller or of similar grid size to the mask grid, the higher
       order corrections are negligible because of the very fast linear
       interpolation used in `interpgrid`.

    2. For high resolution input data (i.e. beyond the mask
       resolution), we must reduce the timestep. Therefore, an adaptive
       timestep is more suited to the problem as this would be very hard
       to judge automatically otherwise.

    This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using
    similar Python implementations) in most setups.
    &#34;&#34;&#34;
    # This error is below that needed to match the RK4 integrator. It
    # is set for visual reasons -- too low and corners start
    # appearing ugly and jagged. Can be tuned.
    maxerror = 0.003

    # This limit is important (for all integrators) to avoid the
    # trajectory skipping some mask cells. We could relax this
    # condition if we use the code which is commented out below to
    # increment the location gradually. However, due to the efficient
    # nature of the interpolation, this doesn&#39;t boost speed by much
    # for quite a bit of complexity.
    maxds = min(1. / dmap.mask.nx, 1. / dmap.mask.ny, 0.1)

    ds = maxds
    stotal = 0
    xi = x0
    yi = y0
    xyf_traj = []
    m_total = []
    
    while True:
        try:
            if dmap.grid.within_grid(xi, yi):
                xyf_traj.append((xi, yi))
                m_total.append(interpgrid(magnitude, xi, yi))
                maxlength = resolution*np.mean(m_total)
            else:
                raise OutOfBounds

            # Compute the two intermediate gradients.
            # f should raise OutOfBounds if the locations given are
            # outside the grid.
            k1x, k1y = f(xi, yi)
            k2x, k2y = f(xi + ds * k1x, yi + ds * k1y)

        except OutOfBounds:
            # Out of the domain during this step.
            # Take an Euler step to the boundary to improve neatness
            # unless the trajectory is currently empty.
            if xyf_traj:
                ds, xyf_traj = _euler_step(xyf_traj, dmap, f)
                stotal += ds
            break
        except TerminateTrajectory:
            break

        dx1 = ds * k1x
        dy1 = ds * k1y
        dx2 = ds * 0.5 * (k1x + k2x)
        dy2 = ds * 0.5 * (k1y + k2y)

        ny, nx = dmap.grid.shape
        # Error is normalized to the axes coordinates
        error = np.hypot((dx2 - dx1) / (nx - 1), (dy2 - dy1) / (ny - 1))

        # Only save step if within error tolerance
        if error &lt; maxerror:
            xi += dx2
            yi += dy2
            try:
                dmap.update_trajectory(xi, yi, broken_streamlines)
            except InvalidIndexError:
                break
            if stotal + ds &gt; maxlength:
                break
            stotal += ds

        # recalculate stepsize based on step error
        if error == 0:
            ds = maxds
        else:
            ds = min(maxds, 0.85 * ds * (maxerror / error) ** 0.5)

    return stotal, xyf_traj


def _euler_step(xyf_traj, dmap, f):
    &#34;&#34;&#34;Simple Euler integration step that extends streamline to boundary.&#34;&#34;&#34;
    ny, nx = dmap.grid.shape
    xi, yi = xyf_traj[-1]
    cx, cy = f(xi, yi)
    if cx == 0:
        dsx = np.inf
    elif cx &lt; 0:
        dsx = xi / -cx
    else:
        dsx = (nx - 1 - xi) / cx
    if cy == 0:
        dsy = np.inf
    elif cy &lt; 0:
        dsy = yi / -cy
    else:
        dsy = (ny - 1 - yi) / cy
    ds = min(dsx, dsy)
    xyf_traj.append((xi + cx * ds, yi + cy * ds))
    return ds, xyf_traj


# Utility functions
# ========================

def interpgrid(a, xi, yi):
    &#34;&#34;&#34;Fast 2D, linear interpolation on an integer grid&#34;&#34;&#34;

    Ny, Nx = np.shape(a)
    if isinstance(xi, np.ndarray):
        x = xi.astype(int)
        y = yi.astype(int)
        # Check that xn, yn don&#39;t exceed max index
        xn = np.clip(x + 1, 0, Nx - 1)
        yn = np.clip(y + 1, 0, Ny - 1)
    else:
        x = int(xi)
        y = int(yi)
        # conditional is faster than clipping for integers
        if x == (Nx - 1):
            xn = x
        else:
            xn = x + 1
        if y == (Ny - 1):
            yn = y
        else:
            yn = y + 1

    a00 = a[y, x]
    a01 = a[y, xn]
    a10 = a[yn, x]
    a11 = a[yn, xn]
    xt = xi - x
    yt = yi - y
    a0 = a00 * (1 - xt) + a01 * xt
    a1 = a10 * (1 - xt) + a11 * xt
    ai = a0 * (1 - yt) + a1 * yt

    if not isinstance(xi, np.ndarray):
        if np.ma.is_masked(ai):
            raise TerminateTrajectory

    return ai


def _gen_starting_points(x,y,grains):
    if isinstance(grains,tuple):
        nx, ny = grains
    elif isinstance(grains,int):
        nx = ny = grains
    
    eps = np.finfo(np.float32).eps
    
    tmp_x =  np.linspace(x.min()+eps, x.max()-eps, nx)
    tmp_y =  np.linspace(y.min()+eps, y.max()-eps, ny)
    
    xs = np.tile(tmp_x, ny)
    ys = np.repeat(tmp_y, nx)

    seed_points = np.array([xs, ys])
    
    return seed_points.T</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.modplot.velovect"><code class="name flex">
<span>def <span class="ident">velovect</span></span>(<span>axes, x, y, u, v, density=1, linewidth=None, color=None, cmap=None, norm=None, arrowsize=1, arrowstyle=&#x27;-|&gt;&#x27;, transform=None, zorder=None, start_points=None, integration_direction='both', grains=15, broken_streamlines=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw streamlines of a vector flow.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>1D/2D arrays</code></dt>
<dd>Evenly spaced strictly increasing arrays to make a grid.
If 2D, all
rows of <em>x</em> must be equal and all columns of <em>y</em> must be equal; i.e.,
they must be as if generated by <code>np.meshgrid(x_1d, y_1d)</code>.</dd>
<dt><strong><code>u</code></strong>, <strong><code>v</code></strong> :&ensp;<code>2D arrays</code></dt>
<dd><em>x</em> and <em>y</em>-velocities. The number of rows and columns must match
the length of <em>y</em> and <em>x</em>, respectively.</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code> or <code>(float, float)</code></dt>
<dd>Controls the closeness of streamlines. When <code>density = 1</code>, the domain
is divided into a 30x30 grid. <em>density</em> linearly scales this grid.
Each cell in the grid can have, at most, one traversing streamline.
For different densities in each direction, use a tuple
(density_x, density_y).</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code> or <code>2D array</code></dt>
<dd>The width of the streamlines. With a 2D array the line width can be
varied across the grid. The array must have the same shape as <em>u</em>
and <em>v</em>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>color</code> or <code>2D array</code></dt>
<dd>The streamline color. If given an array, its values are converted to
colors using <em>cmap</em> and <em>norm</em>.
The array must have the same shape
as <em>u</em> and <em>v</em>.</dd>
<dt><strong><code>cmap</code></strong>, <strong><code>norm</code></strong></dt>
<dd>Data normalization and colormapping parameters for <em>color</em>; only used
if <em>color</em> is an array of floats. See <code>~.Axes.imshow</code> for a detailed
description.</dd>
<dt><strong><code>arrowsize</code></strong> :&ensp;<code>float</code></dt>
<dd>Scaling factor for the arrow size.</dd>
<dt><strong><code>arrowstyle</code></strong> :&ensp;<code>str</code></dt>
<dd>Arrow style specification.
See <code>~matplotlib.patches.FancyArrowPatch</code>.</dd>
<dt><strong><code>minlength</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum length of streamline in axes coordinates.</dd>
<dt><strong><code>start_points</code></strong> :&ensp;<code>(N, 2) array</code></dt>
<dd>Coordinates of starting points for the streamlines in data coordinates
(the same coordinates as the <em>x</em> and <em>y</em> arrays).</dd>
<dt><strong><code>zorder</code></strong> :&ensp;<code>float</code></dt>
<dd>The zorder of the streamlines and arrows.
Artists with lower zorder values are drawn first.</dd>
<dt><strong><code>maxlength</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum length of streamline in axes coordinates.</dd>
<dt><strong><code>integration_direction</code></strong> :&ensp;<code>{'forward', 'backward', 'both'}</code>, default<code>: 'both'</code></dt>
<dd>Integrate the streamline in forward, backward or both directions.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>indexable object</code>, optional</dt>
<dd>DATA_PARAMETER_PLACEHOLDER</dd>
<dt><strong><code>broken_streamlines</code></strong> :&ensp;<code>boolean</code>, default<code>: True</code></dt>
<dd>If False, forces streamlines to continue until they
leave the plot domain.
If True, they may be terminated if they
come too close to another streamline.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StreamplotSet</code></dt>
<dd>
<p>Container object with attributes</p>
<ul>
<li>
<p><code>lines</code>: <code>.LineCollection</code> of streamlines</p>
</li>
<li>
<p><code>arrows</code>: <code>.PatchCollection</code> containing <code>.FancyArrowPatch</code>
objects representing the arrows half-way along streamlines.</p>
<p>This container will probably change in the future to allow changes
to the colormap, alpha, etc. for both lines and arrows, but these
changes should be backward compatible.</p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def velovect(axes, x, y, u, v, density=1, linewidth=None, color=None,
               cmap=None, norm=None, arrowsize=1, arrowstyle=&#39;-|&gt;&#39;,
               transform=None, zorder=None, start_points=None,
               integration_direction=&#39;both&#39;,
               grains=15,
               broken_streamlines=True):
    &#34;&#34;&#34;
    Draw streamlines of a vector flow.

    Parameters
    ----------
    x, y : 1D/2D arrays
        Evenly spaced strictly increasing arrays to make a grid.  If 2D, all
        rows of *x* must be equal and all columns of *y* must be equal; i.e.,
        they must be as if generated by ``np.meshgrid(x_1d, y_1d)``.
    u, v : 2D arrays
        *x* and *y*-velocities. The number of rows and columns must match
        the length of *y* and *x*, respectively.
    density : float or (float, float)
        Controls the closeness of streamlines. When ``density = 1``, the domain
        is divided into a 30x30 grid. *density* linearly scales this grid.
        Each cell in the grid can have, at most, one traversing streamline.
        For different densities in each direction, use a tuple
        (density_x, density_y).
    linewidth : float or 2D array
        The width of the streamlines. With a 2D array the line width can be
        varied across the grid. The array must have the same shape as *u*
        and *v*.
    color : color or 2D array
        The streamline color. If given an array, its values are converted to
        colors using *cmap* and *norm*.  The array must have the same shape
        as *u* and *v*.
    cmap, norm
        Data normalization and colormapping parameters for *color*; only used
        if *color* is an array of floats. See `~.Axes.imshow` for a detailed
        description.
    arrowsize : float
        Scaling factor for the arrow size.
    arrowstyle : str
        Arrow style specification.
        See `~matplotlib.patches.FancyArrowPatch`.
    minlength : float
        Minimum length of streamline in axes coordinates.
    start_points : (N, 2) array
        Coordinates of starting points for the streamlines in data coordinates
        (the same coordinates as the *x* and *y* arrays).
    zorder : float
        The zorder of the streamlines and arrows.
        Artists with lower zorder values are drawn first.
    maxlength : float
        Maximum length of streamline in axes coordinates.
    integration_direction : {&#39;forward&#39;, &#39;backward&#39;, &#39;both&#39;}, default: &#39;both&#39;
        Integrate the streamline in forward, backward or both directions.
    data : indexable object, optional
        DATA_PARAMETER_PLACEHOLDER
    broken_streamlines : boolean, default: True
        If False, forces streamlines to continue until they
        leave the plot domain.  If True, they may be terminated if they
        come too close to another streamline.

    Returns
    -------
    StreamplotSet
        Container object with attributes
 
        - ``lines``: `.LineCollection` of streamlines

        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch`
          objects representing the arrows half-way along streamlines.

            This container will probably change in the future to allow changes
            to the colormap, alpha, etc. for both lines and arrows, but these
            changes should be backward compatible.
    &#34;&#34;&#34;
    grid = Grid(x, y)
    mask = StreamMask(10)
    dmap = DomainMap(grid, mask)

    if zorder is None:
        zorder = mlines.Line2D.zorder

    # default to data coordinates
    if transform is None:
        transform = axes.transData

    if color is None:
        color = axes._get_lines.get_next_color()

    if linewidth is None:
        linewidth = mpl.rcParams[&#39;lines.linewidth&#39;]

    line_kw = {}
    arrow_kw = dict(arrowstyle=arrowstyle, mutation_scale=10 * arrowsize)

    _api.check_in_list([&#39;both&#39;, &#39;forward&#39;, &#39;backward&#39;],
                       integration_direction=integration_direction)

    #if integration_direction == &#39;both&#39;: #done for magnitude
    #    maxlength /= 2.

    use_multicolor_lines = isinstance(color, np.ndarray)
    if use_multicolor_lines:
        if color.shape != grid.shape:
            raise ValueError(&#34;If &#39;color&#39; is given, it must match the shape of &#34;
                             &#34;the (x, y) grid&#34;)
        line_colors = [[]]  # Empty entry allows concatenation of zero arrays.
        color = np.ma.masked_invalid(color)
    else:
        line_kw[&#39;color&#39;] = color
        arrow_kw[&#39;color&#39;] = color

    if isinstance(linewidth, np.ndarray):
        if linewidth.shape != grid.shape:
            raise ValueError(&#34;If &#39;linewidth&#39; is given, it must match the &#34;
                             &#34;shape of the (x, y) grid&#34;)
        line_kw[&#39;linewidth&#39;] = []
    else:
        line_kw[&#39;linewidth&#39;] = linewidth
        arrow_kw[&#39;linewidth&#39;] = linewidth

    line_kw[&#39;zorder&#39;] = zorder
    arrow_kw[&#39;zorder&#39;] = zorder

    # Sanity checks.
    if u.shape != grid.shape or v.shape != grid.shape:
        raise ValueError(&#34;&#39;u&#39; and &#39;v&#39; must match the shape of the (x, y) grid&#34;)

    u = np.ma.masked_invalid(u)
    v = np.ma.masked_invalid(v)
    magnitude = np.sqrt(u**2 + v**2)
    magnitude/=np.max(magnitude)
    if integration_direction == &#39;both&#39;:
        magnitude /= 2.
        
    resolution = density/np.max(grains)
    integrate = _get_integrator(u, v, dmap, resolution, magnitude, integration_direction)

    trajectories = []    
   
    if start_points is None:
        start_points=_gen_starting_points(x,y,grains)
    
    sp2 = np.asanyarray(start_points, dtype=float).copy()

    # Check if start_points are outside the data boundaries
    for xs, ys in sp2:
        if not (grid.x_origin &lt;= xs &lt;= grid.x_origin + grid.width and
                grid.y_origin &lt;= ys &lt;= grid.y_origin + grid.height):
                raise ValueError(f&#34;Starting point ({xs}, {ys}) outside of &#34;
                                 &#34;data boundaries&#34;)

    # Convert start_points from data to array coords
    # Shift the seed points from the bottom left of the data so that
    # data2grid works properly.
    sp2[:, 0] -= grid.x_origin
    sp2[:, 1] -= grid.y_origin

    for xs, ys in sp2:
        xg, yg = dmap.data2grid(xs, ys)
        # Floating point issues can cause xg, yg to be slightly out of
        # bounds for xs, ys on the upper boundaries. Because we have
        # already checked that the starting points are within the original
        # grid, clip the xg, yg to the grid to work around this issue
        xg = np.clip(xg, 0, grid.nx - 1)
        yg = np.clip(yg, 0, grid.ny - 1)
        
        t = integrate(xg, yg, broken_streamlines)
        if t is not None:
            trajectories.append(t)

    if use_multicolor_lines:
        if norm is None:
            norm = mcolors.Normalize(color.min(), color.max())
        cmap = cm._ensure_cmap(cmap)

    streamlines = []
    arrows = []
    for t in trajectories:
        tgx, tgy = t.T
        # Rescale from grid-coordinates to data-coordinates.
        tx, ty = dmap.grid2data(tgx, tgy)
        tx += grid.x_origin
        ty += grid.y_origin

        # Create multiple tiny segments if varying width or color is given
        if isinstance(linewidth, np.ndarray) or use_multicolor_lines:
            points = np.transpose([tx, ty]).reshape(-1, 1, 2)
            streamlines.extend(np.hstack([points[:-1], points[1:]]))
        else:
            points = np.transpose([tx, ty])
            streamlines.append(points)

        # Add arrows halfway along each trajectory.
        s = np.cumsum(np.hypot(np.diff(tx), np.diff(ty)))
        n = np.searchsorted(s, s[-1])
        arrow_tail = (tx[n], ty[n])
        arrow_head = (np.mean(tx[n:n + 2]), np.mean(ty[n:n + 2]))

        if isinstance(linewidth, np.ndarray):
            line_widths = interpgrid(linewidth, tgx, tgy)[:-1]
            line_kw[&#39;linewidth&#39;].extend(line_widths)
            arrow_kw[&#39;linewidth&#39;] = line_widths[n]

        if use_multicolor_lines:
            color_values = interpgrid(color, tgx, tgy)[:-1]
            line_colors.append(color_values)
            arrow_kw[&#39;color&#39;] = cmap(norm(color_values[n]))

        p = patches.FancyArrowPatch(
            arrow_tail, arrow_head, transform=transform, **arrow_kw)
        arrows.append(p)
        
    lc = mcollections.LineCollection(
        streamlines, transform=transform, **line_kw)
    lc.sticky_edges.x[:] = [grid.x_origin, grid.x_origin + grid.width]
    lc.sticky_edges.y[:] = [grid.y_origin, grid.y_origin + grid.height]
    if use_multicolor_lines:
        lc.set_array(np.ma.hstack(line_colors))
        lc.set_cmap(cmap)
        lc.set_norm(norm)
    axes.add_collection(lc)

    ac = mcollections.PatchCollection(arrows)
    # Adding the collection itself is broken; see #2341.
    for p in arrows:
        axes.add_patch(p)

    axes.autoscale_view()
    stream_container = StreamplotSet(lc, ac)
    return stream_container</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools" href="index.html">dfm_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfm_tools.modplot.velovect" href="#dfm_tools.modplot.velovect">velovect</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>