<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dfm_tools.get_nc API documentation</title>
<meta name="description" content="dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.get_nc</code></h1>
</header>
<section id="section-intro">
<p>dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.
if not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<p>All names, logos, and references to "Deltares" are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.</p>
<p>INFORMATION
This script is part of dfm_tools: <a href="https://github.com/openearth/dfm_tools">https://github.com/openearth/dfm_tools</a>
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools</p>
<p>Created on Fri Feb 14 12:45:11 2020</p>
<p>@author: veenstra</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  if not, see &lt;http://www.gnu.org/licenses/&gt;.

All names, logos, and references to &#34;Deltares&#34; are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.


INFORMATION
This script is part of dfm_tools: https://github.com/openearth/dfm_tools
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools

Created on Fri Feb 14 12:45:11 2020

@author: veenstra
&#34;&#34;&#34;

import warnings
import numpy as np
import datetime as dt
import pandas as pd
import xugrid as xu
import xarray as xr
import matplotlib.pyplot as plt
from dfm_tools.xarray_helpers import get_vertical_dimensions


def get_ugrid_verts(data_xr_map): #TODO: remove this deprecated function
    &#34;&#34;&#34;
    getting ugrid verts from xugrid mapfile.
    &#34;&#34;&#34;
    raise DeprecationWarning(&#39;dfmt.get_ugrid_verts() is deprecated, use uds.grid.face_node_coordinates instead (https://github.com/Deltares/xugrid/issues/48)&#39;)
    
    # face_nos = data_xr_map.grid.face_node_connectivity
    
    # face_nnodecoords_x = data_xr_map.grid.node_x[face_nos]
    # face_nnodecoords_x[face_nos==-1] = np.nan
    # face_nnodecoords_y = data_xr_map.grid.node_y[face_nos]
    # face_nnodecoords_y[face_nos==-1] = np.nan
    
    # ugrid_all_verts = np.c_[face_nnodecoords_x[...,np.newaxis],face_nnodecoords_y[...,np.newaxis]]
    # return ugrid_all_verts


def calc_dist_pythagoras(x1,x2,y1,y2): # TODO: only used in dfm_tools.ugrid, remove?
    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance


def calc_dist_haversine(lon1,lon2,lat1,lat2): # TODO: only used in dfm_tools.ugrid, remove?
    &#34;&#34;&#34;
    calculates distance between lat/lon coordinates in meters
    https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128
    &#34;&#34;&#34;
    # convert to radians
    lon1_rad = np.deg2rad(lon1)
    lon2_rad = np.deg2rad(lon2)
    lat1_rad = np.deg2rad(lat1)
    lat2_rad = np.deg2rad(lat2)
    
    # apply formulae
    a = np.sin((lat2_rad-lat1_rad)/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin((lon2_rad-lon1_rad)/2)**2
    c = 2 * np.arctan2( np.sqrt(a), np.sqrt(1-a) )
    R = 6371000
    distance = R * c
    if np.isnan(distance).any():
        raise Exception(&#39;nan encountered in calc_dist_latlon distance, replaced by 0&#39;) #warnings.warn
        #distance[np.isnan(distance)] = 0
    return distance


def polygon_intersect(data_frommap_merged, line_array, calcdist_fromlatlon=None):
    #data_frommap_merged: xugrid dataset (contains ds and grid)
    #TODO: remove hardcoding
    &#34;&#34;&#34;
    #TODO: maybe move to meshkernel/xugrid functionality?
    Cross section functionality is implemented in MeshKernel (C++) but still needs to be exposed in MeshKernelPy (can be done in dec2022). Here is the function with documentation: 
    https://github.com/Deltares/MeshKernel/blob/067f1493e7f972ba0cdb2a1f4deb48d1c74695d5/include/MeshKernelApi/MeshKernel.hpp#L356
    &#34;&#34;&#34;
    
    import numpy as np
    #from matplotlib.path import Path
    import shapely #separate import, since sometimes this works, while import shapely.geometry fails
    from shapely.geometry import LineString, Polygon, MultiLineString, Point
    from dfm_tools.get_nc import calc_dist_pythagoras, calc_dist_haversine

    if calcdist_fromlatlon is None:
        #auto determine if cartesian/sperical
        if hasattr(data_frommap_merged.ugrid.obj,&#39;projected_coordinate_system&#39;):
            calcdist_fromlatlon = False
        elif hasattr(data_frommap_merged.ugrid.obj,&#39;wgs84&#39;):
            calcdist_fromlatlon = True
        else:
            raise Exception(&#39;To auto determine calcdist_fromlatlon, a variable &#34;projected_coordinate_system&#34; or &#34;wgs84&#34; is required, please provide calcdist_fromlatlon=True/False yourself.&#39;)

    dtstart_all = dt.datetime.now()

    #defining celinlinebox
    line_section = LineString(line_array)
    
    ugrid_all_verts = data_frommap_merged.grid.face_node_coordinates
    verts_xmax = np.nanmax(ugrid_all_verts[:,:,0].data,axis=1)
    verts_xmin = np.nanmin(ugrid_all_verts[:,:,0].data,axis=1)
    verts_ymax = np.nanmax(ugrid_all_verts[:,:,1].data,axis=1)
    verts_ymin = np.nanmin(ugrid_all_verts[:,:,1].data,axis=1)
    
    #TODO: replace this with xr.sel() once it works for xugrid (getting verts_inlinebox_nos is than still an issue)
    cellinlinebox_all_bool = (((np.min(line_array[:,0]) &lt;= verts_xmax) &amp;
                               (np.max(line_array[:,0]) &gt;= verts_xmin)) &amp;
                              ((np.min(line_array[:,1]) &lt;= verts_ymax) &amp; 
                               (np.max(line_array[:,1]) &gt;= verts_ymin))
                              )
    #cellinlinebox_all_bool[:] = 1 #to force all cells to be taken into account
    
    intersect_coords = np.empty((0,4))
    intersect_gridnos = np.empty((0),dtype=int) #has to be numbers, since a boolean is differently ordered
    verts_inlinebox = ugrid_all_verts[cellinlinebox_all_bool,:,:]
    verts_inlinebox_nos = np.where(cellinlinebox_all_bool)[0]

    
    print(f&#39;&gt;&gt; finding crossing flow links (can take a while, processing {cellinlinebox_all_bool.sum()} of {len(cellinlinebox_all_bool)} cells): &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    for iP, pol_data in enumerate(verts_inlinebox):
        pol_shp = Polygon(pol_data[~np.isnan(pol_data).all(axis=1)])
        intersect_result = pol_shp.intersection(line_section)
        if isinstance(intersect_result,shapely.geometry.multilinestring.MultiLineString): #in the rare case that a cell (pol_shp) is crossed by multiple parts of the line
            intersect_result_multi = intersect_result
        elif isinstance(intersect_result,shapely.geometry.linestring.LineString): #if one linepart trough cell (ex/including node), make multilinestring anyway
            if intersect_result.coords == []: #when the line does not cross this cell, intersect_results.coords is an empty linestring and this cell can be skipped (continue makes forloop continue with next in line without finishing the rest of the steps for this instance)
                continue
            elif len(intersect_result.coords.xy[0]) == 0: #for newer cartopy versions, when line does not cross this cell, intersect_result.coords.xy is (array(&#39;d&#39;), array(&#39;d&#39;)), and both arrays in tuple have len 0.
                continue
            intersect_result_multi = MultiLineString([intersect_result])
        for iLL, intesect_result_one in enumerate(intersect_result_multi.geoms): #loop over multilinestrings, will mostly only contain one linestring. Will be two if the line crosses a cell more than once.
            intersection_line = intesect_result_one.coords
            intline_xyshape = np.array(intersection_line.xy).shape
            #print(&#39;len(intersection_line.xy): %s&#39;%([intline_xyshape]))
            for numlinepart_incell in range(1,intline_xyshape[1]): #is mostly 1, but more if there is a linebreakpoint in this cell (then there are two or more lineparts)
                intersect_gridnos = np.append(intersect_gridnos,verts_inlinebox_nos[iP])
                #intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy)[np.newaxis,:,numlinepart_incell-1:numlinepart_incell+1]],axis=0)
                intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy).T[numlinepart_incell-1:numlinepart_incell+1].flatten()[np.newaxis]])
    
    if intersect_coords.shape[0] != len(intersect_gridnos):
        raise Exception(&#39;something went wrong, intersect_coords.shape[0] and len(intersect_gridnos) are not equal&#39;)
    
    intersect_pd = pd.DataFrame(intersect_coords,index=intersect_gridnos,columns=[&#39;x1&#39;,&#39;y1&#39;,&#39;x2&#39;,&#39;y2&#39;])
    intersect_pd.index.name = &#39;gridnumber&#39;
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
            
    
    #calculating distance for all crossed cells, from first point of line
    nlinecoords = line_array.shape[0]
    nlinedims = len(line_array.shape)
    ncrosscellparts = len(intersect_pd)
    if nlinecoords&lt;2 or nlinedims != 2:
        raise Exception(&#39;ERROR: line_array should at least contain two xy points [[x,y],[x,y]]&#39;)
    
    #calculate distance between celledge-linepart crossing (is zero when line iL crosses cell)
    distperline_tostart = np.zeros((ncrosscellparts,nlinecoords-1))
    distperline_tostop = np.zeros((ncrosscellparts,nlinecoords-1))
    linepart_length = np.zeros((nlinecoords))
    for iL in range(nlinecoords-1):
        #calculate length of lineparts
        line_section_part = LineString(line_array[iL:iL+2,:])
        if calcdist_fromlatlon:
            linepart_length[iL+1] = calc_dist_haversine(line_array[iL,0],line_array[iL+1,0],line_array[iL,1],line_array[iL+1,1])
        else:
            linepart_length[iL+1] = line_section_part.length
    
        #get distance between all lineparts and point (later used to calculate distance from beginpoint of closest linepart)
        for iP in range(ncrosscellparts):
            distperline_tostart[iP,iL] = line_section_part.distance(Point(intersect_coords[:,0][iP],intersect_coords[:,1][iP]))
            distperline_tostop[iP,iL] = line_section_part.distance(Point(intersect_coords[:,2][iP],intersect_coords[:,3][iP]))
    linepart_lengthcum = np.cumsum(linepart_length)
    cross_points_closestlineid = np.argmin(np.maximum(distperline_tostart,distperline_tostop),axis=1)
    intersect_pd[&#39;closestlineid&#39;] = cross_points_closestlineid
    
    
    if not calcdist_fromlatlon:
        crs_dist_starts = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    else:
        crs_dist_starts = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    intersect_pd[&#39;crs_dist_starts&#39;] = crs_dist_starts
    intersect_pd[&#39;crs_dist_stops&#39;] = crs_dist_stops
    intersect_pd[&#39;linepartlen&#39;] = crs_dist_stops-crs_dist_starts
    intersect_pd = intersect_pd.sort_values(&#39;crs_dist_starts&#39;)
    
    print(f&#39;&gt;&gt; polygon_intersect() total, found intersection trough {len(intersect_gridnos)} of {len(cellinlinebox_all_bool)} cells: {(dt.datetime.now()-dtstart_all).total_seconds():.2f} sec&#39;)
    return intersect_pd


def get_xzcoords_onintersection(data_frommap_merged, intersect_pd, timestep=None):
    #TODO: remove hardcoding of variable names
    if timestep is None: #TODO: maybe make time dependent grid?
        raise Exception(&#39;ERROR: argument timestep not provided, this is necessary to retrieve correct waterlevel or fullgrid output&#39;)
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_frommap_merged)
    if dimn_layer is not None:
        nlay = data_frommap_merged.dims[dimn_layer]
    else: #no layers, 2D model
        nlay = 1

    xu_facedim = data_frommap_merged.grid.face_dimension
    xu_edgedim = data_frommap_merged.grid.edge_dimension
    xu_nodedim = data_frommap_merged.grid.node_dimension
        
    #potentially construct fullgrid info (zcc/zw) #TODO: this ifloop is copied from get_mapdata_atdepth(), prevent this duplicate code
    if dimn_layer not in data_frommap_merged.dims: #2D model
        print(&#39;depth dimension not found, probably 2D model&#39;)
        pass
    elif &#39;mesh2d_flowelem_zw&#39; in data_frommap_merged.variables: #fullgrid info already available, so continuing
        print(&#39;zw/zcc (fullgrid) values already present in Dataset&#39;)
        pass
    elif &#39;mesh2d_layer_sigma&#39; in data_frommap_merged.variables: #reconstruct_zw_zcc_fromsigma and treat as zsigma/fullgrid mapfile from here
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_frommap_merged = reconstruct_zw_zcc_fromsigma(data_frommap_merged)
    elif &#39;mesh2d_layer_z&#39; in data_frommap_merged.variables:        
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_frommap_merged = reconstruct_zw_zcc_fromz(data_frommap_merged)
    else:
        raise Exception(&#39;layers present, but unknown layertype, expected one of variables: mesh2d_flowelem_zw, mesh2d_layer_sigma, mesh2d_layer_z&#39;)
    
    intersect_gridnos = intersect_pd.index
    data_frommap_merged_sel = data_frommap_merged.ugrid.obj.drop_dims([xu_edgedim,xu_nodedim]).isel(time=timestep).isel({xu_facedim:intersect_gridnos}) #TODO: not possible to do isel with non-sorted gridnos on ugridDataset, but it is on xrDataset. Dropping edge/nodedims first for neatness, so there is not mismatch in face/node/edge after using .isel(faces)
    if dimn_layer not in data_frommap_merged_sel.dims:
        data_frommap_wl3_sel = data_frommap_merged_sel[&#39;mesh2d_s1&#39;].to_numpy()
        data_frommap_bl_sel = data_frommap_merged_sel[&#39;mesh2d_flowelem_bl&#39;].to_numpy()
        zvals_interface = np.linspace(data_frommap_bl_sel,data_frommap_wl3_sel,nlay+1)
    elif &#39;mesh2d_flowelem_zw&#39; in data_frommap_merged_sel.variables:
        zvals_interface_filled = data_frommap_merged_sel[&#39;mesh2d_flowelem_zw&#39;].bfill(dim=dimn_interfaces) #fill nan values (below bed) with equal values
        zvals_interface = zvals_interface_filled.to_numpy().T # transpose to make in line with 2D sigma dataset
    
    #convert to output for plot_netmapdata
    crs_dist_starts_matrix = np.repeat(intersect_pd[&#39;crs_dist_starts&#39;].values[np.newaxis],nlay,axis=0)
    crs_dist_stops_matrix = np.repeat(intersect_pd[&#39;crs_dist_stops&#39;].values[np.newaxis],nlay,axis=0)
    crs_verts_x_all = np.array([[crs_dist_starts_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_starts_matrix.ravel()]]).T
    crs_verts_z_all = np.ma.array([zvals_interface[1:,:].ravel(),zvals_interface[1:,:].ravel(),zvals_interface[:-1,:].ravel(),zvals_interface[:-1,:].ravel()]).T[:,:,np.newaxis]
    crs_verts = np.ma.concatenate([crs_verts_x_all, crs_verts_z_all], axis=2)
    
    #define grid
    shape_crs_grid = crs_verts[:,:,0].shape
    shape_crs_flat = crs_verts[:,:,0].ravel().shape
    xr_crs_grid = xu.Ugrid2d(node_x=crs_verts[:,:,0].ravel(),
                             node_y=crs_verts[:,:,1].ravel(),
                             fill_value=-1,
                             face_node_connectivity=np.arange(shape_crs_flat[0]).reshape(shape_crs_grid),
                             )

    #define dataset
    crs_plotdata_clean = data_frommap_merged_sel
    if dimn_layer in data_frommap_merged_sel.dims:
        facedim_tempname = &#39;facedim_tempname&#39; #temporary new name to avoid duplicate from-to dimension name in .stack()
        crs_plotdata_clean = crs_plotdata_clean.rename({xu_facedim:facedim_tempname})
        crs_plotdata_clean = crs_plotdata_clean.stack({xr_crs_grid.face_dimension:[dimn_layer,facedim_tempname]})
        #reset_index converts face-dimension from multiindex to flat
        crs_plotdata_clean = crs_plotdata_clean.reset_index([xr_crs_grid.face_dimension])
    
    #combine into xugrid
    xr_crs_ugrid = xu.UgridDataset(crs_plotdata_clean, grids=[xr_crs_grid])
    return xr_crs_ugrid


def polyline_mapslice(data_frommap_merged, line_array, timestep, calcdist_fromlatlon=None): #TODO: merge this into one function
    #intersect function, find crossed cell numbers (gridnos) and coordinates of intersection (2 per crossed cell)
    intersect_pd = polygon_intersect(data_frommap_merged, line_array, calcdist_fromlatlon=calcdist_fromlatlon)
    if len(intersect_pd) == 0:
        raise Exception(&#39;line_array does not cross mapdata&#39;) #TODO: move exception elsewhere?
    #derive vertices from cross section (distance from first point)
    xr_crs_ugrid = get_xzcoords_onintersection(data_frommap_merged, intersect_pd=intersect_pd, timestep=timestep)
    return xr_crs_ugrid


def reconstruct_zw_zcc_fromsigma(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value
    &#34;&#34;&#34;
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_percentage = data_xr_map[&#39;mesh2d_layer_sigma&#39;]
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = data_frommap_wl_sel+(data_frommap_wl_sel-data_frommap_bl_sel)*zvals_cen_percentage
    
    zvals_interface_percentage = data_xr_map[&#39;mesh2d_interface_sigma&#39;]
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_frommap_wl_sel+(data_frommap_wl_sel-data_frommap_bl_sel)*zvals_interface_percentage
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map


def reconstruct_zw_zcc_fromz(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel
    #TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel
    #TODO: remove hardcoding of varnames
    &#34;&#34;&#34;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr_map)
    
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_z0_sel = data_frommap_wl_sel*0
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_zval = data_xr_map[&#39;mesh2d_layer_z&#39;] #no clipping for zcenter values, since otherwise interp will fail
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = (data_frommap_z0_sel+zvals_cen_zval)

    zvals_interface_zval = data_xr_map[&#39;mesh2d_interface_z&#39;] #clipping for zinterface values, to make sure layer interfaces are also at water/bed level
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = (data_frommap_z0_sel+zvals_interface_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)
    bool_notoplayer_int = zvals_interface_zval&lt;zvals_interface_zval.isel({dimn_interfaces:-1})
    bool_int_abovewl = zvals_interface_zval&gt;data_frommap_wl_sel
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_xr_map[&#39;mesh2d_flowelem_zw&#39;].where(bool_notoplayer_int | bool_int_abovewl, other=data_frommap_wl_sel) #zvalues of top layer_interfaces that are lower than wl are replaced by wl
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map


def get_Dataset_atdepths(data_xr, depths, reference=&#39;z0&#39;, zlayer_z0_selnearest=False):
    &#34;&#34;&#34;
    data_xr_map:
        has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
        in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy
    depths:
        int/float or list/array of int/float. Depths w.r.t. reference level. If reference==&#39;waterlevel&#39;, depth&gt;0 returns only nans. If reference==&#39;bedlevel&#39;, depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.
    reference:
        compute depth w.r.t. z0/waterlevel/bed
        default: reference=&#39;z0&#39;
    zlayer_z0_interp:
        Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference=&#39;z&#39; (not &#39;waterlevel&#39; or &#39;bedlevel&#39;). Only used if &#34;mesh2d_layer_z&#34; is present (zlayer model)
        This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.
    
    #TODO: zmodel gets depth in figure title, because of .set_index() in open_partitioned_dataset(). Sigmamodel gets percentage/fraction in title. &gt;&gt; set_index was removed there, so check again.
    #TODO: check if attributes should be passed/altered
    #TODO: build in check whether layers/interfaces are coherent (len(int)=len(lay)+1), since one could also supply a uds.isel(layer=range(10)) where there are still 51 interfaces. (if not, raise error to remove layer selection)
    #TODO: also waterlevelvar in 3D model gets depth_fromref coordinate, would be nice to avoid.
    #TODO: clean up unneccesary variables (like pre-interp depth values and interface dim)
    &#34;&#34;&#34;
    
    depth_varname = &#39;depth_fromref&#39;
    
    try:
        dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr)
    except: #TODO: catch nicely
        dimn_layer = dimn_interfaces = None
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = data_xr.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
        dimname_layc = dimn_layer
        dimname_layw = dimn_interfaces
        varname_wl = f&#39;{gridname}_s1&#39;
        varname_bl = f&#39;{gridname}_flowelem_bl&#39;
    elif &#39;laydim&#39; in data_xr.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
        dimname_layc = &#39;laydim&#39;
        dimname_layw = &#39;laydimw&#39;
        varname_wl = &#39;waterlevel&#39;
        varname_bl = &#39;bedlevel&#39;
        warnings.warn(UserWarning(&#39;get_Dataset_atdepths() is not tested for hisfiles yet, please check your results.&#39;))
    else:
        print(&#39;WARNING: depth dimension not found, probably 2D model, returning input Dataset&#39;)
        return data_xr #early return
    
    if not isinstance(data_xr,(xr.Dataset,xu.UgridDataset)):
        raise Exception(f&#39;data_xr_map should be of type xr.Dataset, but is {type(data_xr)}&#39;)
    
    #create depth xr.DataArray
    if isinstance(depths,(float,int)):
        #depths = depths #float/int
        depth_dims = ()
    else:
        depths = np.unique(depths) #array of unique+sorted floats/ints
        depth_dims = (depth_varname)
    depths_xr = xr.DataArray(depths,dims=depth_dims,attrs={&#39;units&#39;:&#39;m&#39;,
                                                           &#39;reference&#39;:f&#39;model_{reference}&#39;,
                                                           &#39;positive&#39;:&#39;up&#39;}) #TODO: make more in line with CMEMS etc
    
    #simplified/faster method for zlayer icm z0 reference (mapfiles only) #TODO: maybe remove this part of the code to make it better maintainable.
    if &#39;mesh2d_layer_z&#39; in data_xr.variables and zlayer_z0_selnearest and reference==&#39;z0&#39;: # selects nearest z-center values (instead of slicing), should be faster #TODO: check if this is faster than fullgrid
        print(&#39;z-layer model, zlayer_z0_selnearest=True and reference==&#34;z0&#34; so using xr.sel(method=&#34;nearest&#34;)]&#39;)
        warnings.warn(DeprecationWarning(&#39;The get_Dataset_atdepths() keyword zlayer_z0_selnearest might be phased out.&#39;))
        data_xr = data_xr.set_index({dimn_layer:&#39;mesh2d_layer_z&#39;})#.rename({&#39;nmesh2d_layer&#39;:depth_varname}) #set depth as index on layers, to be able to interp to depths instead of layernumbers
        data_xr[depth_varname] = depths_xr
        data_xr_atdepths = data_xr.sel({dimn_layer:depths_xr},method=&#39;nearest&#39;)
        data_wl = data_xr[varname_wl]
        data_bl = data_xr[varname_bl]
        data_xr_atdepths = data_xr_atdepths.where((depths_xr&gt;=data_bl) &amp; (depths_xr&lt;=data_wl)) #filter above wl and below bl values
        return data_xr_atdepths #early return
    
    #potentially construct fullgrid info (zcc/zw) #TODO: maybe move to separate function, like open_partitioned_dataset() (although bl/wl are needed anyway)
    if varname_zint in data_xr.variables: #fullgrid info already available, so continuing
        print(f&#39;zw/zcc (fullgrid) values already present in Dataset in variable {varname_zint}&#39;)
        pass
    elif &#39;mesh2d_layer_sigma&#39; in data_xr.variables: #reconstruct_zw_zcc_fromsigma and treat as zsigma/fullgrid mapfile from here
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_xr = reconstruct_zw_zcc_fromsigma(data_xr)
    elif &#39;mesh2d_layer_z&#39; in data_xr.variables:
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_xr = reconstruct_zw_zcc_fromz(data_xr)
    else:
        raise Exception(&#39;layers present, but unknown layertype/var&#39;)
    
    #correct reference level
    if reference==&#39;z0&#39;:
        zw_reference = data_xr[varname_zint]
    elif reference==&#39;waterlevel&#39;:
        data_wl = data_xr[varname_wl]
        zw_reference = data_xr[varname_zint] - data_wl
    elif reference==&#39;bedlevel&#39;:
        data_bl = data_xr[varname_bl]
        zw_reference = data_xr[varname_zint] - data_bl
    else:
        raise Exception(f&#39;unknown reference &#34;{reference}&#34; (possible are z0, waterlevel and bedlevel&#39;)
    
    print(&#39;&gt;&gt; subsetting data on fixed depth in fullgrid z-data: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
        
    if &#39;time&#39; in data_xr.dims: #TODO: suppress this warning for hisfiles since it does not make sense
        warnings.warn(UserWarning(&#39;get_mapdata_onfixedepth() can be very slow when supplying dataset with time dimension, you could supply ds.isel(time=timestep) instead&#39;))
        
    #get layerno via z-interface value (zw), check which celltop-interfaces are above/on depth and which which cellbottom-interfaces are below/on depth
    bool_topinterface_abovedepth = zw_reference.isel({dimname_layw:slice(1,None)}) &gt;= depths_xr
    bool_botinterface_belowdepth = zw_reference.isel({dimname_layw:slice(None,-1)}) &lt;= depths_xr
    bool_topbotinterface_arounddepth = bool_topinterface_abovedepth &amp; bool_botinterface_belowdepth #this bool also automatically excludes all values below bed and above wl
    bool_topbotinterface_arounddepth = bool_topbotinterface_arounddepth.rename({dimname_layw:dimname_layc}) #correct dimname for interfaces to centers
    data_xr_atdepths = data_xr.where(bool_topbotinterface_arounddepth).max(dim=dimname_layc,keep_attrs=True) #set all layers but one to nan, followed by an arbitrary reduce (max in this case)
    #TODO: suppress/solve warning for DCSM (does not happen when supplying data_xr_map[[&#39;mesh2d_sa1&#39;,&#39;mesh2d_s1&#39;,&#39;mesh2d_flowelem_bl&#39;,&#39;mesh2d_flowelem_zw&#39;]]): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\core.py:4806: PerformanceWarning: Increasing number of chunks by factor of 20&#34; &gt;&gt; still happens with new xugrid method?
    #TODO: suppress warning (upon plotting/load/etc): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\reductions.py:640: RuntimeWarning: All-NaN slice encountered&#34;
    
    #add depth as coordinate var
    data_xr_atdepths[depth_varname] = depths_xr
    data_xr_atdepths = data_xr_atdepths.set_coords([depth_varname])
    
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return data_xr_atdepths


def plot_background(ax=None, projection=None, google_style=&#39;satellite&#39;, resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs):
    &#34;&#34;&#34;
    this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
    import contextily as ctx
    fig, ax = plt.subplots(1,1)
    ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs=&#34;EPSG:28992&#34;)
    More info at: https://contextily.readthedocs.io/en/latest/reference.html

    Parameters
    ----------
    ax : cartopy.mpl.geoaxes.GeoAxesSubplot, optional
        DESCRIPTION. The default is None.
    projection : integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection, optional
        DESCRIPTION. The default is None.
    google_style : Nonetype or string, optional
       The style of the Google Maps tiles. One of None, â€˜streetâ€™, â€˜satelliteâ€™, â€˜terrainâ€™, and â€˜only_streetsâ€™. The default is &#39;satellite&#39;.
    resolution : int, optional
        resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.
    features : string, optional
        Features to plot, options: None, &#39;ocean&#39;, &#39;rivers&#39;, &#39;land&#39;, &#39;countries&#39;, &#39;countries_highres&#39;, &#39;coastlines&#39;, &#39;coastlines_highres&#39;. The default is None.
    nticks : TYPE, optional
        DESCRIPTION. The default is 6.
    latlon_format : bool, optional
        DESCRIPTION. The default is False.
    gridlines : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor=&#39;none&#39;, edgecolor=&#39;gray&#39;, linewidth=0.5, linestyle=&#39;:&#39;

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ax : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    import cartopy
    import cartopy.crs as ccrs
    import cartopy.io.img_tiles as cimgt
    import cartopy.feature as cfeature
    import cartopy.mpl.ticker as cticker

    dummy = ccrs.epsg(28992) #to make cartopy realize it has a cartopy._epsg._EPSGProjection class (maybe gets fixed with cartopy updates, see unittest test_cartopy_epsg)
    if ax is None: #provide axis projection on initialisation, cannot be edited later on
        if projection is None:
            projection=ccrs.PlateCarree() #projection of cimgt.GoogleTiles, useful default
        elif isinstance(projection, (cartopy._epsg._EPSGProjection, cartopy.crs.CRS)): #checks if argument is an EPSG projection or CRS projection (like PlateCarree, Mercator etc). Note: it was cartopy._crs.CRS before instead of cartopy.crs.CRS
            pass
        elif type(projection) is int:
            projection = ccrs.epsg(projection)
        else:
            raise Exception(&#39;argument projection should be of type integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection&#39;)
        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: projection})
        #ax = plt.axes(projection=projection)
    elif type(ax) is cartopy.mpl.geoaxes.GeoAxesSubplot:
        if projection is not None:
            print(&#39;arguments ax and projection are both provided, the projection from the ax is used so the projection argument is ignored&#39;)
    else:
        raise Exception(&#39;argument ax should be of type cartopy.mpl.geoaxes.GeoAxesSubplot, leave argument empty or create correct instance with:\nimport cartopy.crs as ccrs\nfig, (ax1,ax2) = plt.subplots(1,2,figsize=(10,5), subplot_kw={&#34;projection&#34;: ccrs.epsg(28992)})&#39;)



    if gridlines:
        ax.gridlines(draw_labels=True)
    elif nticks is not None: #only look at nticks if gridlines are not used
        extent = ax.get_extent()
        ax.set_xticks(np.linspace(extent[0],extent[1],nticks))
        ax.set_yticks(np.linspace(extent[2],extent[3],nticks))


    if google_style is not None:
        request = cimgt.GoogleTiles(style=google_style)
        ax.add_image(request,resolution)


    if features is not None:
        if type(features) is str:
            features = [features]
        elif type(features) is not list:
            raise Exception(&#39;argument features should be of type list of str&#39;)

        valid_featurelist = [&#39;ocean&#39;,&#39;rivers&#39;,&#39;land&#39;,&#39;countries&#39;,&#39;countries_highres&#39;,&#39;coastlines&#39;,&#39;coastlines_highres&#39;]
        invalid_featurelist = [x for x in features if x not in valid_featurelist]
        if invalid_featurelist != []:
            raise Exception(&#39;invalid features %s requested, possible are: %s&#39;%(invalid_featurelist, valid_featurelist))

        if &#39;ocean&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;ocean&#39;, facecolor=cfeature.COLORS[&#39;water&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.OCEAN, **kwargs)
        if &#39;rivers&#39; in features:
            ax.add_feature(cfeature.RIVERS, **kwargs)
        if &#39;land&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;land&#39;, facecolor=cfeature.COLORS[&#39;land&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.LAND, **kwargs)
        if &#39;countries&#39; in features:
            ax.add_feature(cfeature.BORDERS, **kwargs)
        if &#39;countries_highres&#39; in features:
            feat = cfeature.NaturalEarthFeature(category=&#39;cultural&#39;, name=&#39;admin_0_countries&#39;, scale=&#39;10m&#39;)
            ax.add_feature(feat, **kwargs)
        if &#39;coastlines&#39; in features:
            ax.add_feature(cfeature.COASTLINE, **kwargs)
        if &#39;coastlines_highres&#39; in features:
            ax.coastlines(resolution=&#39;10m&#39;, **kwargs)

    if latlon_format:
        lon_formatter = cticker.LongitudeFormatter()
        lat_formatter = cticker.LatitudeFormatter()
        ax.xaxis.set_major_formatter(lon_formatter)
        ax.yaxis.set_major_formatter(lat_formatter)


    return ax


def plot_ztdata(data_xr_sel, varname, ax=None, only_contour=False, get_ds=False, **kwargs):
    &#34;&#34;&#34;
    

    Parameters
    ----------
    data_xr : TYPE
        DESCRIPTION.
    varname : TYPE
        DESCRIPTION.
    ax : matplotlib.axes._subplots.AxesSubplot, optional
        the figure axis. The default is None.
    only_contour : bool, optional
        Wheter to plot contour lines of the dataset. The default is False.
    **kwargs : TYPE
        properties to give on to the pcolormesh function.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    pc : matplotlib.collections.QuadMesh
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    if not ax: ax=plt.gca()
    
    if len(data_xr_sel[varname].shape) != 2:
        raise Exception(f&#39;ERROR: unexpected number of dimensions in requested squeezed variable ({data_xr_sel[varname].shape}), first use data_xr.isel(stations=int) to select a single station&#39;) #TODO: can also have a different cause, improve message/testing?
    
    #repair zvalues at wl/wl (filling nans and clipping to wl/bl). bfill replaces nan values with last valid value, this is necessary to enable pcolormesh to work. clip forces data to be within bl/wl
    #TODO: put clip in preproces_hisnc to make plotting easier?
    data_xr_sel[&#39;zcoordinate_c&#39;] = data_xr_sel[&#39;zcoordinate_c&#39;].bfill(dim=&#39;laydim&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    data_xr_sel[&#39;zcoordinate_w&#39;] = data_xr_sel[&#39;zcoordinate_w&#39;].bfill(dim=&#39;laydimw&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    
    # generate 2 2d grids for the x &amp; y bounds (you can also give one 2D array as input in case of eg time varying z coordinates)
    data_fromhis_zcor = data_xr_sel[&#39;zcoordinate_w&#39;].to_numpy() 
    data_fromhis_zcor = np.concatenate([data_fromhis_zcor,data_fromhis_zcor[[-1],:]],axis=0)
    time_np = data_xr_sel.time.to_numpy()
    time_cor = np.concatenate([time_np,time_np[[-1]]])
    time_mesh_cor = np.tile(time_cor,(data_fromhis_zcor.shape[-1],1)).T
    if only_contour:
        pc = data_xr_sel[varname].plot.contour(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_c&#39;, **kwargs)
    else:
        #pc = data_xr_sel[varname].plot.pcolormesh(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_w&#39;, **kwargs) #is not possible to put center values on interfaces, som more difficult approach needed
        pc = ax.pcolormesh(time_mesh_cor, data_fromhis_zcor, data_xr_sel[varname], **kwargs)
   
    return pc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.get_nc.get_ugrid_verts"><code class="name flex">
<span>def <span class="ident">get_ugrid_verts</span></span>(<span>data_xr_map)</span>
</code></dt>
<dd>
<div class="desc"><p>getting ugrid verts from xugrid mapfile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ugrid_verts(data_xr_map): #TODO: remove this deprecated function
    &#34;&#34;&#34;
    getting ugrid verts from xugrid mapfile.
    &#34;&#34;&#34;
    raise DeprecationWarning(&#39;dfmt.get_ugrid_verts() is deprecated, use uds.grid.face_node_coordinates instead (https://github.com/Deltares/xugrid/issues/48)&#39;)
    
    # face_nos = data_xr_map.grid.face_node_connectivity
    
    # face_nnodecoords_x = data_xr_map.grid.node_x[face_nos]
    # face_nnodecoords_x[face_nos==-1] = np.nan
    # face_nnodecoords_y = data_xr_map.grid.node_y[face_nos]
    # face_nnodecoords_y[face_nos==-1] = np.nan
    
    # ugrid_all_verts = np.c_[face_nnodecoords_x[...,np.newaxis],face_nnodecoords_y[...,np.newaxis]]
    # return ugrid_all_verts</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.calc_dist_pythagoras"><code class="name flex">
<span>def <span class="ident">calc_dist_pythagoras</span></span>(<span>x1, x2, y1, y2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dist_pythagoras(x1,x2,y1,y2): # TODO: only used in dfm_tools.ugrid, remove?
    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.calc_dist_haversine"><code class="name flex">
<span>def <span class="ident">calc_dist_haversine</span></span>(<span>lon1, lon2, lat1, lat2)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates distance between lat/lon coordinates in meters
<a href="https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128">https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dist_haversine(lon1,lon2,lat1,lat2): # TODO: only used in dfm_tools.ugrid, remove?
    &#34;&#34;&#34;
    calculates distance between lat/lon coordinates in meters
    https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128
    &#34;&#34;&#34;
    # convert to radians
    lon1_rad = np.deg2rad(lon1)
    lon2_rad = np.deg2rad(lon2)
    lat1_rad = np.deg2rad(lat1)
    lat2_rad = np.deg2rad(lat2)
    
    # apply formulae
    a = np.sin((lat2_rad-lat1_rad)/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin((lon2_rad-lon1_rad)/2)**2
    c = 2 * np.arctan2( np.sqrt(a), np.sqrt(1-a) )
    R = 6371000
    distance = R * c
    if np.isnan(distance).any():
        raise Exception(&#39;nan encountered in calc_dist_latlon distance, replaced by 0&#39;) #warnings.warn
        #distance[np.isnan(distance)] = 0
    return distance</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.polygon_intersect"><code class="name flex">
<span>def <span class="ident">polygon_intersect</span></span>(<span>data_frommap_merged, line_array, calcdist_fromlatlon=None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="todo-maybe-move-to-meshkernelxugrid-functionality">TODO: maybe move to meshkernel/xugrid functionality?</h1>
<p>Cross section functionality is implemented in MeshKernel (C++) but still needs to be exposed in MeshKernelPy (can be done in dec2022). Here is the function with documentation:
<a href="https://github.com/Deltares/MeshKernel/blob/067f1493e7f972ba0cdb2a1f4deb48d1c74695d5/include/MeshKernelApi/MeshKernel.hpp#L356">https://github.com/Deltares/MeshKernel/blob/067f1493e7f972ba0cdb2a1f4deb48d1c74695d5/include/MeshKernelApi/MeshKernel.hpp#L356</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_intersect(data_frommap_merged, line_array, calcdist_fromlatlon=None):
    #data_frommap_merged: xugrid dataset (contains ds and grid)
    #TODO: remove hardcoding
    &#34;&#34;&#34;
    #TODO: maybe move to meshkernel/xugrid functionality?
    Cross section functionality is implemented in MeshKernel (C++) but still needs to be exposed in MeshKernelPy (can be done in dec2022). Here is the function with documentation: 
    https://github.com/Deltares/MeshKernel/blob/067f1493e7f972ba0cdb2a1f4deb48d1c74695d5/include/MeshKernelApi/MeshKernel.hpp#L356
    &#34;&#34;&#34;
    
    import numpy as np
    #from matplotlib.path import Path
    import shapely #separate import, since sometimes this works, while import shapely.geometry fails
    from shapely.geometry import LineString, Polygon, MultiLineString, Point
    from dfm_tools.get_nc import calc_dist_pythagoras, calc_dist_haversine

    if calcdist_fromlatlon is None:
        #auto determine if cartesian/sperical
        if hasattr(data_frommap_merged.ugrid.obj,&#39;projected_coordinate_system&#39;):
            calcdist_fromlatlon = False
        elif hasattr(data_frommap_merged.ugrid.obj,&#39;wgs84&#39;):
            calcdist_fromlatlon = True
        else:
            raise Exception(&#39;To auto determine calcdist_fromlatlon, a variable &#34;projected_coordinate_system&#34; or &#34;wgs84&#34; is required, please provide calcdist_fromlatlon=True/False yourself.&#39;)

    dtstart_all = dt.datetime.now()

    #defining celinlinebox
    line_section = LineString(line_array)
    
    ugrid_all_verts = data_frommap_merged.grid.face_node_coordinates
    verts_xmax = np.nanmax(ugrid_all_verts[:,:,0].data,axis=1)
    verts_xmin = np.nanmin(ugrid_all_verts[:,:,0].data,axis=1)
    verts_ymax = np.nanmax(ugrid_all_verts[:,:,1].data,axis=1)
    verts_ymin = np.nanmin(ugrid_all_verts[:,:,1].data,axis=1)
    
    #TODO: replace this with xr.sel() once it works for xugrid (getting verts_inlinebox_nos is than still an issue)
    cellinlinebox_all_bool = (((np.min(line_array[:,0]) &lt;= verts_xmax) &amp;
                               (np.max(line_array[:,0]) &gt;= verts_xmin)) &amp;
                              ((np.min(line_array[:,1]) &lt;= verts_ymax) &amp; 
                               (np.max(line_array[:,1]) &gt;= verts_ymin))
                              )
    #cellinlinebox_all_bool[:] = 1 #to force all cells to be taken into account
    
    intersect_coords = np.empty((0,4))
    intersect_gridnos = np.empty((0),dtype=int) #has to be numbers, since a boolean is differently ordered
    verts_inlinebox = ugrid_all_verts[cellinlinebox_all_bool,:,:]
    verts_inlinebox_nos = np.where(cellinlinebox_all_bool)[0]

    
    print(f&#39;&gt;&gt; finding crossing flow links (can take a while, processing {cellinlinebox_all_bool.sum()} of {len(cellinlinebox_all_bool)} cells): &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    for iP, pol_data in enumerate(verts_inlinebox):
        pol_shp = Polygon(pol_data[~np.isnan(pol_data).all(axis=1)])
        intersect_result = pol_shp.intersection(line_section)
        if isinstance(intersect_result,shapely.geometry.multilinestring.MultiLineString): #in the rare case that a cell (pol_shp) is crossed by multiple parts of the line
            intersect_result_multi = intersect_result
        elif isinstance(intersect_result,shapely.geometry.linestring.LineString): #if one linepart trough cell (ex/including node), make multilinestring anyway
            if intersect_result.coords == []: #when the line does not cross this cell, intersect_results.coords is an empty linestring and this cell can be skipped (continue makes forloop continue with next in line without finishing the rest of the steps for this instance)
                continue
            elif len(intersect_result.coords.xy[0]) == 0: #for newer cartopy versions, when line does not cross this cell, intersect_result.coords.xy is (array(&#39;d&#39;), array(&#39;d&#39;)), and both arrays in tuple have len 0.
                continue
            intersect_result_multi = MultiLineString([intersect_result])
        for iLL, intesect_result_one in enumerate(intersect_result_multi.geoms): #loop over multilinestrings, will mostly only contain one linestring. Will be two if the line crosses a cell more than once.
            intersection_line = intesect_result_one.coords
            intline_xyshape = np.array(intersection_line.xy).shape
            #print(&#39;len(intersection_line.xy): %s&#39;%([intline_xyshape]))
            for numlinepart_incell in range(1,intline_xyshape[1]): #is mostly 1, but more if there is a linebreakpoint in this cell (then there are two or more lineparts)
                intersect_gridnos = np.append(intersect_gridnos,verts_inlinebox_nos[iP])
                #intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy)[np.newaxis,:,numlinepart_incell-1:numlinepart_incell+1]],axis=0)
                intersect_coords = np.concatenate([intersect_coords,np.array(intersection_line.xy).T[numlinepart_incell-1:numlinepart_incell+1].flatten()[np.newaxis]])
    
    if intersect_coords.shape[0] != len(intersect_gridnos):
        raise Exception(&#39;something went wrong, intersect_coords.shape[0] and len(intersect_gridnos) are not equal&#39;)
    
    intersect_pd = pd.DataFrame(intersect_coords,index=intersect_gridnos,columns=[&#39;x1&#39;,&#39;y1&#39;,&#39;x2&#39;,&#39;y2&#39;])
    intersect_pd.index.name = &#39;gridnumber&#39;
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
            
    
    #calculating distance for all crossed cells, from first point of line
    nlinecoords = line_array.shape[0]
    nlinedims = len(line_array.shape)
    ncrosscellparts = len(intersect_pd)
    if nlinecoords&lt;2 or nlinedims != 2:
        raise Exception(&#39;ERROR: line_array should at least contain two xy points [[x,y],[x,y]]&#39;)
    
    #calculate distance between celledge-linepart crossing (is zero when line iL crosses cell)
    distperline_tostart = np.zeros((ncrosscellparts,nlinecoords-1))
    distperline_tostop = np.zeros((ncrosscellparts,nlinecoords-1))
    linepart_length = np.zeros((nlinecoords))
    for iL in range(nlinecoords-1):
        #calculate length of lineparts
        line_section_part = LineString(line_array[iL:iL+2,:])
        if calcdist_fromlatlon:
            linepart_length[iL+1] = calc_dist_haversine(line_array[iL,0],line_array[iL+1,0],line_array[iL,1],line_array[iL+1,1])
        else:
            linepart_length[iL+1] = line_section_part.length
    
        #get distance between all lineparts and point (later used to calculate distance from beginpoint of closest linepart)
        for iP in range(ncrosscellparts):
            distperline_tostart[iP,iL] = line_section_part.distance(Point(intersect_coords[:,0][iP],intersect_coords[:,1][iP]))
            distperline_tostop[iP,iL] = line_section_part.distance(Point(intersect_coords[:,2][iP],intersect_coords[:,3][iP]))
    linepart_lengthcum = np.cumsum(linepart_length)
    cross_points_closestlineid = np.argmin(np.maximum(distperline_tostart,distperline_tostop),axis=1)
    intersect_pd[&#39;closestlineid&#39;] = cross_points_closestlineid
    
    
    if not calcdist_fromlatlon:
        crs_dist_starts = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_pythagoras(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    else:
        crs_dist_starts = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,0], line_array[cross_points_closestlineid,1], intersect_coords[:,1]) + linepart_lengthcum[cross_points_closestlineid]
        crs_dist_stops = calc_dist_haversine(line_array[cross_points_closestlineid,0], intersect_coords[:,2], line_array[cross_points_closestlineid,1], intersect_coords[:,3]) + linepart_lengthcum[cross_points_closestlineid]
    intersect_pd[&#39;crs_dist_starts&#39;] = crs_dist_starts
    intersect_pd[&#39;crs_dist_stops&#39;] = crs_dist_stops
    intersect_pd[&#39;linepartlen&#39;] = crs_dist_stops-crs_dist_starts
    intersect_pd = intersect_pd.sort_values(&#39;crs_dist_starts&#39;)
    
    print(f&#39;&gt;&gt; polygon_intersect() total, found intersection trough {len(intersect_gridnos)} of {len(cellinlinebox_all_bool)} cells: {(dt.datetime.now()-dtstart_all).total_seconds():.2f} sec&#39;)
    return intersect_pd</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.get_xzcoords_onintersection"><code class="name flex">
<span>def <span class="ident">get_xzcoords_onintersection</span></span>(<span>data_frommap_merged, intersect_pd, timestep=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xzcoords_onintersection(data_frommap_merged, intersect_pd, timestep=None):
    #TODO: remove hardcoding of variable names
    if timestep is None: #TODO: maybe make time dependent grid?
        raise Exception(&#39;ERROR: argument timestep not provided, this is necessary to retrieve correct waterlevel or fullgrid output&#39;)
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_frommap_merged)
    if dimn_layer is not None:
        nlay = data_frommap_merged.dims[dimn_layer]
    else: #no layers, 2D model
        nlay = 1

    xu_facedim = data_frommap_merged.grid.face_dimension
    xu_edgedim = data_frommap_merged.grid.edge_dimension
    xu_nodedim = data_frommap_merged.grid.node_dimension
        
    #potentially construct fullgrid info (zcc/zw) #TODO: this ifloop is copied from get_mapdata_atdepth(), prevent this duplicate code
    if dimn_layer not in data_frommap_merged.dims: #2D model
        print(&#39;depth dimension not found, probably 2D model&#39;)
        pass
    elif &#39;mesh2d_flowelem_zw&#39; in data_frommap_merged.variables: #fullgrid info already available, so continuing
        print(&#39;zw/zcc (fullgrid) values already present in Dataset&#39;)
        pass
    elif &#39;mesh2d_layer_sigma&#39; in data_frommap_merged.variables: #reconstruct_zw_zcc_fromsigma and treat as zsigma/fullgrid mapfile from here
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_frommap_merged = reconstruct_zw_zcc_fromsigma(data_frommap_merged)
    elif &#39;mesh2d_layer_z&#39; in data_frommap_merged.variables:        
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_frommap_merged = reconstruct_zw_zcc_fromz(data_frommap_merged)
    else:
        raise Exception(&#39;layers present, but unknown layertype, expected one of variables: mesh2d_flowelem_zw, mesh2d_layer_sigma, mesh2d_layer_z&#39;)
    
    intersect_gridnos = intersect_pd.index
    data_frommap_merged_sel = data_frommap_merged.ugrid.obj.drop_dims([xu_edgedim,xu_nodedim]).isel(time=timestep).isel({xu_facedim:intersect_gridnos}) #TODO: not possible to do isel with non-sorted gridnos on ugridDataset, but it is on xrDataset. Dropping edge/nodedims first for neatness, so there is not mismatch in face/node/edge after using .isel(faces)
    if dimn_layer not in data_frommap_merged_sel.dims:
        data_frommap_wl3_sel = data_frommap_merged_sel[&#39;mesh2d_s1&#39;].to_numpy()
        data_frommap_bl_sel = data_frommap_merged_sel[&#39;mesh2d_flowelem_bl&#39;].to_numpy()
        zvals_interface = np.linspace(data_frommap_bl_sel,data_frommap_wl3_sel,nlay+1)
    elif &#39;mesh2d_flowelem_zw&#39; in data_frommap_merged_sel.variables:
        zvals_interface_filled = data_frommap_merged_sel[&#39;mesh2d_flowelem_zw&#39;].bfill(dim=dimn_interfaces) #fill nan values (below bed) with equal values
        zvals_interface = zvals_interface_filled.to_numpy().T # transpose to make in line with 2D sigma dataset
    
    #convert to output for plot_netmapdata
    crs_dist_starts_matrix = np.repeat(intersect_pd[&#39;crs_dist_starts&#39;].values[np.newaxis],nlay,axis=0)
    crs_dist_stops_matrix = np.repeat(intersect_pd[&#39;crs_dist_stops&#39;].values[np.newaxis],nlay,axis=0)
    crs_verts_x_all = np.array([[crs_dist_starts_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_starts_matrix.ravel()]]).T
    crs_verts_z_all = np.ma.array([zvals_interface[1:,:].ravel(),zvals_interface[1:,:].ravel(),zvals_interface[:-1,:].ravel(),zvals_interface[:-1,:].ravel()]).T[:,:,np.newaxis]
    crs_verts = np.ma.concatenate([crs_verts_x_all, crs_verts_z_all], axis=2)
    
    #define grid
    shape_crs_grid = crs_verts[:,:,0].shape
    shape_crs_flat = crs_verts[:,:,0].ravel().shape
    xr_crs_grid = xu.Ugrid2d(node_x=crs_verts[:,:,0].ravel(),
                             node_y=crs_verts[:,:,1].ravel(),
                             fill_value=-1,
                             face_node_connectivity=np.arange(shape_crs_flat[0]).reshape(shape_crs_grid),
                             )

    #define dataset
    crs_plotdata_clean = data_frommap_merged_sel
    if dimn_layer in data_frommap_merged_sel.dims:
        facedim_tempname = &#39;facedim_tempname&#39; #temporary new name to avoid duplicate from-to dimension name in .stack()
        crs_plotdata_clean = crs_plotdata_clean.rename({xu_facedim:facedim_tempname})
        crs_plotdata_clean = crs_plotdata_clean.stack({xr_crs_grid.face_dimension:[dimn_layer,facedim_tempname]})
        #reset_index converts face-dimension from multiindex to flat
        crs_plotdata_clean = crs_plotdata_clean.reset_index([xr_crs_grid.face_dimension])
    
    #combine into xugrid
    xr_crs_ugrid = xu.UgridDataset(crs_plotdata_clean, grids=[xr_crs_grid])
    return xr_crs_ugrid</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.polyline_mapslice"><code class="name flex">
<span>def <span class="ident">polyline_mapslice</span></span>(<span>data_frommap_merged, line_array, timestep, calcdist_fromlatlon=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polyline_mapslice(data_frommap_merged, line_array, timestep, calcdist_fromlatlon=None): #TODO: merge this into one function
    #intersect function, find crossed cell numbers (gridnos) and coordinates of intersection (2 per crossed cell)
    intersect_pd = polygon_intersect(data_frommap_merged, line_array, calcdist_fromlatlon=calcdist_fromlatlon)
    if len(intersect_pd) == 0:
        raise Exception(&#39;line_array does not cross mapdata&#39;) #TODO: move exception elsewhere?
    #derive vertices from cross section (distance from first point)
    xr_crs_ugrid = get_xzcoords_onintersection(data_frommap_merged, intersect_pd=intersect_pd, timestep=timestep)
    return xr_crs_ugrid</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc_fromsigma</span></span>(<span>data_xr_map)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc_fromsigma(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value
    &#34;&#34;&#34;
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_percentage = data_xr_map[&#39;mesh2d_layer_sigma&#39;]
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = data_frommap_wl_sel+(data_frommap_wl_sel-data_frommap_bl_sel)*zvals_cen_percentage
    
    zvals_interface_percentage = data_xr_map[&#39;mesh2d_interface_sigma&#39;]
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_frommap_wl_sel+(data_frommap_wl_sel-data_frommap_bl_sel)*zvals_interface_percentage
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc_fromz"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc_fromz</span></span>(<span>data_xr_map)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel</p>
<h1 id="todo-gives-spotty-result-for-001m-wrt-bedlevel-for-grevelingen-zmodel">TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel</h1>
<h1 id="todo-remove-hardcoding-of-varnames">TODO: remove hardcoding of varnames</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc_fromz(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel
    #TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel
    #TODO: remove hardcoding of varnames
    &#34;&#34;&#34;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr_map)
    
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_z0_sel = data_frommap_wl_sel*0
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_zval = data_xr_map[&#39;mesh2d_layer_z&#39;] #no clipping for zcenter values, since otherwise interp will fail
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = (data_frommap_z0_sel+zvals_cen_zval)

    zvals_interface_zval = data_xr_map[&#39;mesh2d_interface_z&#39;] #clipping for zinterface values, to make sure layer interfaces are also at water/bed level
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = (data_frommap_z0_sel+zvals_interface_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)
    bool_notoplayer_int = zvals_interface_zval&lt;zvals_interface_zval.isel({dimn_interfaces:-1})
    bool_int_abovewl = zvals_interface_zval&gt;data_frommap_wl_sel
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_xr_map[&#39;mesh2d_flowelem_zw&#39;].where(bool_notoplayer_int | bool_int_abovewl, other=data_frommap_wl_sel) #zvalues of top layer_interfaces that are lower than wl are replaced by wl
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.get_Dataset_atdepths"><code class="name flex">
<span>def <span class="ident">get_Dataset_atdepths</span></span>(<span>data_xr, depths, reference='z0', zlayer_z0_selnearest=False)</span>
</code></dt>
<dd>
<div class="desc"><p>data_xr_map:
has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy
depths:
int/float or list/array of int/float. Depths w.r.t. reference level. If reference=='waterlevel', depth&gt;0 returns only nans. If reference=='bedlevel', depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.
reference:
compute depth w.r.t. z0/waterlevel/bed
default: reference='z0'
zlayer_z0_interp:
Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference='z' (not 'waterlevel' or 'bedlevel'). Only used if "mesh2d_layer_z" is present (zlayer model)
This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.</p>
<h1 id="todo-zmodel-gets-depth-in-figure-title-because-of-set_index-in-open_partitioned_dataset-sigmamodel-gets-percentagefraction-in-title-set_index-was-removed-there-so-check-again">TODO: zmodel gets depth in figure title, because of .set_index() in open_partitioned_dataset(). Sigmamodel gets percentage/fraction in title. &gt;&gt; set_index was removed there, so check again.</h1>
<h1 id="todo-check-if-attributes-should-be-passedaltered">TODO: check if attributes should be passed/altered</h1>
<h1 id="todo-build-in-check-whether-layersinterfaces-are-coherent-lenintlenlay1-since-one-could-also-supply-a-udsisellayerrange10-where-there-are-still-51-interfaces-if-not-raise-error-to-remove-layer-selection">TODO: build in check whether layers/interfaces are coherent (len(int)=len(lay)+1), since one could also supply a uds.isel(layer=range(10)) where there are still 51 interfaces. (if not, raise error to remove layer selection)</h1>
<h1 id="todo-also-waterlevelvar-in-3d-model-gets-depth_fromref-coordinate-would-be-nice-to-avoid">TODO: also waterlevelvar in 3D model gets depth_fromref coordinate, would be nice to avoid.</h1>
<h1 id="todo-clean-up-unneccesary-variables-like-pre-interp-depth-values-and-interface-dim">TODO: clean up unneccesary variables (like pre-interp depth values and interface dim)</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Dataset_atdepths(data_xr, depths, reference=&#39;z0&#39;, zlayer_z0_selnearest=False):
    &#34;&#34;&#34;
    data_xr_map:
        has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
        in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy
    depths:
        int/float or list/array of int/float. Depths w.r.t. reference level. If reference==&#39;waterlevel&#39;, depth&gt;0 returns only nans. If reference==&#39;bedlevel&#39;, depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.
    reference:
        compute depth w.r.t. z0/waterlevel/bed
        default: reference=&#39;z0&#39;
    zlayer_z0_interp:
        Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference=&#39;z&#39; (not &#39;waterlevel&#39; or &#39;bedlevel&#39;). Only used if &#34;mesh2d_layer_z&#34; is present (zlayer model)
        This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.
    
    #TODO: zmodel gets depth in figure title, because of .set_index() in open_partitioned_dataset(). Sigmamodel gets percentage/fraction in title. &gt;&gt; set_index was removed there, so check again.
    #TODO: check if attributes should be passed/altered
    #TODO: build in check whether layers/interfaces are coherent (len(int)=len(lay)+1), since one could also supply a uds.isel(layer=range(10)) where there are still 51 interfaces. (if not, raise error to remove layer selection)
    #TODO: also waterlevelvar in 3D model gets depth_fromref coordinate, would be nice to avoid.
    #TODO: clean up unneccesary variables (like pre-interp depth values and interface dim)
    &#34;&#34;&#34;
    
    depth_varname = &#39;depth_fromref&#39;
    
    try:
        dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr)
    except: #TODO: catch nicely
        dimn_layer = dimn_interfaces = None
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = data_xr.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
        dimname_layc = dimn_layer
        dimname_layw = dimn_interfaces
        varname_wl = f&#39;{gridname}_s1&#39;
        varname_bl = f&#39;{gridname}_flowelem_bl&#39;
    elif &#39;laydim&#39; in data_xr.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
        dimname_layc = &#39;laydim&#39;
        dimname_layw = &#39;laydimw&#39;
        varname_wl = &#39;waterlevel&#39;
        varname_bl = &#39;bedlevel&#39;
        warnings.warn(UserWarning(&#39;get_Dataset_atdepths() is not tested for hisfiles yet, please check your results.&#39;))
    else:
        print(&#39;WARNING: depth dimension not found, probably 2D model, returning input Dataset&#39;)
        return data_xr #early return
    
    if not isinstance(data_xr,(xr.Dataset,xu.UgridDataset)):
        raise Exception(f&#39;data_xr_map should be of type xr.Dataset, but is {type(data_xr)}&#39;)
    
    #create depth xr.DataArray
    if isinstance(depths,(float,int)):
        #depths = depths #float/int
        depth_dims = ()
    else:
        depths = np.unique(depths) #array of unique+sorted floats/ints
        depth_dims = (depth_varname)
    depths_xr = xr.DataArray(depths,dims=depth_dims,attrs={&#39;units&#39;:&#39;m&#39;,
                                                           &#39;reference&#39;:f&#39;model_{reference}&#39;,
                                                           &#39;positive&#39;:&#39;up&#39;}) #TODO: make more in line with CMEMS etc
    
    #simplified/faster method for zlayer icm z0 reference (mapfiles only) #TODO: maybe remove this part of the code to make it better maintainable.
    if &#39;mesh2d_layer_z&#39; in data_xr.variables and zlayer_z0_selnearest and reference==&#39;z0&#39;: # selects nearest z-center values (instead of slicing), should be faster #TODO: check if this is faster than fullgrid
        print(&#39;z-layer model, zlayer_z0_selnearest=True and reference==&#34;z0&#34; so using xr.sel(method=&#34;nearest&#34;)]&#39;)
        warnings.warn(DeprecationWarning(&#39;The get_Dataset_atdepths() keyword zlayer_z0_selnearest might be phased out.&#39;))
        data_xr = data_xr.set_index({dimn_layer:&#39;mesh2d_layer_z&#39;})#.rename({&#39;nmesh2d_layer&#39;:depth_varname}) #set depth as index on layers, to be able to interp to depths instead of layernumbers
        data_xr[depth_varname] = depths_xr
        data_xr_atdepths = data_xr.sel({dimn_layer:depths_xr},method=&#39;nearest&#39;)
        data_wl = data_xr[varname_wl]
        data_bl = data_xr[varname_bl]
        data_xr_atdepths = data_xr_atdepths.where((depths_xr&gt;=data_bl) &amp; (depths_xr&lt;=data_wl)) #filter above wl and below bl values
        return data_xr_atdepths #early return
    
    #potentially construct fullgrid info (zcc/zw) #TODO: maybe move to separate function, like open_partitioned_dataset() (although bl/wl are needed anyway)
    if varname_zint in data_xr.variables: #fullgrid info already available, so continuing
        print(f&#39;zw/zcc (fullgrid) values already present in Dataset in variable {varname_zint}&#39;)
        pass
    elif &#39;mesh2d_layer_sigma&#39; in data_xr.variables: #reconstruct_zw_zcc_fromsigma and treat as zsigma/fullgrid mapfile from here
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_xr = reconstruct_zw_zcc_fromsigma(data_xr)
    elif &#39;mesh2d_layer_z&#39; in data_xr.variables:
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        data_xr = reconstruct_zw_zcc_fromz(data_xr)
    else:
        raise Exception(&#39;layers present, but unknown layertype/var&#39;)
    
    #correct reference level
    if reference==&#39;z0&#39;:
        zw_reference = data_xr[varname_zint]
    elif reference==&#39;waterlevel&#39;:
        data_wl = data_xr[varname_wl]
        zw_reference = data_xr[varname_zint] - data_wl
    elif reference==&#39;bedlevel&#39;:
        data_bl = data_xr[varname_bl]
        zw_reference = data_xr[varname_zint] - data_bl
    else:
        raise Exception(f&#39;unknown reference &#34;{reference}&#34; (possible are z0, waterlevel and bedlevel&#39;)
    
    print(&#39;&gt;&gt; subsetting data on fixed depth in fullgrid z-data: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
        
    if &#39;time&#39; in data_xr.dims: #TODO: suppress this warning for hisfiles since it does not make sense
        warnings.warn(UserWarning(&#39;get_mapdata_onfixedepth() can be very slow when supplying dataset with time dimension, you could supply ds.isel(time=timestep) instead&#39;))
        
    #get layerno via z-interface value (zw), check which celltop-interfaces are above/on depth and which which cellbottom-interfaces are below/on depth
    bool_topinterface_abovedepth = zw_reference.isel({dimname_layw:slice(1,None)}) &gt;= depths_xr
    bool_botinterface_belowdepth = zw_reference.isel({dimname_layw:slice(None,-1)}) &lt;= depths_xr
    bool_topbotinterface_arounddepth = bool_topinterface_abovedepth &amp; bool_botinterface_belowdepth #this bool also automatically excludes all values below bed and above wl
    bool_topbotinterface_arounddepth = bool_topbotinterface_arounddepth.rename({dimname_layw:dimname_layc}) #correct dimname for interfaces to centers
    data_xr_atdepths = data_xr.where(bool_topbotinterface_arounddepth).max(dim=dimname_layc,keep_attrs=True) #set all layers but one to nan, followed by an arbitrary reduce (max in this case)
    #TODO: suppress/solve warning for DCSM (does not happen when supplying data_xr_map[[&#39;mesh2d_sa1&#39;,&#39;mesh2d_s1&#39;,&#39;mesh2d_flowelem_bl&#39;,&#39;mesh2d_flowelem_zw&#39;]]): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\core.py:4806: PerformanceWarning: Increasing number of chunks by factor of 20&#34; &gt;&gt; still happens with new xugrid method?
    #TODO: suppress warning (upon plotting/load/etc): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\reductions.py:640: RuntimeWarning: All-NaN slice encountered&#34;
    
    #add depth as coordinate var
    data_xr_atdepths[depth_varname] = depths_xr
    data_xr_atdepths = data_xr_atdepths.set_coords([depth_varname])
    
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return data_xr_atdepths</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.plot_background"><code class="name flex">
<span>def <span class="ident">plot_background</span></span>(<span>ax=None, projection=None, google_style='satellite', resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
import contextily as ctx
fig, ax = plt.subplots(1,1)
ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs="EPSG:28992")
More info at: <a href="https://contextily.readthedocs.io/en/latest/reference.html">https://contextily.readthedocs.io/en/latest/reference.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>cartopy.mpl.geoaxes.GeoAxesSubplot</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
<dt><strong><code>projection</code></strong> :&ensp;<code>integer, cartopy._crs.CRS</code> or <code>cartopy._epsg._EPSGProjection</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
<dt><strong><code>google_style</code></strong> :&ensp;<code>Nonetype</code> or <code>string</code>, optional</dt>
<dd>&nbsp;</dd>
<dt>The style of the Google Maps tiles. One of None, â€˜streetâ€™, â€˜satelliteâ€™, â€˜terrainâ€™, and â€˜only_streetsâ€™. The default is 'satellite'.</dt>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Features to plot, options: None, 'ocean', 'rivers', 'land', 'countries', 'countries_highres', 'coastlines', 'coastlines_highres'. The default is None.</dd>
<dt><strong><code>nticks</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 6.</dd>
<dt><strong><code>latlon_format</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
<dt><strong><code>gridlines</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor='none', edgecolor='gray', linewidth=0.5, linestyle=':'</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_background(ax=None, projection=None, google_style=&#39;satellite&#39;, resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs):
    &#34;&#34;&#34;
    this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
    import contextily as ctx
    fig, ax = plt.subplots(1,1)
    ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs=&#34;EPSG:28992&#34;)
    More info at: https://contextily.readthedocs.io/en/latest/reference.html

    Parameters
    ----------
    ax : cartopy.mpl.geoaxes.GeoAxesSubplot, optional
        DESCRIPTION. The default is None.
    projection : integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection, optional
        DESCRIPTION. The default is None.
    google_style : Nonetype or string, optional
       The style of the Google Maps tiles. One of None, â€˜streetâ€™, â€˜satelliteâ€™, â€˜terrainâ€™, and â€˜only_streetsâ€™. The default is &#39;satellite&#39;.
    resolution : int, optional
        resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.
    features : string, optional
        Features to plot, options: None, &#39;ocean&#39;, &#39;rivers&#39;, &#39;land&#39;, &#39;countries&#39;, &#39;countries_highres&#39;, &#39;coastlines&#39;, &#39;coastlines_highres&#39;. The default is None.
    nticks : TYPE, optional
        DESCRIPTION. The default is 6.
    latlon_format : bool, optional
        DESCRIPTION. The default is False.
    gridlines : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor=&#39;none&#39;, edgecolor=&#39;gray&#39;, linewidth=0.5, linestyle=&#39;:&#39;

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ax : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    import cartopy
    import cartopy.crs as ccrs
    import cartopy.io.img_tiles as cimgt
    import cartopy.feature as cfeature
    import cartopy.mpl.ticker as cticker

    dummy = ccrs.epsg(28992) #to make cartopy realize it has a cartopy._epsg._EPSGProjection class (maybe gets fixed with cartopy updates, see unittest test_cartopy_epsg)
    if ax is None: #provide axis projection on initialisation, cannot be edited later on
        if projection is None:
            projection=ccrs.PlateCarree() #projection of cimgt.GoogleTiles, useful default
        elif isinstance(projection, (cartopy._epsg._EPSGProjection, cartopy.crs.CRS)): #checks if argument is an EPSG projection or CRS projection (like PlateCarree, Mercator etc). Note: it was cartopy._crs.CRS before instead of cartopy.crs.CRS
            pass
        elif type(projection) is int:
            projection = ccrs.epsg(projection)
        else:
            raise Exception(&#39;argument projection should be of type integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection&#39;)
        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: projection})
        #ax = plt.axes(projection=projection)
    elif type(ax) is cartopy.mpl.geoaxes.GeoAxesSubplot:
        if projection is not None:
            print(&#39;arguments ax and projection are both provided, the projection from the ax is used so the projection argument is ignored&#39;)
    else:
        raise Exception(&#39;argument ax should be of type cartopy.mpl.geoaxes.GeoAxesSubplot, leave argument empty or create correct instance with:\nimport cartopy.crs as ccrs\nfig, (ax1,ax2) = plt.subplots(1,2,figsize=(10,5), subplot_kw={&#34;projection&#34;: ccrs.epsg(28992)})&#39;)



    if gridlines:
        ax.gridlines(draw_labels=True)
    elif nticks is not None: #only look at nticks if gridlines are not used
        extent = ax.get_extent()
        ax.set_xticks(np.linspace(extent[0],extent[1],nticks))
        ax.set_yticks(np.linspace(extent[2],extent[3],nticks))


    if google_style is not None:
        request = cimgt.GoogleTiles(style=google_style)
        ax.add_image(request,resolution)


    if features is not None:
        if type(features) is str:
            features = [features]
        elif type(features) is not list:
            raise Exception(&#39;argument features should be of type list of str&#39;)

        valid_featurelist = [&#39;ocean&#39;,&#39;rivers&#39;,&#39;land&#39;,&#39;countries&#39;,&#39;countries_highres&#39;,&#39;coastlines&#39;,&#39;coastlines_highres&#39;]
        invalid_featurelist = [x for x in features if x not in valid_featurelist]
        if invalid_featurelist != []:
            raise Exception(&#39;invalid features %s requested, possible are: %s&#39;%(invalid_featurelist, valid_featurelist))

        if &#39;ocean&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;ocean&#39;, facecolor=cfeature.COLORS[&#39;water&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.OCEAN, **kwargs)
        if &#39;rivers&#39; in features:
            ax.add_feature(cfeature.RIVERS, **kwargs)
        if &#39;land&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;land&#39;, facecolor=cfeature.COLORS[&#39;land&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.LAND, **kwargs)
        if &#39;countries&#39; in features:
            ax.add_feature(cfeature.BORDERS, **kwargs)
        if &#39;countries_highres&#39; in features:
            feat = cfeature.NaturalEarthFeature(category=&#39;cultural&#39;, name=&#39;admin_0_countries&#39;, scale=&#39;10m&#39;)
            ax.add_feature(feat, **kwargs)
        if &#39;coastlines&#39; in features:
            ax.add_feature(cfeature.COASTLINE, **kwargs)
        if &#39;coastlines_highres&#39; in features:
            ax.coastlines(resolution=&#39;10m&#39;, **kwargs)

    if latlon_format:
        lon_formatter = cticker.LongitudeFormatter()
        lat_formatter = cticker.LatitudeFormatter()
        ax.xaxis.set_major_formatter(lon_formatter)
        ax.yaxis.set_major_formatter(lat_formatter)


    return ax</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.plot_ztdata"><code class="name flex">
<span>def <span class="ident">plot_ztdata</span></span>(<span>data_xr_sel, varname, ax=None, only_contour=False, get_ds=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_xr</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>varname</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes._subplots.AxesSubplot</code>, optional</dt>
<dd>the figure axis. The default is None.</dd>
<dt><strong><code>only_contour</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to plot contour lines of the dataset. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>properties to give on to the pcolormesh function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pc</code></strong> :&ensp;<code>matplotlib.collections.QuadMesh</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ztdata(data_xr_sel, varname, ax=None, only_contour=False, get_ds=False, **kwargs):
    &#34;&#34;&#34;
    

    Parameters
    ----------
    data_xr : TYPE
        DESCRIPTION.
    varname : TYPE
        DESCRIPTION.
    ax : matplotlib.axes._subplots.AxesSubplot, optional
        the figure axis. The default is None.
    only_contour : bool, optional
        Wheter to plot contour lines of the dataset. The default is False.
    **kwargs : TYPE
        properties to give on to the pcolormesh function.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    pc : matplotlib.collections.QuadMesh
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    if not ax: ax=plt.gca()
    
    if len(data_xr_sel[varname].shape) != 2:
        raise Exception(f&#39;ERROR: unexpected number of dimensions in requested squeezed variable ({data_xr_sel[varname].shape}), first use data_xr.isel(stations=int) to select a single station&#39;) #TODO: can also have a different cause, improve message/testing?
    
    #repair zvalues at wl/wl (filling nans and clipping to wl/bl). bfill replaces nan values with last valid value, this is necessary to enable pcolormesh to work. clip forces data to be within bl/wl
    #TODO: put clip in preproces_hisnc to make plotting easier?
    data_xr_sel[&#39;zcoordinate_c&#39;] = data_xr_sel[&#39;zcoordinate_c&#39;].bfill(dim=&#39;laydim&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    data_xr_sel[&#39;zcoordinate_w&#39;] = data_xr_sel[&#39;zcoordinate_w&#39;].bfill(dim=&#39;laydimw&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    
    # generate 2 2d grids for the x &amp; y bounds (you can also give one 2D array as input in case of eg time varying z coordinates)
    data_fromhis_zcor = data_xr_sel[&#39;zcoordinate_w&#39;].to_numpy() 
    data_fromhis_zcor = np.concatenate([data_fromhis_zcor,data_fromhis_zcor[[-1],:]],axis=0)
    time_np = data_xr_sel.time.to_numpy()
    time_cor = np.concatenate([time_np,time_np[[-1]]])
    time_mesh_cor = np.tile(time_cor,(data_fromhis_zcor.shape[-1],1)).T
    if only_contour:
        pc = data_xr_sel[varname].plot.contour(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_c&#39;, **kwargs)
    else:
        #pc = data_xr_sel[varname].plot.pcolormesh(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_w&#39;, **kwargs) #is not possible to put center values on interfaces, som more difficult approach needed
        pc = ax.pcolormesh(time_mesh_cor, data_fromhis_zcor, data_xr_sel[varname], **kwargs)
   
    return pc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools" href="index.html">dfm_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfm_tools.get_nc.get_ugrid_verts" href="#dfm_tools.get_nc.get_ugrid_verts">get_ugrid_verts</a></code></li>
<li><code><a title="dfm_tools.get_nc.calc_dist_pythagoras" href="#dfm_tools.get_nc.calc_dist_pythagoras">calc_dist_pythagoras</a></code></li>
<li><code><a title="dfm_tools.get_nc.calc_dist_haversine" href="#dfm_tools.get_nc.calc_dist_haversine">calc_dist_haversine</a></code></li>
<li><code><a title="dfm_tools.get_nc.polygon_intersect" href="#dfm_tools.get_nc.polygon_intersect">polygon_intersect</a></code></li>
<li><code><a title="dfm_tools.get_nc.get_xzcoords_onintersection" href="#dfm_tools.get_nc.get_xzcoords_onintersection">get_xzcoords_onintersection</a></code></li>
<li><code><a title="dfm_tools.get_nc.polyline_mapslice" href="#dfm_tools.get_nc.polyline_mapslice">polyline_mapslice</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma" href="#dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma">reconstruct_zw_zcc_fromsigma</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc_fromz" href="#dfm_tools.get_nc.reconstruct_zw_zcc_fromz">reconstruct_zw_zcc_fromz</a></code></li>
<li><code><a title="dfm_tools.get_nc.get_Dataset_atdepths" href="#dfm_tools.get_nc.get_Dataset_atdepths">get_Dataset_atdepths</a></code></li>
<li><code><a title="dfm_tools.get_nc.plot_background" href="#dfm_tools.get_nc.plot_background">plot_background</a></code></li>
<li><code><a title="dfm_tools.get_nc.plot_ztdata" href="#dfm_tools.get_nc.plot_ztdata">plot_ztdata</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>