<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dfm_tools.get_nc API documentation</title>
<meta name="description" content="dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dfm_tools.get_nc</code></h1>
</header>
<section id="section-intro">
<p>dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this program.
if not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<p>All names, logos, and references to "Deltares" are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.</p>
<p>INFORMATION
This script is part of dfm_tools: <a href="https://github.com/openearth/dfm_tools">https://github.com/openearth/dfm_tools</a>
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools</p>
<p>Created on Fri Feb 14 12:45:11 2020</p>
<p>@author: veenstra</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
dfm_tools are post-processing tools for Delft3D FM
Copyright (C) 2020 Deltares. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  if not, see &lt;http://www.gnu.org/licenses/&gt;.

All names, logos, and references to &#34;Deltares&#34; are registered trademarks of
Stichting Deltares and remain full property of Stichting Deltares at all times.
All rights reserved.


INFORMATION
This script is part of dfm_tools: https://github.com/openearth/dfm_tools
Check the README.rst on github for other available functions
Check the tests folder on github for example scripts (this is the dfm_tools pytest testbank)
Check the pptx and example figures in (created by the testbank): N:/Deltabox/Bulletin/veenstra/info dfm_tools

Created on Fri Feb 14 12:45:11 2020

@author: veenstra
&#34;&#34;&#34;

import warnings
import numpy as np
import datetime as dt
import re
import xugrid as xu
import xarray as xr
import matplotlib.pyplot as plt
from dfm_tools.xarray_helpers import get_vertical_dimensions, Dataset_varswithdim


def get_ugrid_verts(data_xr_map): #TODO: remove this deprecated function
    &#34;&#34;&#34;
    getting ugrid verts from xugrid mapfile.
    &#34;&#34;&#34;
    raise DeprecationWarning(&#39;dfmt.get_ugrid_verts() is deprecated, use uds.grid.face_node_coordinates instead (https://github.com/Deltares/xugrid/issues/48)&#39;)


def calc_dist_pythagoras(x1,x2,y1,y2):
    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance


def calc_dist_haversine(lon1,lon2,lat1,lat2):
    &#34;&#34;&#34;
    calculates distance between lat/lon coordinates in meters
    https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128
    &#34;&#34;&#34;
    # convert to radians
    lon1_rad = np.deg2rad(lon1)
    lon2_rad = np.deg2rad(lon2)
    lat1_rad = np.deg2rad(lat1)
    lat2_rad = np.deg2rad(lat2)
    
    # apply formulae
    a = np.sin((lat2_rad-lat1_rad)/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin((lon2_rad-lon1_rad)/2)**2
    c = 2 * np.arctan2( np.sqrt(a), np.sqrt(1-a) )
    R = 6371000
    distance = R * c
    if np.isnan(distance).any():
        raise ValueError(&#39;nan encountered in calc_dist_latlon distance&#39;)
    return distance


def intersect_edges_withsort(uds,edges): #TODO: move sorting to xugrid? https://deltares.github.io/xugrid/api/xugrid.Ugrid2d.intersect_edges.html
    
    edge_index, face_index, intersections = uds.grid.intersect_edges(edges) #TODO: is fast, but maybe speed can be increased with bounding box?
    
    #ordering of face_index is wrong (visible with cb3 with long line_array), so sort on distance from startpoint (in x/y units)
    
    #compute distance from start of line to start of each linepart
    edge_len = np.linalg.norm(edges[:,1] - edges[:,0], axis=1)
    edge_len_cum = np.cumsum(edge_len)
    edge_len_cum0 = np.concatenate([[0],edge_len_cum[:-1]])
    
    #compute distance from start to lineparts to start of line (via line)
    startcoord_linepart = edges[edge_index,0,:]
    dist_tostart_linepart = np.linalg.norm(intersections[:,0,:] - startcoord_linepart, axis=1)
    dist_tostart_line = dist_tostart_linepart + edge_len_cum0[edge_index]
    
    #sorting on distance
    id_sorted = np.argsort(dist_tostart_line)
    edge_index = edge_index[id_sorted]
    face_index = face_index[id_sorted]
    intersections = intersections[id_sorted]
    return edge_index, face_index, intersections


def get_xzcoords_onintersection(uds, face_index, crs_dist_starts, crs_dist_stops):
    #TODO: remove hardcoding of variable names
    if &#39;time&#39; in uds.dims: #TODO: maybe make time dependent grid?
        raise Exception(&#39;time dimension present in uds, provide uds.isel(time=timestep) instead. This is necessary to retrieve correct waterlevel or fullgrid output&#39;)
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(uds)
    gridname = uds.grid.name
    
    #construct fullgrid info (zcc/zw) for 3D models
    if dimn_layer in uds.dims:
        uds = reconstruct_zw_zcc(uds)

    #drop all variables that do not contain a face dimension, then select only all sliced faceidx
    xu_facedim = uds.grid.face_dimension
    face_index_xr = xr.DataArray(face_index,dims=(&#39;ncrossed_faces&#39;))
    uds = Dataset_varswithdim(uds,dimname=xu_facedim) #TODO: is there an xugrid alternative?
    uds_sel = uds.sel({xu_facedim:face_index_xr})
    
    # take zvals_interface
    if dimn_layer in uds_sel.dims: #3D model
        nlay = uds.dims[dimn_layer]
        zvals_interface_filled = uds_sel[f&#39;{gridname}_flowelem_zw&#39;].bfill(dim=dimn_interfaces) #fill nan values (below bed) with equal values
        zvals_interface = zvals_interface_filled.to_numpy().T #transpose to make in line with 2D sigma dataset
    else: #2D model, no layers
        nlay = 1
        data_frommap_wl3_sel = uds_sel[f&#39;{gridname}_s1&#39;].to_numpy() #TODO: add escape for missing wl/bl vars
        data_frommap_bl_sel = uds_sel[f&#39;{gridname}_flowelem_bl&#39;].to_numpy()
        zvals_interface = np.linspace(data_frommap_bl_sel,data_frommap_wl3_sel,nlay+1)

    #derive crs_verts
    crs_dist_starts_matrix = np.repeat(crs_dist_starts[np.newaxis],nlay,axis=0)
    crs_dist_stops_matrix = np.repeat(crs_dist_stops[np.newaxis],nlay,axis=0)
    crs_verts_x_all = np.array([[crs_dist_starts_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_starts_matrix.ravel()]]).T
    crs_verts_z_all = np.ma.array([zvals_interface[1:,:].ravel(),zvals_interface[1:,:].ravel(),zvals_interface[:-1,:].ravel(),zvals_interface[:-1,:].ravel()]).T[:,:,np.newaxis]
    crs_verts = np.ma.concatenate([crs_verts_x_all, crs_verts_z_all], axis=2)
    
    #define grid
    shape_crs_grid = crs_verts[:,:,0].shape
    shape_crs_flat = crs_verts[:,:,0].ravel().shape
    xr_crs_grid = xu.Ugrid2d(node_x=crs_verts[:,:,0].ravel(),
                             node_y=crs_verts[:,:,1].ravel(),
                             fill_value=-1,
                             face_node_connectivity=np.arange(shape_crs_flat[0]).reshape(shape_crs_grid),
                             )

    #define dataset
    if dimn_layer in uds_sel.dims:
        crs_plotdata_clean = uds_sel.stack({xr_crs_grid.face_dimension:[dimn_layer,&#39;ncrossed_faces&#39;]},create_index=False)
    else: #2D: still make sure xr_crs_grid.face_dimension is created, using stack since .rename() gives &#34;UserWarning: rename &#39;ncrossed_faces&#39; to &#39;mesh2d_nFaces&#39; does not create an index anymore.&#34;
        crs_plotdata_clean = uds_sel.stack({xr_crs_grid.face_dimension:[&#39;ncrossed_faces&#39;]},create_index=False)
                    
    #combine into xugrid
    xr_crs_ugrid = xu.UgridDataset(crs_plotdata_clean, grids=[xr_crs_grid])
    return xr_crs_ugrid


def polyline_mapslice(uds:xu.UgridDataset, line_array:np.array, calcdist_fromlatlon:bool = None) -&gt; xu.UgridDataset:
    &#34;&#34;&#34;
    Slice trough mapdata, combine: intersect_edges_withsort, calculation of distances and conversion to ugrid dataset.

    Parameters
    ----------
    uds : xu.UgridDataset
        DESCRIPTION.
    line_array : np.array
        DESCRIPTION.
    calcdist_fromlatlon : bool, optional
        DESCRIPTION. The default is None.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    xr_crs_ugrid : xu.UgridDataset
        DESCRIPTION.

    &#34;&#34;&#34;
    
    #compute intersection coordinates of crossings between edges and faces and their respective indices
    edges = np.stack([line_array[:-1],line_array[1:]],axis=1)
    edge_index, face_index, intersections = intersect_edges_withsort(uds=uds, edges=edges)
    if len(edge_index) == 0:
        raise ValueError(&#39;polyline does not cross mapdata&#39;)
    
    #auto determine if cartesian/sperical distance should be computed
    if calcdist_fromlatlon is None:
        if hasattr(uds,&#39;projected_coordinate_system&#39;):
            calcdist_fromlatlon = False
        elif hasattr(uds,&#39;wgs84&#39;):
            calcdist_fromlatlon = True
        else:
            raise KeyError(&#39;To auto determine calcdist_fromlatlon, a variable &#34;projected_coordinate_system&#34; or &#34;wgs84&#34; is required, please provide calcdist_fromlatlon=True/False yourself.&#39;)
    if calcdist_fromlatlon:
        calc_dist = calc_dist_haversine
    else:
        calc_dist = calc_dist_pythagoras
    
    #compute pyt/haversine start/stop distances for all intersections
    edge_len = calc_dist(edges[:,0,0], edges[:,1,0], edges[:,0,1], edges[:,1,1])
    edge_len_cum = np.cumsum(edge_len)
    edge_len_cum0 = np.concatenate([[0],edge_len_cum[:-1]])
    crs_dist_starts = calc_dist(edges[edge_index,0,0], intersections[:,0,0], edges[edge_index,0,1], intersections[:,0,1]) + edge_len_cum0[edge_index]
    crs_dist_stops  = calc_dist(edges[edge_index,0,0], intersections[:,1,0], edges[edge_index,0,1], intersections[:,1,1]) + edge_len_cum0[edge_index]
    
    #derive vertices from cross section (distance from first point)
    xr_crs_ugrid = get_xzcoords_onintersection(uds=uds, face_index=face_index, crs_dist_starts=crs_dist_starts, crs_dist_stops=crs_dist_stops)
    
    return xr_crs_ugrid


def get_formula_terms(uds, varn_contains):
    &#34;&#34;&#34;
    get formula_terms for zw/zcc reconstruction, convert to list and then to dict. This can be done for layer/interface (via varn_contains)
    &#34;&#34;&#34;
    osz_varnames = list(uds.filter_by_attrs(formula_terms=lambda v: v is not None).variables) #names of variables containing attribute &#34;formula_terms&#34;
    osz_varnames_contains = [x for x in osz_varnames if varn_contains in x] #TODO: to get the layer/interface ocean_*_coordinate. Not too pretty, but it works
    if len(osz_varnames_contains) != 1: #should be 1 exactly, none is the case in zlayer models
        raise ValueError(f&#39;no or more than one {varn_contains} variable found with formula_terms attribute: {osz_varnames}&#39;)
    osz_varn = osz_varnames_contains[0]
    osz_formulaterms = uds[osz_varn].attrs[&#39;formula_terms&#39;]
    tokens = re.split(&#39;[:\\s]+&#39;, osz_formulaterms)
    osz_formulaterms_dict = dict(zip(tokens[::2], tokens[1::2]))
    return osz_formulaterms_dict


def reconstruct_zw_zcc_fromsigma(uds):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value
    based on https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_coordinate
    &#34;&#34;&#34;
    osz_formulaterms_int_dict = get_formula_terms(uds,varn_contains=&#39;interface&#39;)
    osz_formulaterms_lay_dict = get_formula_terms(uds,varn_contains=&#39;layer&#39;)
    
    uds_eta = uds[osz_formulaterms_int_dict[&#39;eta&#39;]] #mesh2d_s1
    uds_depth = uds[osz_formulaterms_int_dict[&#39;depth&#39;]] #mesh2d_bldepth in new output, mesh2d_waterdepth in old output (see comment below)
    if uds_depth.attrs[&#39;standard_name&#39;] == &#39;sea_floor_depth_below_sea_surface&#39;: # previously the waterdepth instead of negative bedlevel was coupled via the formula_terms in sigmamodels (was fixed in OSS 140982 / 29-3-2022)
        uds_depth = -uds[&#39;mesh2d_flowelem_bl&#39;] # assuming this variable is available, which is not guaranteed
    uds_sigma_int = uds[osz_formulaterms_int_dict[&#39;sigma&#39;]] #mesh2d_interface_sigma
    uds_sigma_lay = uds[osz_formulaterms_lay_dict[&#39;sigma&#39;]] #mesh2d_layer_sigma
    
    uds[&#39;mesh2d_flowelem_zw&#39;] = uds_eta + uds_sigma_int*(uds_depth+uds_eta)
    uds[&#39;mesh2d_flowelem_zcc&#39;] = uds_eta + uds_sigma_lay*(uds_depth+uds_eta)
    
    uds = uds.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return uds


def reconstruct_zw_zcc_fromz(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel
    #TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel
    #TODO: remove hardcoding of varnames (assuming wl/bl variables are available)
    #TODO: center values are clipped to waterlevel+bedlevel, so the center values of the top+bottom layer are currently incorrect
    &#34;&#34;&#34;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr_map)
    
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_z0_sel = data_frommap_wl_sel*0
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_zval = data_xr_map[&#39;mesh2d_layer_z&#39;] #no clipping for zcenter values, since otherwise interp will fail
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = (data_frommap_z0_sel+zvals_cen_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)

    zvals_interface_zval = data_xr_map[&#39;mesh2d_interface_z&#39;] #clipping for zinterface values, to make sure layer interfaces are also at water/bed level
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = (data_frommap_z0_sel+zvals_interface_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)
    bool_notoplayer_int = zvals_interface_zval&lt;zvals_interface_zval.isel({dimn_interfaces:-1})
    bool_int_abovewl = zvals_interface_zval&gt;data_frommap_wl_sel
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_xr_map[&#39;mesh2d_flowelem_zw&#39;].where(bool_notoplayer_int | bool_int_abovewl, other=data_frommap_wl_sel) #zvalues of top layer_interfaces that are lower than wl are replaced by wl
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map


def reconstruct_zw_zcc_fromzsigma(uds):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zsigmavalue model without full grid output. Implemented in https://issuetracker.deltares.nl/browse/UNST-5477
    based on https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_over_z_coordinate
    #TODO: center values are clipped to bedlevel, so the center values of the bottom layer are currently incorrect
    &#34;&#34;&#34;
    
    #TODO: default fillvalues are not automatically parsed to nan, so doing it manually: https://github.com/pydata/xarray/issues/2742
    import netCDF4
    fillvals = netCDF4.default_fillvals
    
    osz_formulaterms_int_dict = get_formula_terms(uds,varn_contains=&#39;interface&#39;)
    osz_formulaterms_lay_dict = get_formula_terms(uds,varn_contains=&#39;layer&#39;)
    
    uds_eta = uds[osz_formulaterms_int_dict[&#39;eta&#39;]] #mesh2d_s1
    uds_depth = uds[osz_formulaterms_int_dict[&#39;depth&#39;]] #mesh2d_bldepth: positive version of mesh2d_flowelem_bl, but this one is always in file
    uds_depth_c = uds[osz_formulaterms_int_dict[&#39;depth_c&#39;]] #mesh2d_sigmazdepth
    uds_zlev_int = uds[osz_formulaterms_int_dict[&#39;zlev&#39;]] #mesh2d_interface_z
    uds_zlev_int = uds_zlev_int.where(uds_zlev_int!=fillvals[&#39;f8&#39;])
    uds_sigma_int = uds[osz_formulaterms_int_dict[&#39;sigma&#39;]] #mesh2d_interface_sigma
    uds_sigma_int = uds_sigma_int.where(uds_sigma_int!=fillvals[&#39;f8&#39;])
    uds_zlev_lay = uds[osz_formulaterms_lay_dict[&#39;zlev&#39;]] #mesh2d_layer_z
    uds_zlev_lay = uds_zlev_lay.where(uds_zlev_lay!=fillvals[&#39;f8&#39;])
    uds_sigma_lay = uds[osz_formulaterms_lay_dict[&#39;sigma&#39;]] #mesh2d_layer_sigma
    uds_sigma_lay = uds_sigma_lay.where(uds_sigma_lay!=fillvals[&#39;f8&#39;])
    
    # for levels k where sigma(k) has a defined value and zlev(k) is not defined:
    # z(n,k,j,i) = eta(n,j,i) + sigma(k)*(min(depth_c,depth(j,i))+eta(n,j,i))
    zw_sigmapart = uds_eta + uds_sigma_int*(uds_depth.clip(max=uds_depth_c)+uds_eta)
    zcc_sigmapart = uds_eta + uds_sigma_lay*(uds_depth.clip(max=uds_depth_c)+uds_eta)
    # for levels k where zlev(k) has a defined value and sigma(k) is not defined: 
    # z(n,k,j,i) = zlev(k)
    zw_zpart = uds_zlev_int.clip(min=-uds_depth) #added clipping of zvalues with bedlevel
    zcc_zpart = uds_zlev_lay.clip(min=-uds_depth) #added clipping of zvalues with bedlevel
    uds[&#39;mesh2d_flowelem_zw&#39;] = zw_sigmapart.fillna(zw_zpart)
    uds[&#39;mesh2d_flowelem_zcc&#39;] = zcc_sigmapart.fillna(zcc_zpart)
    
    uds = uds.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return uds


def reconstruct_zw_zcc(ds):
    dimn_layer, dimn_interfaces = get_vertical_dimensions(ds)
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = ds.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
    elif &#39;laydim&#39; in ds.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
    
    #reconstruct zw/zcc variables (if not in file) and treat as fullgrid mapfile from here
    if varname_zint in ds.variables: #fullgrid info already available, so continuing
        print(f&#39;zw/zcc (fullgrid) values already present in Dataset in variable {varname_zint}&#39;)
    elif len(ds.filter_by_attrs(standard_name=&#39;ocean_sigma_z_coordinate&#39;)) != 0:
        print(&#39;zsigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromzsigma(ds)
    elif &#39;mesh2d_layer_sigma&#39; in ds.variables: #TODO: var with standard_name=&#39;ocean_sigma_coordinate&#39; available?
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromsigma(ds)
    elif &#39;mesh2d_layer_z&#39; in ds.variables:
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromz(ds)
    else:
        raise KeyError(&#39;layers present, but unknown layertype, expected one of variables: mesh2d_flowelem_zw, mesh2d_layer_sigma, mesh2d_layer_z&#39;)
    return ds

    
def get_Dataset_atdepths(data_xr:xu.UgridDataset, depths, reference:str =&#39;z0&#39;):    
    &#34;&#34;&#34;
    Lazily depth-slice a dataset with layers. Performance can be increased by using a subset of variables or subsetting the dataset in any dimension.
    This can be done for instance with ds.isel(time=-1) or uds.ugrid.sel(x=slice(),y=slice()) to subset a ugrid dataset in space.
    The return dataset only contains the sliced variables.
    
    Parameters
    ----------
    data_xr : xu.UgridDataset
        has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
        in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy
    depths : TYPE
        int/float or list/array of int/float. Depths w.r.t. reference level. If reference==&#39;waterlevel&#39;, depth&gt;0 returns only nans. If reference==&#39;bedlevel&#39;, depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.
    reference : str, optional
        compute depth w.r.t. z0/waterlevel/bed. The default is &#39;z0&#39;.
    zlayer_z0_selnearest : bool, optional
        Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference=&#39;z&#39; (not &#39;waterlevel&#39; or &#39;bedlevel&#39;). Only used if &#34;mesh2d_layer_z&#34; is present (zlayer model)
        This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.. The default is False.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    xu.UgridDataset
        Dataset with the depth-sliced variables.

    &#34;&#34;&#34;
    
    depth_vardimname = f&#39;depth_from_{reference}&#39;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr)
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = data_xr.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
        dimname_layc = dimn_layer
        dimname_layw = dimn_interfaces
        varname_wl = f&#39;{gridname}_s1&#39;
        varname_bl = f&#39;{gridname}_flowelem_bl&#39;
    elif &#39;laydim&#39; in data_xr.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
        dimname_layc = &#39;laydim&#39;
        dimname_layw = &#39;laydimw&#39;
        varname_wl = &#39;waterlevel&#39;
        varname_bl = &#39;bedlevel&#39;
    else:
        print(UserWarning(&#39;depth/layer dimension not found, probably 2D model, returning input Dataset&#39;)) #TODO: this can also be at depth, since slice will put parts of model dry (and allnan if below wl or below bl). Implement this
        return data_xr #early return
    
    if not isinstance(data_xr,(xr.Dataset,xu.UgridDataset)):
        raise TypeError(f&#39;data_xr_map should be of type xr.Dataset, but is {type(data_xr)}&#39;)
    
    #create depth xr.DataArray
    if isinstance(depths,(float,int)):
        depth_dims = ()
    else:
        depths = np.unique(depths) #array of unique+sorted floats/ints
        depth_dims = (depth_vardimname)
    depths_xr = xr.DataArray(depths,dims=depth_dims,attrs={&#39;units&#39;:&#39;m&#39;,
                                                           &#39;reference&#39;:f&#39;model_{reference}&#39;,
                                                           &#39;positive&#39;:&#39;up&#39;}) #TODO: make more in line with CMEMS etc
    
    #potentially construct fullgrid info (zcc/zw)
    data_xr = reconstruct_zw_zcc(data_xr)
    
    #correct reference level
    if reference==&#39;z0&#39;:
        zw_reference = data_xr[varname_zint]
    elif reference==&#39;waterlevel&#39;:
        if varname_wl not in data_xr.variables:
            raise KeyError(f&#39;get_Dataset_atdepths() called with reference=waterlevel, but {varname_wl} variable not present&#39;)
        data_wl = data_xr[varname_wl]
        zw_reference = data_xr[varname_zint] - data_wl
    elif reference==&#39;bedlevel&#39;:
        if varname_bl not in data_xr.variables:
            raise KeyError(f&#39;get_Dataset_atdepths() called with reference=bedlevel, but {varname_bl} variable not present&#39;) #TODO: in case of zsigma/sigma it can also be -mesh2d_bldepth
        data_bl = data_xr[varname_bl]
        zw_reference = data_xr[varname_zint] - data_bl
    else:
        raise KeyError(f&#39;unknown reference &#34;{reference}&#34; (possible are z0, waterlevel and bedlevel&#39;) #TODO: make enum?
    
    print(&#39;&gt;&gt; subsetting data on fixed depth in fullgrid z-data: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    
    #get layerbool via z-interface value (zw), check which celltop-interfaces are above/on depth and which which cellbottom-interfaces are below/on depth
    bool_topinterface_abovedepth = zw_reference.isel({dimname_layw:slice(1,None)}) &gt;= depths_xr
    bool_botinterface_belowdepth = zw_reference.isel({dimname_layw:slice(None,-1)}) &lt;= depths_xr
    bool_topbotinterface_arounddepth = bool_topinterface_abovedepth &amp; bool_botinterface_belowdepth #this bool also automatically excludes all values below bed and above wl
    bool_topbotinterface_arounddepth = bool_topbotinterface_arounddepth.rename({dimname_layw:dimname_layc}) #correct dimname for interfaces to centers
    
    #subset variables that have no, time, face and/or layer dims, slice only variables with all three dims (and add to subset)
    bool_dims = [x for x in bool_topbotinterface_arounddepth.dims if x!=depth_vardimname] #exclude depth_vardimname (present if multiple depths supplied), since it is not present in pre-slice variables
    variables_toslice = [var for var in data_xr.data_vars if set(bool_dims).issubset(data_xr[var].dims)]
    
    #actual slicing with .where().max()
    ds_atdepths = data_xr[variables_toslice].where(bool_topbotinterface_arounddepth).max(dim=dimname_layc,keep_attrs=True) #set all layers but one to nan, followed by an arbitrary reduce (max in this case) #TODO: check if attributes should be passed/altered
    #TODO: suppress warning (upon plotting/load/etc): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\reductions.py:640: RuntimeWarning: All-NaN slice encountered&#34; &gt;&gt; already merged in xarray: https://github.com/dask/dask/pull/9916
    ds_atdepths = ds_atdepths.drop_dims([dimname_layw,dimname_layc],errors=&#39;ignore&#39;) #dropping interface dim if it exists, since it does not correspond to new depths dim
    
    #add depth as coordinate var
    ds_atdepths[depth_vardimname] = depths_xr
    ds_atdepths = ds_atdepths.set_coords([depth_vardimname])
    
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return ds_atdepths


def rasterize_ugrid(uds:xu.UgridDataset, ds_like:xr.Dataset = None, resolution:float = None):
    &#34;&#34;&#34;
    Rasterizing ugrid dataset to regular dataset. ds_like has higher priority than `resolution`. If both are not passed, a raster is generated of at least 200x200
    inspired by xugrid.plot.imshow and xugrid.ugrid.ugrid2d.rasterize/rasterize_like.


    Parameters
    ----------
    uds : xu.UgridDataset
        DESCRIPTION.
    ds_like : xr.Dataset, optional
        xr.Dataset with ed x and y variables to interpolate uds to. The default is None.
    resolution : float, optional
        Only used if ds_like is not supplied. The default is None.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ds : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    #TODO: maybe put part of code in xugrid (https://github.com/Deltares/xugrid/issues/31)
    #TODO: vars can also be rasterized with uds_facevars[var].ugrid.rasterize(resolution), but is not efficient. Wait for uds.rasterize() method: https://github.com/Deltares/xugrid/issues/61
    if not isinstance(uds,xu.core.wrap.UgridDataset):
        raise TypeError(f&#39;rasterize_ugrid expected xu.core.wrap.UgridDataset, got {type(uds)} instead&#39;)
    
    grid = uds.grid
    xu_facedim = uds.grid.face_dimension
    uds_facevars = Dataset_varswithdim(uds,xu_facedim)
    
    if ds_like is not None:
        regx = ds_like.x
        regy = ds_like.y
    else:
        xmin, ymin, xmax, ymax = grid.bounds
        dx = xmax - xmin
        dy = ymax - ymin
        if resolution is None: # check if a rasterization resolution is passed, otherwise default to 200 raster cells otherwise for the smallest axis.
            resolution = min(dx, dy) / 200
        d = abs(resolution)
        regx = np.arange(xmin + 0.5 * d, xmax, d)
        regy = np.arange(ymin + 0.5 * d, ymax, d)
    
    regx, regy, index = grid.rasterize_like(x=regx,y=regy) #TODO: this can be used to steer rasterization, eg with xstart/ystart/xres/yres
    index_da = xr.DataArray(index,dims=(&#39;y&#39;,&#39;x&#39;))
    
    print(f&#39;&gt;&gt; rasterizing ugrid dataset with {len(uds_facevars.data_vars)} face variables to shape={index_da.shape}: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    ds = uds_facevars.isel({xu_facedim:index_da})
    ds = ds.where(index_da != grid.fill_value)
    ds[&#39;x&#39;] = xr.DataArray(regx,dims=&#39;x&#39;)
    ds[&#39;y&#39;] = xr.DataArray(regy,dims=&#39;y&#39;)
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return ds


def plot_background(ax=None, projection=None, google_style=&#39;satellite&#39;, resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs):
    &#34;&#34;&#34;
    this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
    import contextily as ctx
    fig, ax = plt.subplots(1,1)
    ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs=&#34;EPSG:28992&#34;)
    More info at: https://contextily.readthedocs.io/en/latest/reference.html

    Parameters
    ----------
    ax : cartopy.mpl.geoaxes.GeoAxesSubplot, optional
        DESCRIPTION. The default is None.
    projection : integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection, optional
        DESCRIPTION. The default is None.
    google_style : Nonetype or string, optional
       The style of the Google Maps tiles. One of None, ‘street’, ‘satellite’, ‘terrain’, and ‘only_streets’. The default is &#39;satellite&#39;.
    resolution : int, optional
        resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.
    features : string, optional
        Features to plot, options: None, &#39;ocean&#39;, &#39;rivers&#39;, &#39;land&#39;, &#39;countries&#39;, &#39;countries_highres&#39;, &#39;coastlines&#39;, &#39;coastlines_highres&#39;. The default is None.
    nticks : TYPE, optional
        DESCRIPTION. The default is 6.
    latlon_format : bool, optional
        DESCRIPTION. The default is False.
    gridlines : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor=&#39;none&#39;, edgecolor=&#39;gray&#39;, linewidth=0.5, linestyle=&#39;:&#39;

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ax : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    import cartopy
    import cartopy.crs as ccrs
    import cartopy.io.img_tiles as cimgt
    import cartopy.feature as cfeature
    import cartopy.mpl.ticker as cticker

    dummy = ccrs.epsg(28992) #to make cartopy realize it has a cartopy._epsg._EPSGProjection class (maybe gets fixed with cartopy updates, see unittest test_cartopy_epsg)
    if ax is None: #provide axis projection on initialisation, cannot be edited later on
        if projection is None:
            projection=ccrs.PlateCarree() #projection of cimgt.GoogleTiles, useful default
        elif isinstance(projection, (cartopy._epsg._EPSGProjection, cartopy.crs.CRS)): #checks if argument is an EPSG projection or CRS projection (like PlateCarree, Mercator etc). Note: it was cartopy._crs.CRS before instead of cartopy.crs.CRS
            pass
        elif type(projection) is int:
            projection = ccrs.epsg(projection)
        else:
            raise TypeError(&#39;argument projection should be of type integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection&#39;)
        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: projection})
    elif type(ax) is cartopy.mpl.geoaxes.GeoAxesSubplot:
        if projection is not None:
            print(&#39;arguments ax and projection are both provided, the projection from the ax is used so the projection argument is ignored&#39;)
    else:
        raise TypeError(&#39;argument ax should be of type cartopy.mpl.geoaxes.GeoAxesSubplot, leave argument empty or create correct instance with:\nimport cartopy.crs as ccrs\nfig, (ax1,ax2) = plt.subplots(1,2,figsize=(10,5), subplot_kw={&#34;projection&#34;: ccrs.epsg(28992)})&#39;)



    if gridlines:
        ax.gridlines(draw_labels=True)
    elif nticks is not None: #only look at nticks if gridlines are not used
        extent = ax.get_extent()
        ax.set_xticks(np.linspace(extent[0],extent[1],nticks))
        ax.set_yticks(np.linspace(extent[2],extent[3],nticks))


    if google_style is not None:
        request = cimgt.GoogleTiles(style=google_style)
        ax.add_image(request,resolution)


    if features is not None:
        if type(features) is str:
            features = [features]
        elif type(features) is not list:
            raise TypeError(&#39;argument features should be of type list of str&#39;)

        valid_featurelist = [&#39;ocean&#39;,&#39;rivers&#39;,&#39;land&#39;,&#39;countries&#39;,&#39;countries_highres&#39;,&#39;coastlines&#39;,&#39;coastlines_highres&#39;]
        invalid_featurelist = [x for x in features if x not in valid_featurelist]
        if invalid_featurelist != []:
            raise KeyError(&#39;invalid features %s requested, possible are: %s&#39;%(invalid_featurelist, valid_featurelist))

        if &#39;ocean&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;ocean&#39;, facecolor=cfeature.COLORS[&#39;water&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.OCEAN, **kwargs)
        if &#39;rivers&#39; in features:
            ax.add_feature(cfeature.RIVERS, **kwargs)
        if &#39;land&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;land&#39;, facecolor=cfeature.COLORS[&#39;land&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.LAND, **kwargs)
        if &#39;countries&#39; in features:
            ax.add_feature(cfeature.BORDERS, **kwargs)
        if &#39;countries_highres&#39; in features:
            feat = cfeature.NaturalEarthFeature(category=&#39;cultural&#39;, name=&#39;admin_0_countries&#39;, scale=&#39;10m&#39;)
            ax.add_feature(feat, **kwargs)
        if &#39;coastlines&#39; in features:
            ax.add_feature(cfeature.COASTLINE, **kwargs)
        if &#39;coastlines_highres&#39; in features:
            ax.coastlines(resolution=&#39;10m&#39;, **kwargs)

    if latlon_format:
        lon_formatter = cticker.LongitudeFormatter()
        lat_formatter = cticker.LatitudeFormatter()
        ax.xaxis.set_major_formatter(lon_formatter)
        ax.yaxis.set_major_formatter(lat_formatter)


    return ax


def plot_ztdata(data_xr_sel, varname, ax=None, only_contour=False, **kwargs):
    &#34;&#34;&#34;
    

    Parameters
    ----------
    data_xr : TYPE
        DESCRIPTION.
    varname : TYPE
        DESCRIPTION.
    ax : matplotlib.axes._subplots.AxesSubplot, optional
        the figure axis. The default is None.
    only_contour : bool, optional
        Wheter to plot contour lines of the dataset. The default is False.
    **kwargs : TYPE
        properties to give on to the pcolormesh function.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    pc : matplotlib.collections.QuadMesh
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    if not ax: ax=plt.gca()
    
    if len(data_xr_sel[varname].shape) != 2:
        raise ValueError(f&#39;ERROR: unexpected number of dimensions in requested squeezed variable ({data_xr_sel[varname].shape}), first use data_xr.isel(stations=int) to select a single station&#39;) #TODO: can also have a different cause, improve message/testing?
    
    #repair zvalues at wl/wl (filling nans and clipping to wl/bl). bfill replaces nan values with last valid value, this is necessary to enable pcolormesh to work. clip forces data to be within bl/wl
    #TODO: put clip in preproces_hisnc to make plotting easier?
    data_xr_sel[&#39;zcoordinate_c&#39;] = data_xr_sel[&#39;zcoordinate_c&#39;].bfill(dim=&#39;laydim&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    data_xr_sel[&#39;zcoordinate_w&#39;] = data_xr_sel[&#39;zcoordinate_w&#39;].bfill(dim=&#39;laydimw&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    
    # generate 2 2d grids for the x &amp; y bounds (you can also give one 2D array as input in case of eg time varying z coordinates)
    data_fromhis_zcor = data_xr_sel[&#39;zcoordinate_w&#39;].to_numpy() 
    data_fromhis_zcor = np.concatenate([data_fromhis_zcor,data_fromhis_zcor[[-1],:]],axis=0)
    time_np = data_xr_sel.time.to_numpy()
    time_cor = np.concatenate([time_np,time_np[[-1]]])
    time_mesh_cor = np.tile(time_cor,(data_fromhis_zcor.shape[-1],1)).T
    if only_contour:
        pc = data_xr_sel[varname].plot.contour(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_c&#39;, **kwargs)
    else:
        #pc = data_xr_sel[varname].plot.pcolormesh(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_w&#39;, **kwargs) #TODO: not possible to put center values on interfaces, so more difficult approach needed
        pc = ax.pcolormesh(time_mesh_cor, data_fromhis_zcor, data_xr_sel[varname], **kwargs)
   
    return pc</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dfm_tools.get_nc.get_ugrid_verts"><code class="name flex">
<span>def <span class="ident">get_ugrid_verts</span></span>(<span>data_xr_map)</span>
</code></dt>
<dd>
<div class="desc"><p>getting ugrid verts from xugrid mapfile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ugrid_verts(data_xr_map): #TODO: remove this deprecated function
    &#34;&#34;&#34;
    getting ugrid verts from xugrid mapfile.
    &#34;&#34;&#34;
    raise DeprecationWarning(&#39;dfmt.get_ugrid_verts() is deprecated, use uds.grid.face_node_coordinates instead (https://github.com/Deltares/xugrid/issues/48)&#39;)</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.calc_dist_pythagoras"><code class="name flex">
<span>def <span class="ident">calc_dist_pythagoras</span></span>(<span>x1, x2, y1, y2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dist_pythagoras(x1,x2,y1,y2):
    distance = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.calc_dist_haversine"><code class="name flex">
<span>def <span class="ident">calc_dist_haversine</span></span>(<span>lon1, lon2, lat1, lat2)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates distance between lat/lon coordinates in meters
<a href="https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128">https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dist_haversine(lon1,lon2,lat1,lat2):
    &#34;&#34;&#34;
    calculates distance between lat/lon coordinates in meters
    https://community.esri.com/t5/coordinate-reference-systems-blog/distance-on-a-sphere-the-haversine-formula/ba-p/902128
    &#34;&#34;&#34;
    # convert to radians
    lon1_rad = np.deg2rad(lon1)
    lon2_rad = np.deg2rad(lon2)
    lat1_rad = np.deg2rad(lat1)
    lat2_rad = np.deg2rad(lat2)
    
    # apply formulae
    a = np.sin((lat2_rad-lat1_rad)/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin((lon2_rad-lon1_rad)/2)**2
    c = 2 * np.arctan2( np.sqrt(a), np.sqrt(1-a) )
    R = 6371000
    distance = R * c
    if np.isnan(distance).any():
        raise ValueError(&#39;nan encountered in calc_dist_latlon distance&#39;)
    return distance</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.intersect_edges_withsort"><code class="name flex">
<span>def <span class="ident">intersect_edges_withsort</span></span>(<span>uds, edges)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect_edges_withsort(uds,edges): #TODO: move sorting to xugrid? https://deltares.github.io/xugrid/api/xugrid.Ugrid2d.intersect_edges.html
    
    edge_index, face_index, intersections = uds.grid.intersect_edges(edges) #TODO: is fast, but maybe speed can be increased with bounding box?
    
    #ordering of face_index is wrong (visible with cb3 with long line_array), so sort on distance from startpoint (in x/y units)
    
    #compute distance from start of line to start of each linepart
    edge_len = np.linalg.norm(edges[:,1] - edges[:,0], axis=1)
    edge_len_cum = np.cumsum(edge_len)
    edge_len_cum0 = np.concatenate([[0],edge_len_cum[:-1]])
    
    #compute distance from start to lineparts to start of line (via line)
    startcoord_linepart = edges[edge_index,0,:]
    dist_tostart_linepart = np.linalg.norm(intersections[:,0,:] - startcoord_linepart, axis=1)
    dist_tostart_line = dist_tostart_linepart + edge_len_cum0[edge_index]
    
    #sorting on distance
    id_sorted = np.argsort(dist_tostart_line)
    edge_index = edge_index[id_sorted]
    face_index = face_index[id_sorted]
    intersections = intersections[id_sorted]
    return edge_index, face_index, intersections</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.get_xzcoords_onintersection"><code class="name flex">
<span>def <span class="ident">get_xzcoords_onintersection</span></span>(<span>uds, face_index, crs_dist_starts, crs_dist_stops)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xzcoords_onintersection(uds, face_index, crs_dist_starts, crs_dist_stops):
    #TODO: remove hardcoding of variable names
    if &#39;time&#39; in uds.dims: #TODO: maybe make time dependent grid?
        raise Exception(&#39;time dimension present in uds, provide uds.isel(time=timestep) instead. This is necessary to retrieve correct waterlevel or fullgrid output&#39;)
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(uds)
    gridname = uds.grid.name
    
    #construct fullgrid info (zcc/zw) for 3D models
    if dimn_layer in uds.dims:
        uds = reconstruct_zw_zcc(uds)

    #drop all variables that do not contain a face dimension, then select only all sliced faceidx
    xu_facedim = uds.grid.face_dimension
    face_index_xr = xr.DataArray(face_index,dims=(&#39;ncrossed_faces&#39;))
    uds = Dataset_varswithdim(uds,dimname=xu_facedim) #TODO: is there an xugrid alternative?
    uds_sel = uds.sel({xu_facedim:face_index_xr})
    
    # take zvals_interface
    if dimn_layer in uds_sel.dims: #3D model
        nlay = uds.dims[dimn_layer]
        zvals_interface_filled = uds_sel[f&#39;{gridname}_flowelem_zw&#39;].bfill(dim=dimn_interfaces) #fill nan values (below bed) with equal values
        zvals_interface = zvals_interface_filled.to_numpy().T #transpose to make in line with 2D sigma dataset
    else: #2D model, no layers
        nlay = 1
        data_frommap_wl3_sel = uds_sel[f&#39;{gridname}_s1&#39;].to_numpy() #TODO: add escape for missing wl/bl vars
        data_frommap_bl_sel = uds_sel[f&#39;{gridname}_flowelem_bl&#39;].to_numpy()
        zvals_interface = np.linspace(data_frommap_bl_sel,data_frommap_wl3_sel,nlay+1)

    #derive crs_verts
    crs_dist_starts_matrix = np.repeat(crs_dist_starts[np.newaxis],nlay,axis=0)
    crs_dist_stops_matrix = np.repeat(crs_dist_stops[np.newaxis],nlay,axis=0)
    crs_verts_x_all = np.array([[crs_dist_starts_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_stops_matrix.ravel(),crs_dist_starts_matrix.ravel()]]).T
    crs_verts_z_all = np.ma.array([zvals_interface[1:,:].ravel(),zvals_interface[1:,:].ravel(),zvals_interface[:-1,:].ravel(),zvals_interface[:-1,:].ravel()]).T[:,:,np.newaxis]
    crs_verts = np.ma.concatenate([crs_verts_x_all, crs_verts_z_all], axis=2)
    
    #define grid
    shape_crs_grid = crs_verts[:,:,0].shape
    shape_crs_flat = crs_verts[:,:,0].ravel().shape
    xr_crs_grid = xu.Ugrid2d(node_x=crs_verts[:,:,0].ravel(),
                             node_y=crs_verts[:,:,1].ravel(),
                             fill_value=-1,
                             face_node_connectivity=np.arange(shape_crs_flat[0]).reshape(shape_crs_grid),
                             )

    #define dataset
    if dimn_layer in uds_sel.dims:
        crs_plotdata_clean = uds_sel.stack({xr_crs_grid.face_dimension:[dimn_layer,&#39;ncrossed_faces&#39;]},create_index=False)
    else: #2D: still make sure xr_crs_grid.face_dimension is created, using stack since .rename() gives &#34;UserWarning: rename &#39;ncrossed_faces&#39; to &#39;mesh2d_nFaces&#39; does not create an index anymore.&#34;
        crs_plotdata_clean = uds_sel.stack({xr_crs_grid.face_dimension:[&#39;ncrossed_faces&#39;]},create_index=False)
                    
    #combine into xugrid
    xr_crs_ugrid = xu.UgridDataset(crs_plotdata_clean, grids=[xr_crs_grid])
    return xr_crs_ugrid</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.polyline_mapslice"><code class="name flex">
<span>def <span class="ident">polyline_mapslice</span></span>(<span>uds: xugrid.core.wrap.UgridDataset, line_array: <built-in function array>, calcdist_fromlatlon: bool = None) ‑> xugrid.core.wrap.UgridDataset</span>
</code></dt>
<dd>
<div class="desc"><p>Slice trough mapdata, combine: intersect_edges_withsort, calculation of distances and conversion to ugrid dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uds</code></strong> :&ensp;<code>xu.UgridDataset</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>line_array</code></strong> :&ensp;<code>np.array</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>calcdist_fromlatlon</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xr_crs_ugrid</code></strong> :&ensp;<code>xu.UgridDataset</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polyline_mapslice(uds:xu.UgridDataset, line_array:np.array, calcdist_fromlatlon:bool = None) -&gt; xu.UgridDataset:
    &#34;&#34;&#34;
    Slice trough mapdata, combine: intersect_edges_withsort, calculation of distances and conversion to ugrid dataset.

    Parameters
    ----------
    uds : xu.UgridDataset
        DESCRIPTION.
    line_array : np.array
        DESCRIPTION.
    calcdist_fromlatlon : bool, optional
        DESCRIPTION. The default is None.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    xr_crs_ugrid : xu.UgridDataset
        DESCRIPTION.

    &#34;&#34;&#34;
    
    #compute intersection coordinates of crossings between edges and faces and their respective indices
    edges = np.stack([line_array[:-1],line_array[1:]],axis=1)
    edge_index, face_index, intersections = intersect_edges_withsort(uds=uds, edges=edges)
    if len(edge_index) == 0:
        raise ValueError(&#39;polyline does not cross mapdata&#39;)
    
    #auto determine if cartesian/sperical distance should be computed
    if calcdist_fromlatlon is None:
        if hasattr(uds,&#39;projected_coordinate_system&#39;):
            calcdist_fromlatlon = False
        elif hasattr(uds,&#39;wgs84&#39;):
            calcdist_fromlatlon = True
        else:
            raise KeyError(&#39;To auto determine calcdist_fromlatlon, a variable &#34;projected_coordinate_system&#34; or &#34;wgs84&#34; is required, please provide calcdist_fromlatlon=True/False yourself.&#39;)
    if calcdist_fromlatlon:
        calc_dist = calc_dist_haversine
    else:
        calc_dist = calc_dist_pythagoras
    
    #compute pyt/haversine start/stop distances for all intersections
    edge_len = calc_dist(edges[:,0,0], edges[:,1,0], edges[:,0,1], edges[:,1,1])
    edge_len_cum = np.cumsum(edge_len)
    edge_len_cum0 = np.concatenate([[0],edge_len_cum[:-1]])
    crs_dist_starts = calc_dist(edges[edge_index,0,0], intersections[:,0,0], edges[edge_index,0,1], intersections[:,0,1]) + edge_len_cum0[edge_index]
    crs_dist_stops  = calc_dist(edges[edge_index,0,0], intersections[:,1,0], edges[edge_index,0,1], intersections[:,1,1]) + edge_len_cum0[edge_index]
    
    #derive vertices from cross section (distance from first point)
    xr_crs_ugrid = get_xzcoords_onintersection(uds=uds, face_index=face_index, crs_dist_starts=crs_dist_starts, crs_dist_stops=crs_dist_stops)
    
    return xr_crs_ugrid</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.get_formula_terms"><code class="name flex">
<span>def <span class="ident">get_formula_terms</span></span>(<span>uds, varn_contains)</span>
</code></dt>
<dd>
<div class="desc"><p>get formula_terms for zw/zcc reconstruction, convert to list and then to dict. This can be done for layer/interface (via varn_contains)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_formula_terms(uds, varn_contains):
    &#34;&#34;&#34;
    get formula_terms for zw/zcc reconstruction, convert to list and then to dict. This can be done for layer/interface (via varn_contains)
    &#34;&#34;&#34;
    osz_varnames = list(uds.filter_by_attrs(formula_terms=lambda v: v is not None).variables) #names of variables containing attribute &#34;formula_terms&#34;
    osz_varnames_contains = [x for x in osz_varnames if varn_contains in x] #TODO: to get the layer/interface ocean_*_coordinate. Not too pretty, but it works
    if len(osz_varnames_contains) != 1: #should be 1 exactly, none is the case in zlayer models
        raise ValueError(f&#39;no or more than one {varn_contains} variable found with formula_terms attribute: {osz_varnames}&#39;)
    osz_varn = osz_varnames_contains[0]
    osz_formulaterms = uds[osz_varn].attrs[&#39;formula_terms&#39;]
    tokens = re.split(&#39;[:\\s]+&#39;, osz_formulaterms)
    osz_formulaterms_dict = dict(zip(tokens[::2], tokens[1::2]))
    return osz_formulaterms_dict</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc_fromsigma</span></span>(<span>uds)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value
based on <a href="https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_coordinate">https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_coordinate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc_fromsigma(uds):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for sigma model, necessary for slicing sigmamodel on depth value
    based on https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_coordinate
    &#34;&#34;&#34;
    osz_formulaterms_int_dict = get_formula_terms(uds,varn_contains=&#39;interface&#39;)
    osz_formulaterms_lay_dict = get_formula_terms(uds,varn_contains=&#39;layer&#39;)
    
    uds_eta = uds[osz_formulaterms_int_dict[&#39;eta&#39;]] #mesh2d_s1
    uds_depth = uds[osz_formulaterms_int_dict[&#39;depth&#39;]] #mesh2d_bldepth in new output, mesh2d_waterdepth in old output (see comment below)
    if uds_depth.attrs[&#39;standard_name&#39;] == &#39;sea_floor_depth_below_sea_surface&#39;: # previously the waterdepth instead of negative bedlevel was coupled via the formula_terms in sigmamodels (was fixed in OSS 140982 / 29-3-2022)
        uds_depth = -uds[&#39;mesh2d_flowelem_bl&#39;] # assuming this variable is available, which is not guaranteed
    uds_sigma_int = uds[osz_formulaterms_int_dict[&#39;sigma&#39;]] #mesh2d_interface_sigma
    uds_sigma_lay = uds[osz_formulaterms_lay_dict[&#39;sigma&#39;]] #mesh2d_layer_sigma
    
    uds[&#39;mesh2d_flowelem_zw&#39;] = uds_eta + uds_sigma_int*(uds_depth+uds_eta)
    uds[&#39;mesh2d_flowelem_zcc&#39;] = uds_eta + uds_sigma_lay*(uds_depth+uds_eta)
    
    uds = uds.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return uds</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc_fromz"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc_fromz</span></span>(<span>data_xr_map)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel</p>
<h1 id="todo-gives-spotty-result-for-001m-wrt-bedlevel-for-grevelingen-zmodel">TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel</h1>
<h1 id="todo-remove-hardcoding-of-varnames-assuming-wlbl-variables-are-available">TODO: remove hardcoding of varnames (assuming wl/bl variables are available)</h1>
<h1 id="todo-center-values-are-clipped-to-waterlevelbedlevel-so-the-center-values-of-the-topbottom-layer-are-currently-incorrect">TODO: center values are clipped to waterlevel+bedlevel, so the center values of the top+bottom layer are currently incorrect</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc_fromz(data_xr_map):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zvalue model. Necessary when extracting values with zdepth w.r.t. waterlevel/bedlevel
    #TODO: gives spotty result for 0/0.1m w.r.t. bedlevel for Grevelingen zmodel
    #TODO: remove hardcoding of varnames (assuming wl/bl variables are available)
    #TODO: center values are clipped to waterlevel+bedlevel, so the center values of the top+bottom layer are currently incorrect
    &#34;&#34;&#34;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr_map)
    
    data_frommap_wl_sel = data_xr_map[&#39;mesh2d_s1&#39;]
    data_frommap_z0_sel = data_frommap_wl_sel*0
    data_frommap_bl_sel = data_xr_map[&#39;mesh2d_flowelem_bl&#39;]
    
    zvals_cen_zval = data_xr_map[&#39;mesh2d_layer_z&#39;] #no clipping for zcenter values, since otherwise interp will fail
    data_xr_map[&#39;mesh2d_flowelem_zcc&#39;] = (data_frommap_z0_sel+zvals_cen_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)

    zvals_interface_zval = data_xr_map[&#39;mesh2d_interface_z&#39;] #clipping for zinterface values, to make sure layer interfaces are also at water/bed level
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = (data_frommap_z0_sel+zvals_interface_zval).clip(min=data_frommap_bl_sel, max=data_frommap_wl_sel)
    bool_notoplayer_int = zvals_interface_zval&lt;zvals_interface_zval.isel({dimn_interfaces:-1})
    bool_int_abovewl = zvals_interface_zval&gt;data_frommap_wl_sel
    data_xr_map[&#39;mesh2d_flowelem_zw&#39;] = data_xr_map[&#39;mesh2d_flowelem_zw&#39;].where(bool_notoplayer_int | bool_int_abovewl, other=data_frommap_wl_sel) #zvalues of top layer_interfaces that are lower than wl are replaced by wl
    
    data_xr_map = data_xr_map.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return data_xr_map</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc_fromzsigma"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc_fromzsigma</span></span>(<span>uds)</span>
</code></dt>
<dd>
<div class="desc"><p>reconstruct full grid output (time/face-varying z-values) for zsigmavalue model without full grid output. Implemented in <a href="https://issuetracker.deltares.nl/browse/UNST-5477">https://issuetracker.deltares.nl/browse/UNST-5477</a>
based on <a href="https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_over_z_coordinate">https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_over_z_coordinate</a></p>
<h1 id="todo-center-values-are-clipped-to-bedlevel-so-the-center-values-of-the-bottom-layer-are-currently-incorrect">TODO: center values are clipped to bedlevel, so the center values of the bottom layer are currently incorrect</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc_fromzsigma(uds):
    &#34;&#34;&#34;
    reconstruct full grid output (time/face-varying z-values) for zsigmavalue model without full grid output. Implemented in https://issuetracker.deltares.nl/browse/UNST-5477
    based on https://cfconventions.org/cf-conventions/cf-conventions.html#_ocean_sigma_over_z_coordinate
    #TODO: center values are clipped to bedlevel, so the center values of the bottom layer are currently incorrect
    &#34;&#34;&#34;
    
    #TODO: default fillvalues are not automatically parsed to nan, so doing it manually: https://github.com/pydata/xarray/issues/2742
    import netCDF4
    fillvals = netCDF4.default_fillvals
    
    osz_formulaterms_int_dict = get_formula_terms(uds,varn_contains=&#39;interface&#39;)
    osz_formulaterms_lay_dict = get_formula_terms(uds,varn_contains=&#39;layer&#39;)
    
    uds_eta = uds[osz_formulaterms_int_dict[&#39;eta&#39;]] #mesh2d_s1
    uds_depth = uds[osz_formulaterms_int_dict[&#39;depth&#39;]] #mesh2d_bldepth: positive version of mesh2d_flowelem_bl, but this one is always in file
    uds_depth_c = uds[osz_formulaterms_int_dict[&#39;depth_c&#39;]] #mesh2d_sigmazdepth
    uds_zlev_int = uds[osz_formulaterms_int_dict[&#39;zlev&#39;]] #mesh2d_interface_z
    uds_zlev_int = uds_zlev_int.where(uds_zlev_int!=fillvals[&#39;f8&#39;])
    uds_sigma_int = uds[osz_formulaterms_int_dict[&#39;sigma&#39;]] #mesh2d_interface_sigma
    uds_sigma_int = uds_sigma_int.where(uds_sigma_int!=fillvals[&#39;f8&#39;])
    uds_zlev_lay = uds[osz_formulaterms_lay_dict[&#39;zlev&#39;]] #mesh2d_layer_z
    uds_zlev_lay = uds_zlev_lay.where(uds_zlev_lay!=fillvals[&#39;f8&#39;])
    uds_sigma_lay = uds[osz_formulaterms_lay_dict[&#39;sigma&#39;]] #mesh2d_layer_sigma
    uds_sigma_lay = uds_sigma_lay.where(uds_sigma_lay!=fillvals[&#39;f8&#39;])
    
    # for levels k where sigma(k) has a defined value and zlev(k) is not defined:
    # z(n,k,j,i) = eta(n,j,i) + sigma(k)*(min(depth_c,depth(j,i))+eta(n,j,i))
    zw_sigmapart = uds_eta + uds_sigma_int*(uds_depth.clip(max=uds_depth_c)+uds_eta)
    zcc_sigmapart = uds_eta + uds_sigma_lay*(uds_depth.clip(max=uds_depth_c)+uds_eta)
    # for levels k where zlev(k) has a defined value and sigma(k) is not defined: 
    # z(n,k,j,i) = zlev(k)
    zw_zpart = uds_zlev_int.clip(min=-uds_depth) #added clipping of zvalues with bedlevel
    zcc_zpart = uds_zlev_lay.clip(min=-uds_depth) #added clipping of zvalues with bedlevel
    uds[&#39;mesh2d_flowelem_zw&#39;] = zw_sigmapart.fillna(zw_zpart)
    uds[&#39;mesh2d_flowelem_zcc&#39;] = zcc_sigmapart.fillna(zcc_zpart)
    
    uds = uds.set_coords([&#39;mesh2d_flowelem_zw&#39;,&#39;mesh2d_flowelem_zcc&#39;])
    return uds</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.reconstruct_zw_zcc"><code class="name flex">
<span>def <span class="ident">reconstruct_zw_zcc</span></span>(<span>ds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_zw_zcc(ds):
    dimn_layer, dimn_interfaces = get_vertical_dimensions(ds)
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = ds.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
    elif &#39;laydim&#39; in ds.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
    
    #reconstruct zw/zcc variables (if not in file) and treat as fullgrid mapfile from here
    if varname_zint in ds.variables: #fullgrid info already available, so continuing
        print(f&#39;zw/zcc (fullgrid) values already present in Dataset in variable {varname_zint}&#39;)
    elif len(ds.filter_by_attrs(standard_name=&#39;ocean_sigma_z_coordinate&#39;)) != 0:
        print(&#39;zsigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromzsigma(ds)
    elif &#39;mesh2d_layer_sigma&#39; in ds.variables: #TODO: var with standard_name=&#39;ocean_sigma_coordinate&#39; available?
        print(&#39;sigma-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromsigma(ds)
    elif &#39;mesh2d_layer_z&#39; in ds.variables:
        print(&#39;z-layer model, computing zw/zcc (fullgrid) values and treat as fullgrid model from here&#39;)
        ds = reconstruct_zw_zcc_fromz(ds)
    else:
        raise KeyError(&#39;layers present, but unknown layertype, expected one of variables: mesh2d_flowelem_zw, mesh2d_layer_sigma, mesh2d_layer_z&#39;)
    return ds</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.get_Dataset_atdepths"><code class="name flex">
<span>def <span class="ident">get_Dataset_atdepths</span></span>(<span>data_xr: xugrid.core.wrap.UgridDataset, depths, reference: str = 'z0')</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily depth-slice a dataset with layers. Performance can be increased by using a subset of variables or subsetting the dataset in any dimension.
This can be done for instance with ds.isel(time=-1) or uds.ugrid.sel(x=slice(),y=slice()) to subset a ugrid dataset in space.
The return dataset only contains the sliced variables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_xr</code></strong> :&ensp;<code>xu.UgridDataset</code></dt>
<dd>has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy</dd>
<dt><strong><code>depths</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>int/float or list/array of int/float. Depths w.r.t. reference level. If reference=='waterlevel', depth&gt;0 returns only nans. If reference=='bedlevel', depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>compute depth w.r.t. z0/waterlevel/bed. The default is 'z0'.</dd>
<dt><strong><code>zlayer_z0_selnearest</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference='z' (not 'waterlevel' or 'bedlevel'). Only used if "mesh2d_layer_z" is present (zlayer model)
This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.. The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xu.UgridDataset</code></dt>
<dd>Dataset with the depth-sliced variables.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Dataset_atdepths(data_xr:xu.UgridDataset, depths, reference:str =&#39;z0&#39;):    
    &#34;&#34;&#34;
    Lazily depth-slice a dataset with layers. Performance can be increased by using a subset of variables or subsetting the dataset in any dimension.
    This can be done for instance with ds.isel(time=-1) or uds.ugrid.sel(x=slice(),y=slice()) to subset a ugrid dataset in space.
    The return dataset only contains the sliced variables.
    
    Parameters
    ----------
    data_xr : xu.UgridDataset
        has to be Dataset (not a DataArray), otherwise mesh2d_flowelem_zw etc are not available (interface z values)
        in case of zsigma/sigma layers (or fullgrid), it is advisable to .sel()/.isel() the time dimension first, because that is less computationally heavy
    depths : TYPE
        int/float or list/array of int/float. Depths w.r.t. reference level. If reference==&#39;waterlevel&#39;, depth&gt;0 returns only nans. If reference==&#39;bedlevel&#39;, depth&lt;0 returns only nans. Depths are sorted and only uniques are kept.
    reference : str, optional
        compute depth w.r.t. z0/waterlevel/bed. The default is &#39;z0&#39;.
    zlayer_z0_selnearest : bool, optional
        Use xr.interp() to interpolate zlayer model to z-value. Only possible for reference=&#39;z&#39; (not &#39;waterlevel&#39; or &#39;bedlevel&#39;). Only used if &#34;mesh2d_layer_z&#34; is present (zlayer model)
        This is faster but results in values interpolated between zcc (z cell centers), so it is different than slicing.. The default is False.

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    xu.UgridDataset
        Dataset with the depth-sliced variables.

    &#34;&#34;&#34;
    
    depth_vardimname = f&#39;depth_from_{reference}&#39;
    
    dimn_layer, dimn_interfaces = get_vertical_dimensions(data_xr)
    
    if dimn_layer is not None: #D-FlowFM mapfile
        gridname = data_xr.grid.name
        varname_zint = f&#39;{gridname}_flowelem_zw&#39;
        dimname_layc = dimn_layer
        dimname_layw = dimn_interfaces
        varname_wl = f&#39;{gridname}_s1&#39;
        varname_bl = f&#39;{gridname}_flowelem_bl&#39;
    elif &#39;laydim&#39; in data_xr.dims: #D-FlowFM hisfile
        varname_zint = &#39;zcoordinate_w&#39;
        dimname_layc = &#39;laydim&#39;
        dimname_layw = &#39;laydimw&#39;
        varname_wl = &#39;waterlevel&#39;
        varname_bl = &#39;bedlevel&#39;
    else:
        print(UserWarning(&#39;depth/layer dimension not found, probably 2D model, returning input Dataset&#39;)) #TODO: this can also be at depth, since slice will put parts of model dry (and allnan if below wl or below bl). Implement this
        return data_xr #early return
    
    if not isinstance(data_xr,(xr.Dataset,xu.UgridDataset)):
        raise TypeError(f&#39;data_xr_map should be of type xr.Dataset, but is {type(data_xr)}&#39;)
    
    #create depth xr.DataArray
    if isinstance(depths,(float,int)):
        depth_dims = ()
    else:
        depths = np.unique(depths) #array of unique+sorted floats/ints
        depth_dims = (depth_vardimname)
    depths_xr = xr.DataArray(depths,dims=depth_dims,attrs={&#39;units&#39;:&#39;m&#39;,
                                                           &#39;reference&#39;:f&#39;model_{reference}&#39;,
                                                           &#39;positive&#39;:&#39;up&#39;}) #TODO: make more in line with CMEMS etc
    
    #potentially construct fullgrid info (zcc/zw)
    data_xr = reconstruct_zw_zcc(data_xr)
    
    #correct reference level
    if reference==&#39;z0&#39;:
        zw_reference = data_xr[varname_zint]
    elif reference==&#39;waterlevel&#39;:
        if varname_wl not in data_xr.variables:
            raise KeyError(f&#39;get_Dataset_atdepths() called with reference=waterlevel, but {varname_wl} variable not present&#39;)
        data_wl = data_xr[varname_wl]
        zw_reference = data_xr[varname_zint] - data_wl
    elif reference==&#39;bedlevel&#39;:
        if varname_bl not in data_xr.variables:
            raise KeyError(f&#39;get_Dataset_atdepths() called with reference=bedlevel, but {varname_bl} variable not present&#39;) #TODO: in case of zsigma/sigma it can also be -mesh2d_bldepth
        data_bl = data_xr[varname_bl]
        zw_reference = data_xr[varname_zint] - data_bl
    else:
        raise KeyError(f&#39;unknown reference &#34;{reference}&#34; (possible are z0, waterlevel and bedlevel&#39;) #TODO: make enum?
    
    print(&#39;&gt;&gt; subsetting data on fixed depth in fullgrid z-data: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    
    #get layerbool via z-interface value (zw), check which celltop-interfaces are above/on depth and which which cellbottom-interfaces are below/on depth
    bool_topinterface_abovedepth = zw_reference.isel({dimname_layw:slice(1,None)}) &gt;= depths_xr
    bool_botinterface_belowdepth = zw_reference.isel({dimname_layw:slice(None,-1)}) &lt;= depths_xr
    bool_topbotinterface_arounddepth = bool_topinterface_abovedepth &amp; bool_botinterface_belowdepth #this bool also automatically excludes all values below bed and above wl
    bool_topbotinterface_arounddepth = bool_topbotinterface_arounddepth.rename({dimname_layw:dimname_layc}) #correct dimname for interfaces to centers
    
    #subset variables that have no, time, face and/or layer dims, slice only variables with all three dims (and add to subset)
    bool_dims = [x for x in bool_topbotinterface_arounddepth.dims if x!=depth_vardimname] #exclude depth_vardimname (present if multiple depths supplied), since it is not present in pre-slice variables
    variables_toslice = [var for var in data_xr.data_vars if set(bool_dims).issubset(data_xr[var].dims)]
    
    #actual slicing with .where().max()
    ds_atdepths = data_xr[variables_toslice].where(bool_topbotinterface_arounddepth).max(dim=dimname_layc,keep_attrs=True) #set all layers but one to nan, followed by an arbitrary reduce (max in this case) #TODO: check if attributes should be passed/altered
    #TODO: suppress warning (upon plotting/load/etc): &#34;C:\Users\veenstra\Anaconda3\envs\dfm_tools_env\lib\site-packages\dask\array\reductions.py:640: RuntimeWarning: All-NaN slice encountered&#34; &gt;&gt; already merged in xarray: https://github.com/dask/dask/pull/9916
    ds_atdepths = ds_atdepths.drop_dims([dimname_layw,dimname_layc],errors=&#39;ignore&#39;) #dropping interface dim if it exists, since it does not correspond to new depths dim
    
    #add depth as coordinate var
    ds_atdepths[depth_vardimname] = depths_xr
    ds_atdepths = ds_atdepths.set_coords([depth_vardimname])
    
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return ds_atdepths</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.rasterize_ugrid"><code class="name flex">
<span>def <span class="ident">rasterize_ugrid</span></span>(<span>uds: xugrid.core.wrap.UgridDataset, ds_like: xarray.core.dataset.Dataset = None, resolution: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rasterizing ugrid dataset to regular dataset. ds_like has higher priority than <code>resolution</code>. If both are not passed, a raster is generated of at least 200x200
inspired by xugrid.plot.imshow and xugrid.ugrid.ugrid2d.rasterize/rasterize_like.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uds</code></strong> :&ensp;<code>xu.UgridDataset</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>ds_like</code></strong> :&ensp;<code>xr.Dataset</code>, optional</dt>
<dd>xr.Dataset with ed x and y variables to interpolate uds to. The default is None.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Only used if ds_like is not supplied. The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rasterize_ugrid(uds:xu.UgridDataset, ds_like:xr.Dataset = None, resolution:float = None):
    &#34;&#34;&#34;
    Rasterizing ugrid dataset to regular dataset. ds_like has higher priority than `resolution`. If both are not passed, a raster is generated of at least 200x200
    inspired by xugrid.plot.imshow and xugrid.ugrid.ugrid2d.rasterize/rasterize_like.


    Parameters
    ----------
    uds : xu.UgridDataset
        DESCRIPTION.
    ds_like : xr.Dataset, optional
        xr.Dataset with ed x and y variables to interpolate uds to. The default is None.
    resolution : float, optional
        Only used if ds_like is not supplied. The default is None.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ds : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;
    #TODO: maybe put part of code in xugrid (https://github.com/Deltares/xugrid/issues/31)
    #TODO: vars can also be rasterized with uds_facevars[var].ugrid.rasterize(resolution), but is not efficient. Wait for uds.rasterize() method: https://github.com/Deltares/xugrid/issues/61
    if not isinstance(uds,xu.core.wrap.UgridDataset):
        raise TypeError(f&#39;rasterize_ugrid expected xu.core.wrap.UgridDataset, got {type(uds)} instead&#39;)
    
    grid = uds.grid
    xu_facedim = uds.grid.face_dimension
    uds_facevars = Dataset_varswithdim(uds,xu_facedim)
    
    if ds_like is not None:
        regx = ds_like.x
        regy = ds_like.y
    else:
        xmin, ymin, xmax, ymax = grid.bounds
        dx = xmax - xmin
        dy = ymax - ymin
        if resolution is None: # check if a rasterization resolution is passed, otherwise default to 200 raster cells otherwise for the smallest axis.
            resolution = min(dx, dy) / 200
        d = abs(resolution)
        regx = np.arange(xmin + 0.5 * d, xmax, d)
        regy = np.arange(ymin + 0.5 * d, ymax, d)
    
    regx, regy, index = grid.rasterize_like(x=regx,y=regy) #TODO: this can be used to steer rasterization, eg with xstart/ystart/xres/yres
    index_da = xr.DataArray(index,dims=(&#39;y&#39;,&#39;x&#39;))
    
    print(f&#39;&gt;&gt; rasterizing ugrid dataset with {len(uds_facevars.data_vars)} face variables to shape={index_da.shape}: &#39;,end=&#39;&#39;)
    dtstart = dt.datetime.now()
    ds = uds_facevars.isel({xu_facedim:index_da})
    ds = ds.where(index_da != grid.fill_value)
    ds[&#39;x&#39;] = xr.DataArray(regx,dims=&#39;x&#39;)
    ds[&#39;y&#39;] = xr.DataArray(regy,dims=&#39;y&#39;)
    print(f&#39;{(dt.datetime.now()-dtstart).total_seconds():.2f} sec&#39;)
    
    return ds</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.plot_background"><code class="name flex">
<span>def <span class="ident">plot_background</span></span>(<span>ax=None, projection=None, google_style='satellite', resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
import contextily as ctx
fig, ax = plt.subplots(1,1)
ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs="EPSG:28992")
More info at: <a href="https://contextily.readthedocs.io/en/latest/reference.html">https://contextily.readthedocs.io/en/latest/reference.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>cartopy.mpl.geoaxes.GeoAxesSubplot</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
<dt><strong><code>projection</code></strong> :&ensp;<code>integer, cartopy._crs.CRS</code> or <code>cartopy._epsg._EPSGProjection</code>, optional</dt>
<dd>DESCRIPTION. The default is None.</dd>
<dt><strong><code>google_style</code></strong> :&ensp;<code>Nonetype</code> or <code>string</code>, optional</dt>
<dd>&nbsp;</dd>
<dt>The style of the Google Maps tiles. One of None, ‘street’, ‘satellite’, ‘terrain’, and ‘only_streets’. The default is 'satellite'.</dt>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Features to plot, options: None, 'ocean', 'rivers', 'land', 'countries', 'countries_highres', 'coastlines', 'coastlines_highres'. The default is None.</dd>
<dt><strong><code>nticks</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is 6.</dd>
<dt><strong><code>latlon_format</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
<dt><strong><code>gridlines</code></strong> :&ensp;<code>TYPE</code>, optional</dt>
<dd>DESCRIPTION. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor='none', edgecolor='gray', linewidth=0.5, linestyle=':'</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_background(ax=None, projection=None, google_style=&#39;satellite&#39;, resolution=1, features=None, nticks=6, latlon_format=False, gridlines=False, **kwargs):
    &#34;&#34;&#34;
    this definition uses cartopy to plot a geoaxis and a satellite basemap and coastlines. A faster alternative for a basemap is contextily:
    import contextily as ctx
    fig, ax = plt.subplots(1,1)
    ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery, crs=&#34;EPSG:28992&#34;)
    More info at: https://contextily.readthedocs.io/en/latest/reference.html

    Parameters
    ----------
    ax : cartopy.mpl.geoaxes.GeoAxesSubplot, optional
        DESCRIPTION. The default is None.
    projection : integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection, optional
        DESCRIPTION. The default is None.
    google_style : Nonetype or string, optional
       The style of the Google Maps tiles. One of None, ‘street’, ‘satellite’, ‘terrain’, and ‘only_streets’. The default is &#39;satellite&#39;.
    resolution : int, optional
        resolution for the Google Maps tiles. 1 works wel for global images, 12 works well for a scale of Grevelingen lake, using 12 on global scale will give you a server timeout. The default is 1.
    features : string, optional
        Features to plot, options: None, &#39;ocean&#39;, &#39;rivers&#39;, &#39;land&#39;, &#39;countries&#39;, &#39;countries_highres&#39;, &#39;coastlines&#39;, &#39;coastlines_highres&#39;. The default is None.
    nticks : TYPE, optional
        DESCRIPTION. The default is 6.
    latlon_format : bool, optional
        DESCRIPTION. The default is False.
    gridlines : TYPE, optional
        DESCRIPTION. The default is False.
    **kwargs : TYPE
        additional arguments for ax.add_feature or ax.coastlines(). examples arguments and values are: alpha=0.5, facecolor=&#39;none&#39;, edgecolor=&#39;gray&#39;, linewidth=0.5, linestyle=&#39;:&#39;

    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    ax : TYPE
        DESCRIPTION.

    &#34;&#34;&#34;

    import cartopy
    import cartopy.crs as ccrs
    import cartopy.io.img_tiles as cimgt
    import cartopy.feature as cfeature
    import cartopy.mpl.ticker as cticker

    dummy = ccrs.epsg(28992) #to make cartopy realize it has a cartopy._epsg._EPSGProjection class (maybe gets fixed with cartopy updates, see unittest test_cartopy_epsg)
    if ax is None: #provide axis projection on initialisation, cannot be edited later on
        if projection is None:
            projection=ccrs.PlateCarree() #projection of cimgt.GoogleTiles, useful default
        elif isinstance(projection, (cartopy._epsg._EPSGProjection, cartopy.crs.CRS)): #checks if argument is an EPSG projection or CRS projection (like PlateCarree, Mercator etc). Note: it was cartopy._crs.CRS before instead of cartopy.crs.CRS
            pass
        elif type(projection) is int:
            projection = ccrs.epsg(projection)
        else:
            raise TypeError(&#39;argument projection should be of type integer, cartopy._crs.CRS or cartopy._epsg._EPSGProjection&#39;)
        fig, ax = plt.subplots(subplot_kw={&#39;projection&#39;: projection})
    elif type(ax) is cartopy.mpl.geoaxes.GeoAxesSubplot:
        if projection is not None:
            print(&#39;arguments ax and projection are both provided, the projection from the ax is used so the projection argument is ignored&#39;)
    else:
        raise TypeError(&#39;argument ax should be of type cartopy.mpl.geoaxes.GeoAxesSubplot, leave argument empty or create correct instance with:\nimport cartopy.crs as ccrs\nfig, (ax1,ax2) = plt.subplots(1,2,figsize=(10,5), subplot_kw={&#34;projection&#34;: ccrs.epsg(28992)})&#39;)



    if gridlines:
        ax.gridlines(draw_labels=True)
    elif nticks is not None: #only look at nticks if gridlines are not used
        extent = ax.get_extent()
        ax.set_xticks(np.linspace(extent[0],extent[1],nticks))
        ax.set_yticks(np.linspace(extent[2],extent[3],nticks))


    if google_style is not None:
        request = cimgt.GoogleTiles(style=google_style)
        ax.add_image(request,resolution)


    if features is not None:
        if type(features) is str:
            features = [features]
        elif type(features) is not list:
            raise TypeError(&#39;argument features should be of type list of str&#39;)

        valid_featurelist = [&#39;ocean&#39;,&#39;rivers&#39;,&#39;land&#39;,&#39;countries&#39;,&#39;countries_highres&#39;,&#39;coastlines&#39;,&#39;coastlines_highres&#39;]
        invalid_featurelist = [x for x in features if x not in valid_featurelist]
        if invalid_featurelist != []:
            raise KeyError(&#39;invalid features %s requested, possible are: %s&#39;%(invalid_featurelist, valid_featurelist))

        if &#39;ocean&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;ocean&#39;, facecolor=cfeature.COLORS[&#39;water&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.OCEAN, **kwargs)
        if &#39;rivers&#39; in features:
            ax.add_feature(cfeature.RIVERS, **kwargs)
        if &#39;land&#39; in features:
            #feat = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, name=&#39;land&#39;, facecolor=cfeature.COLORS[&#39;land&#39;], scale=&#39;10m&#39;, edgecolor=&#39;face&#39;, alpha=alpha)
            #ax.add_feature(feat)
            ax.add_feature(cfeature.LAND, **kwargs)
        if &#39;countries&#39; in features:
            ax.add_feature(cfeature.BORDERS, **kwargs)
        if &#39;countries_highres&#39; in features:
            feat = cfeature.NaturalEarthFeature(category=&#39;cultural&#39;, name=&#39;admin_0_countries&#39;, scale=&#39;10m&#39;)
            ax.add_feature(feat, **kwargs)
        if &#39;coastlines&#39; in features:
            ax.add_feature(cfeature.COASTLINE, **kwargs)
        if &#39;coastlines_highres&#39; in features:
            ax.coastlines(resolution=&#39;10m&#39;, **kwargs)

    if latlon_format:
        lon_formatter = cticker.LongitudeFormatter()
        lat_formatter = cticker.LatitudeFormatter()
        ax.xaxis.set_major_formatter(lon_formatter)
        ax.yaxis.set_major_formatter(lat_formatter)


    return ax</code></pre>
</details>
</dd>
<dt id="dfm_tools.get_nc.plot_ztdata"><code class="name flex">
<span>def <span class="ident">plot_ztdata</span></span>(<span>data_xr_sel, varname, ax=None, only_contour=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_xr</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>varname</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>DESCRIPTION.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes._subplots.AxesSubplot</code>, optional</dt>
<dd>the figure axis. The default is None.</dd>
<dt><strong><code>only_contour</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheter to plot contour lines of the dataset. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>properties to give on to the pcolormesh function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>DESCRIPTION.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pc</code></strong> :&ensp;<code>matplotlib.collections.QuadMesh</code></dt>
<dd>DESCRIPTION.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ztdata(data_xr_sel, varname, ax=None, only_contour=False, **kwargs):
    &#34;&#34;&#34;
    

    Parameters
    ----------
    data_xr : TYPE
        DESCRIPTION.
    varname : TYPE
        DESCRIPTION.
    ax : matplotlib.axes._subplots.AxesSubplot, optional
        the figure axis. The default is None.
    only_contour : bool, optional
        Wheter to plot contour lines of the dataset. The default is False.
    **kwargs : TYPE
        properties to give on to the pcolormesh function.
    
    Raises
    ------
    Exception
        DESCRIPTION.

    Returns
    -------
    pc : matplotlib.collections.QuadMesh
        DESCRIPTION.
    
    &#34;&#34;&#34;
    
    if not ax: ax=plt.gca()
    
    if len(data_xr_sel[varname].shape) != 2:
        raise ValueError(f&#39;ERROR: unexpected number of dimensions in requested squeezed variable ({data_xr_sel[varname].shape}), first use data_xr.isel(stations=int) to select a single station&#39;) #TODO: can also have a different cause, improve message/testing?
    
    #repair zvalues at wl/wl (filling nans and clipping to wl/bl). bfill replaces nan values with last valid value, this is necessary to enable pcolormesh to work. clip forces data to be within bl/wl
    #TODO: put clip in preproces_hisnc to make plotting easier?
    data_xr_sel[&#39;zcoordinate_c&#39;] = data_xr_sel[&#39;zcoordinate_c&#39;].bfill(dim=&#39;laydim&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    data_xr_sel[&#39;zcoordinate_w&#39;] = data_xr_sel[&#39;zcoordinate_w&#39;].bfill(dim=&#39;laydimw&#39;).clip(min=data_xr_sel.bedlevel,max=data_xr_sel.waterlevel)
    
    # generate 2 2d grids for the x &amp; y bounds (you can also give one 2D array as input in case of eg time varying z coordinates)
    data_fromhis_zcor = data_xr_sel[&#39;zcoordinate_w&#39;].to_numpy() 
    data_fromhis_zcor = np.concatenate([data_fromhis_zcor,data_fromhis_zcor[[-1],:]],axis=0)
    time_np = data_xr_sel.time.to_numpy()
    time_cor = np.concatenate([time_np,time_np[[-1]]])
    time_mesh_cor = np.tile(time_cor,(data_fromhis_zcor.shape[-1],1)).T
    if only_contour:
        pc = data_xr_sel[varname].plot.contour(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_c&#39;, **kwargs)
    else:
        #pc = data_xr_sel[varname].plot.pcolormesh(ax=ax, x=&#39;time&#39;, y=&#39;zcoordinate_w&#39;, **kwargs) #TODO: not possible to put center values on interfaces, so more difficult approach needed
        pc = ax.pcolormesh(time_mesh_cor, data_fromhis_zcor, data_xr_sel[varname], **kwargs)
   
    return pc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dfm_tools" href="index.html">dfm_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dfm_tools.get_nc.get_ugrid_verts" href="#dfm_tools.get_nc.get_ugrid_verts">get_ugrid_verts</a></code></li>
<li><code><a title="dfm_tools.get_nc.calc_dist_pythagoras" href="#dfm_tools.get_nc.calc_dist_pythagoras">calc_dist_pythagoras</a></code></li>
<li><code><a title="dfm_tools.get_nc.calc_dist_haversine" href="#dfm_tools.get_nc.calc_dist_haversine">calc_dist_haversine</a></code></li>
<li><code><a title="dfm_tools.get_nc.intersect_edges_withsort" href="#dfm_tools.get_nc.intersect_edges_withsort">intersect_edges_withsort</a></code></li>
<li><code><a title="dfm_tools.get_nc.get_xzcoords_onintersection" href="#dfm_tools.get_nc.get_xzcoords_onintersection">get_xzcoords_onintersection</a></code></li>
<li><code><a title="dfm_tools.get_nc.polyline_mapslice" href="#dfm_tools.get_nc.polyline_mapslice">polyline_mapslice</a></code></li>
<li><code><a title="dfm_tools.get_nc.get_formula_terms" href="#dfm_tools.get_nc.get_formula_terms">get_formula_terms</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma" href="#dfm_tools.get_nc.reconstruct_zw_zcc_fromsigma">reconstruct_zw_zcc_fromsigma</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc_fromz" href="#dfm_tools.get_nc.reconstruct_zw_zcc_fromz">reconstruct_zw_zcc_fromz</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc_fromzsigma" href="#dfm_tools.get_nc.reconstruct_zw_zcc_fromzsigma">reconstruct_zw_zcc_fromzsigma</a></code></li>
<li><code><a title="dfm_tools.get_nc.reconstruct_zw_zcc" href="#dfm_tools.get_nc.reconstruct_zw_zcc">reconstruct_zw_zcc</a></code></li>
<li><code><a title="dfm_tools.get_nc.get_Dataset_atdepths" href="#dfm_tools.get_nc.get_Dataset_atdepths">get_Dataset_atdepths</a></code></li>
<li><code><a title="dfm_tools.get_nc.rasterize_ugrid" href="#dfm_tools.get_nc.rasterize_ugrid">rasterize_ugrid</a></code></li>
<li><code><a title="dfm_tools.get_nc.plot_background" href="#dfm_tools.get_nc.plot_background">plot_background</a></code></li>
<li><code><a title="dfm_tools.get_nc.plot_ztdata" href="#dfm_tools.get_nc.plot_ztdata">plot_ztdata</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>